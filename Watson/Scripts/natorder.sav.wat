declareconstant "LESS_EQ_ADD";
declareconstant "LESS_OR_ADD";
declareconstant "LESS_ADD1";
declareconstant "LESS_ADD";
declareconstant "REALSUBNATTYPE";
declareconstant "NOT_SUC_ADD_LEQ";
declareconstant "NOT_GREATER_EQ";
declareconstant "NOT_GREATER";
declareconstant "NOT_NUM_EQ";
declareconstant "NOT_LEQ_SUC";
declareconstant "NOT_SUC_LEQ_0";
declareconstant "ADD_MONO_LEQ";
declareconstant "EQ_LEQ";
declareconstant "LESS_LEQ_TRANS";
declareconstant "LEQ_LESS_TRANS";
declareconstant "LESS_MULT2";
declareconstant "LESS_0_FALSE";
declareconstant "NOT_LEQ";
declareconstant "LEQ_CASES";
declareconstant "GREATER_EQ";
declareconstant "LESS_LESS_CASES";
declareconstant "LEQ_IMP_LESS_SUC";
declareconstant "NOT_SUC_LEQ";
declareconstant "LESS_ADD_SUCF";
declareconstant "LESS_ADD_SUC";
declareconstant "FLESS_ADD_SUC";
declareconstant "LESS_EQ_ANTISYM";
declareconstant "LESS_MONO_MULTF";
declareconstant "LESS_MONO_MULT";
declareconstant "FLESS_MONO_MULT";
declareconstant "MULT_SUC";
declareconstant "LEQ_LEQ_MONO";
declareconstant "LEQ_TRANS";
declareconstant "LESS_SUC_NOT";
declareconstant "LEQ_ADDF";
declareconstant "LEQ_ADD";
declareconstant "FLEQ_ADD";
declareconstant "LESS_ADD_NZF";
declareconstant "LESS_ADD_NZ";
declareconstant "FLESS_ADD_NZ";
declareconstant "NOT_SUC_LESS";
declareconstant "NOT_LESS";
declareconstant "LESS_EQ_BOOL";
declareconstant "LEQ_ANTISYM";
declareconstant "SUC_LESSF";
declareconstant "LEQ_MONO_ADD_EQF";
declareconstant "LEQ_MONO_ADD_EQ";
declareconstant "LESS_MONO_ADD_EQ";
declareconstant "LESS_MONO_ADD_INVF";
declareconstant "LESS_MONO_ADD_INV";
declareconstant "FORALL_LESS_MONO_ADD_INVF";
declareconstant "FORALL_LESS_MONO_ADD_INV";
declareconstant "LESS_MONO_ADDF";
declareconstant "LESS_MONO_ADD";
declareconstant "FORALL_LESS_MONO_ADDF";
declareconstant "FORALL_LESS_MONO_ADD";
declareconstant "BOUNDED_N";
declareconstant "LESS_LESS_SUC";
declareconstant "LESS_ANTISYMF";
declareconstant "LESS_ANTISYM";
declareconstant "FORALL_LESS_ANTISYM";
declareconstant "LESS_TRANSF";
declareconstant "LESS_TRANS";
declareconstant "FORALL_LESS_TRANS";
declareconstant "LESS_IMP_LEQ";
declareconstant "LEQ_REFL";
declareconstant "NOT_ADD_LESSF";
declareconstant "NOT_ADD_LESS";
declareconstant "LESS_NOT_SUC";
declareconstant "LESS_SUC_EQ_COR";
declareconstant "LESS_EQ_MONO";
declareconstant "ALL_GEQ_0";
declareconstant "LEQ_SUC_REFL";
declareconstant "LESS_EQ";
declareconstant "OR_LESS";
declareconstant "LESS_OR";
declareconstant "LESS_CASES_IMP";
declareconstant "LESS_CASESF";
declareconstant "LESS_CASES";
declareconstant "FORALL_LESS_CASES";
declareconstant "LESS_0_CASES_INV";
declareconstant "LESS_0_CASES";
declareconstant "LESS_EQ_SUC_LESS";
declareconstant "LESS_MONO_EQ";
declareconstant "LESS_MONO_REVF";
declareconstant "LESS_MONO_REV";
declareconstant "LEQ_SUC";
declareconstant "LESS_SUC_SUCF";
declareconstant "LESS_SUC_SUC";
declareconstant "LESS_NOT_EQF";
declareconstant "LESS_NOT_EQ";
declareconstant "EQ_NOT_LESSF";
declareconstant "EQ_NOT_LESS";
declareconstant "SUC_EQ_LESSF";
declareconstant "SUC_EQ_LESS";
declareconstant "LESS_0F";
declareconstant "LESS_0";
declareconstant "FORALL_LESS_0";
declareconstant "LESS_SUC_IMPF";
declareconstant "LESS_SUC_IMP";
declareconstant "LESS_THM";
declareconstant "LESS_LEMMA1F";
declareconstant "LESS_LEMMA1";
declareconstant "LESS_LEMMA2F";
declareconstant "LESS_LEMMA2";
declareconstant "LESS_SUC_REFLF";
declareconstant "LESS_SUC_REFL";
declareconstant "FORALL_LESS_SUC_REFL";
declareconstant "LESS_SUCF";
declareconstant "LESS_SUC";
declareconstant "LESS_MONOF";
declareconstant "LESS_MONO";
declareconstant "SUC_IDF";
declareconstant "SUC_ID";
declareconstant "SUB_REFL";
declareconstant "LESS_0_0";
declareconstant "LEQ_0";
declareconstant "NOT_LESS_0F";
declareconstant "NOT_LESS_0";
declareconstant "FNOT_LESS_0";
declareconstant "ElimForall";
declareconstant "INSTANTIATEF";
declareconstant "SUC_LESS";
declareconstant "MP_THMF";
declareconstant "MP_THM";
declareconstant "LESS_NOT_REFL";
declareconstant "LESSBOOL2";
declareconstant "LESSBOOL";
declareconstant "NATLESS2";
declareconstant "NOT_LESS_THAN_SELF";
declareconstant "NATLESSSCIN";
declareconstant "MINUSSUCC_NAT";
declareconstant "INDUCTION_NAT";
declareconstant "PLUSSCIN_NAT";
declareconstant "ZEROMINUS_NAT";
declareconstant "PLUSTYPE_NAT";
declareconstant "PLUSSUCC_NAT";
declareconstant "PLUSMINUS_NAT";
declareconstant "MINUSZERO_NAT";
declareconstant "NATSNONNEG";
declareconstant "MINUSZERO2";
declareconstant "NOT_LEMMA";
declareconstant "ABSOLUTE_ONE";
declareconstant "ABSOLUTE_ZERO";
declareconstant "PLUSID_NAT";
declareconstant "SUCCNOTZERO_NAT";
declareconstant "NATLESS";
declareconstant "NATPLUS";
declareconstant "MINUSCOMP";
declareconstant "LESS_OR_EQ";
declareconstant "GREATER_OR_EQ";
declareconstant "REAL_NOT_LESS";
declareconstant "DIFF_EQ";
declareconstant "POS_SIGN";
declareconstant "REAL_LESS_CANCEL";
declareconstant "REAL_LESS_TRANS";
declareconstant "EQUATION_TO_DIFFERENCE";
declareconstant "X2";
declareconstant "X1";
declareconstant "X";
declareconstant "REAL_UNTYPE";
declareconstant "REAL_UNTYPE_1";
declareconstant "REAL_TYPE";
declareconstant "REAL_TYPE_1";
declareconstant "ALL_CANCEL";
declareconstant "ALL_CANCEL_7";
declareconstant "ALL_CANCEL_6";
declareconstant "ALL_CANCEL_5";
declareconstant "ALL_CANCEL_4";
declareconstant "ALL_CANCEL_3";
declareconstant "ALL_CANCEL_2";
declareconstant "ALL_CANCEL_1";
declareconstant "FIXBREAKMINUS";
declareconstant "GETPLUS";
declareconstant "ZEROORSUCC";
declareconstant "POS_ZERO";
declareconstant "POS_ONE";
declareconstant "SQUARE_POS";
declareconstant "NOTBOTHPOS";
declareconstant "ZERONOTPOS";
declareconstant "POSASSERT";
declareconstant "ALT_POS_DEF";
declareconstant "NOT_EQ";
declareconstant "GREATER_EQ_REAL";
declareconstant "LESS_EQ_REAL";
declareconstant "GREATER";
declareconstant "REAL_LESS_DEF";
declareconstant "DISTANCEFLIP";
declareconstant "MINUSFLIP";
declareconstant "TRICHOTOMY";
declareconstant "POSTIMES";
declareconstant "POSPLUS";
declareconstant "POSTYPE";
declareconstant "REALABS";
declareconstant "ABSREAL";
declareconstant "Positive";
declareconstant "ZEROSELFINV";
declareconstant "SUBTRACT_DIFF";
declareconstant "MINUSZERO";
declareconstant "MINUSMINUS";
declareconstant "PLUSINVDISTS";
declareconstant "PLUSINVDIST";
declareconstant "SUBTRACT_SUM";
declareconstant "ADD_CANCEL";
declareconstant "MINUSPLUS";
declareconstant "BREAKMINUS";
declareconstant "SIGNPULL";
declareconstant "PREDTYPE";
declareconstant "PREDSCIN";
declareconstant "Pred";
declareconstant "NATMINUSSCIN";
declareconstant "NAT_SUB";
declareconstant "NATMINUSTYPE";
declareconstant "NATMINUSCOMP";
declareconstant "NAT__SUB";
declareconstant "LESS1";
declareconstant "FINDGCD";
declareconstant "REALNUMERAL2";
declareconstant "REALNUMERAL";
declareconstant "TYPENUMERAL";
declareconstant "GCD";
declareconstant "EQEVAL2";
declareconstant "GCDTYPE";
declareconstant "GCD2";
declareconstant "GCD1";
declareconstant "gcd";
declareconstant "odd";
declareconstant "even";
declareconstant "INDUCT_TAC";
declareconstant "INDUCT_TAC_2";
declareconstant "INDUCT_TAC_1";
declareconstant "INDUCTION";
declareconstant "SAMESUCC";
declareconstant "SUCCNOTZERO";
declareconstant "FACTORZERO";
declareconstant "TIMESZERO";
declareconstant "COMMDIST";
declareconstant "EPLUSID";
declareconstant "COMMPLUSID";
declareconstant "REALZERO";
declareconstant "TIMESINTDIV";
declareconstant "NATCALC";
declareconstant "DIVSCIN";
declareconstant "ZERONOTONE";
declareconstant "EVALEQ";
declareconstant "LESSTYPE";
declareconstant "MODSCIN";
declareconstant "MODTYPE";
declareconstant "MODCOMP";
declareconstant "MOD_DEF";
declareconstant "INT_DIVSCIN";
declareconstant "INT_DIVTYPE";
declareconstant "INT_DIV";
declareconstant "TIMESSCIN";
declareconstant "TIMESCOMP";
declareconstant "TIMESTYPE2";
declareconstant "REALNAT";
declareconstant "MINUSSCIN";
declareconstant "PLUSSCIN";
declareconstant "PLUSCOMP";
declareconstant "PLUSTYPE2";
declareconstant "ZERONAT";
declareconstant "ONENAT";
declareconstant "BUILTIN";
declareconstant "EQ_COMP";
declareconstant "LESSCOMP";
declareconstant "LESS_COMP";
declareconstant "LESS";
declareconstant "ABSOLUTE2";
declareconstant "ABSOLUTE";
declareconstant "TIMES_POS";
declareconstant "PLUS_POS";
declareconstant "Absolute";
declareconstant "DIST";
declareconstant "TIMESDIV";
declareconstant "TD";
declareconstant "TIMESID";
declareconstant "TIMESASSOC";
declareconstant "TIMESCOMM";
declareconstant "DIVTYPE";
declareconstant "TIMESTYPE";
declareconstant "PLUSMINUS";
declareconstant "PM";
declareconstant "PLUSID";
declareconstant "PLUSASSOC";
declareconstant "PLUSCOMM";
declareconstant "MINUSTYPE";
declareconstant "PLUSTYPE";
declareconstant "Real";
declareconstant "COMP_DIV";
declareconstant "COMP_TIMES";
declareconstant "COMP_MINUS";
declareconstant "COMP_PLUS";
declareconstant "COMPLESSTYPE";
declareconstant "COMPEQTYPE";
declareconstant "COMPMODTYPE";
declareconstant "COMPDIVTYPE";
declareconstant "COMPTIMESTYPE";
declareconstant "COMPMINUSTYPE";
declareconstant "COMPPLUSTYPE";
declareconstant "MAKE_NAT";
declareconstant "MAKE_NAT_2";
declareconstant "MAKE_NAT_1";
declareconstant "COMP_NAT_2";
declareconstant "COMP_NAT";
declareconstant "Nat";
declareconstant "True";
declareconstant "TRUERETRACT";
declareconstant "Bool";
declareconstant "BOOL_RETRACT";
declareconstant "POINTTYPE";
declareconstant "UNIONTYPE";
declareconstant "UNIONRETRACT";
declareconstant "PRODTYPE";
declareconstant "PRODRETRACT";
declareconstant "ARROWTYPE";
declareconstant "ARROWRETRACT";
declareconstant "TADDTOP";
declareconstant "TADDBOTH";
declareconstant "TADDRIGHT";
declareconstant "TADDLEFT";
declareconstant "TREMTOP";
declareconstant "TREMBOTH";
declareconstant "TREMRIGHT";
declareconstant "TREMLEFT";
declareconstant "Complement2";
declareconstant "Subset2";
declareconstant "SetDifference2";
declareconstant "Intersection2";
declareconstant "Union2";
declareconstant "SetEquiv2";
declareconstant "DiffSymmDisj";
declareconstant "UnionDisj";
declareconstant "Disj_NotForsome";
declareconstant "DisjIdem";
declareconstant "DisjEmpty";
declareconstant "EmptyDisj";
declareconstant "DisjUniv";
declareconstant "UnivDisj";
declareconstant "DisjSymm";
declareconstant "DisjScin";
declareconstant "DisjType";
declareconstant "SubsetNotPsubset";
declareconstant "PsubsetNotSubset";
declareconstant "PsubsetSubset";
declareconstant "PsubsetUniv";
declareconstant "UnivPsubset";
declareconstant "EmptyPsubset";
declareconstant "PsubsetEmpty";
declareconstant "PsubsetIdem";
declareconstant "PsubsetScin";
declareconstant "PsubsetType";
declareconstant "DiffSubset";
declareconstant "Subset_InterAbsorption";
declareconstant "InterSymmSubset";
declareconstant "InterSubset";
declareconstant "SubsetUnionSymm";
declareconstant "SubsetUnion";
declareconstant "Subset_UnionAbsorption";
declareconstant "UnivSubset";
declareconstant "SubsetUniv";
declareconstant "SubsetEmpty";
declareconstant "EmptySubset";
declareconstant "SubsetAntisym";
declareconstant "SubsetIdem";
declareconstant "SubsetTrans";
declareconstant "FORALL_3pt82a";
declareconstant "SubsetScin";
declareconstant "SubsetType";
declareconstant "InDiff";
declareconstant "DiffInter_Union";
declareconstant "DiffUnion";
declareconstant "UnionDiff_absorption";
declareconstant "InterDiff_Empty";
declareconstant "Diff_InterCompl";
declareconstant "DiffInter";
declareconstant "DiffSymm";
declareconstant "DiffIdem";
declareconstant "UnivDiff";
declareconstant "DiffUniv";
declareconstant "EmptyDiff";
declareconstant "DiffEmpty";
declareconstant "DubDiff";
declareconstant "DiffScin";
declareconstant "DiffType";
declareconstant "InInter";
declareconstant "UnionUniv_InterEmpty";
declareconstant "DEMORGANb";
declareconstant "DEMORGANa";
declareconstant "InterCompl";
declareconstant "UnionInter";
declareconstant "InterUnion";
declareconstant "InterEqEmpty";
declareconstant "InterUniv";
declareconstant "UnivInter";
declareconstant "InterEmpty";
declareconstant "EmptyInter";
declareconstant "InterIdem";
declareconstant "InterAssoc";
declareconstant "InterSymm";
declareconstant "InterScin";
declareconstant "InterType";
declareconstant "InUnion";
declareconstant "UnionEqUniv";
declareconstant "UnionEqEmpty";
declareconstant "UnionCompl";
declareconstant "UnionEmpty";
declareconstant "EmptyUnion";
declareconstant "UnionUniv";
declareconstant "UnivUnion";
declareconstant "UnionIdem";
declareconstant "UnionAssoc";
declareconstant "UnionSymm";
declareconstant "UnionScin";
declareconstant "UnionType";
declareconstant "InCompl";
declareconstant "ComplEmpty_Univ";
declareconstant "ComplUniv_Empty";
declareconstant "EqCompl";
declareconstant "ComplEq";
declareconstant "ComplEqUniv";
declareconstant "ComplUniv";
declareconstant "ComplEmpty";
declareconstant "DubComplement";
declareconstant "EqEmpty";
declareconstant "NotEqEmpty";
declareconstant "EqUniv";
declareconstant "NotEq";
declareconstant "EmptyNotUniv";
declareconstant "UnivNotEmpty";
declareconstant "EquivSymm";
declareconstant "EquivType";
declareconstant "EquivBool";
declareconstant "InUniv";
declareconstant "InEmpty";
declareconstant "ReverseIn";
declareconstant "ApplyIn";
declareconstant "InType";
declareconstant "INBOOL";
declareconstant "EmptySet";
declareconstant "TrueSet";
declareconstant "SETRETRACT";
declareconstant "Disjoint";
declareconstant "Psubset";
declareconstant "Complement";
declareconstant "Subset";
declareconstant "SetDifference";
declareconstant "Intersection";
declareconstant "Union";
declareconstant "SetEquiv";
declareconstant "Set";
declareconstant "FS_SEQUENT";
declareconstant "FS6";
declareconstant "FS5";
declareconstant "FS4";
declareconstant "FS3";
declareconstant "FS2";
declareconstant "FS1";
declareconstant "FS0b";
declareconstant "FS0";
declareconstant "SETUP_SEQUENT";
declareconstant "INR";
declareconstant "INL";
declareconstant "INSCOUT";
declareconstant "IN";
declareconstant "EXISTR";
declareconstant "EXISTL";
declareconstant "FORSOMEANDDIST";
declareconstant "UNIVR";
declareconstant "UNIVL";
declareconstant "CUT";
declareconstant "IFFR";
declareconstant "IFFL";
declareconstant "WEAKR";
declareconstant "WEAKL";
declareconstant "EXR";
declareconstant "EXL";
declareconstant "AXIOM";
declareconstant "IFR";
declareconstant "IFL";
declareconstant "ORR";
declareconstant "ORL";
declareconstant "ANDR";
declareconstant "ANDL";
declareconstant "NEGR";
declareconstant "NEGL";
declareconstant "SELFLABEL";
declareconstant "GETR";
declareconstant "GETL";
declareconstant "UNIV_EQ_TAC";
declareconstant "UNIV_EQ";
declareconstant "UNIV_TAC";
declareconstant "9pt26";
declareconstant "9pt25";
declareconstant "9pt24";
declareconstant "9pt23";
declareconstant "9pt22";
declareconstant "9pt21";
declareconstant "9pt20";
declareconstant "9pt18c";
declareconstant "9pt18b";
declareconstant "9pt18a";
declareconstant "9pt11";
declareconstant "9pt10";
declareconstant "9pt8";
declareconstant "9pt7";
declareconstant "9pt6";
declareconstant "9pt5";
declareconstant "9pt4d";
declareconstant "9pt4c";
declareconstant "9pt4b";
declareconstant "9pt4a";
declareconstant "9pt3c";
declareconstant "9pt3b";
declareconstant "9pt3a";
declareconstant "8pt19E";
declareconstant "8pt19U";
declareconstant "8pt16E";
declareconstant "8pt16U";
declareconstant "8pt15E";
declareconstant "8pt15U";
declareconstant "8pt13E";
declareconstant "8pt13U";
declareconstant "FORSOMERBOOL3";
declareconstant "FORSOMERBOOL2";
declareconstant "FORALLRBOOL3";
declareconstant "FORALLRBOOL2";
declareconstant "UNIV_RANGE_2";
declareconstant "8pt14E";
declareconstant "L";
declareconstant "R";
declareconstant "8pt14U";
declareconstant "9pt30b";
declareconstant "9pt30a";
declareconstant "9pt16b";
declareconstant "9pt16a";
declareconstant "9pt16a1";
declareconstant "PRE9pt12";
declareconstant "CONVERT_IMP_2";
declareconstant "CONVERT_IMP_1";
declareconstant "ONEPOINT";
declareconstant "UNIV_RANGE_1";
declareconstant "forsomer3";
declareconstant "forsomer2";
declareconstant "FORSOMERBOOL";
declareconstant "forsomer";
declareconstant "forallr2";
declareconstant "FORALLRBOOL";
declareconstant "forallr";
declareconstant "EQ_TRANS";
declareconstant "COMMUTE_LEVEL_QUANT";
declareconstant "ALT_QUANT_AGAIN";
declareconstant "TAB_CEX";
declareconstant "TAB_WITNESS";
declareconstant "ANY_INSTANCE";
declareconstant "forallcase";
declareconstant "forsomecase";
declareconstant "CEX_TAC";
declareconstant "CHOICE_TAC";
declareconstant "CEX";
declareconstant "SUBTYPE";
declareconstant "COUNTER";
declareconstant "COUNTER1";
declareconstant "CHOICE";
declareconstant "ALT_QUANT_IMP";
declareconstant "TAB_ALL_NEW_2";
declareconstant "TAB_ALL_NEW_1";
declareconstant "TAB_SOME_NEW_2";
declareconstant "TAB_SOME_NEW_1";
declareconstant "TAB_SOME_2";
declareconstant "TAB_ALL_2";
declareconstant "TAB_SOME";
declareconstant "TAB_ALL";
declareconstant "TAB_XOR_2";
declareconstant "TAB_XOR";
declareconstant "TAB_IFF_2";
declareconstant "TAB_IFF";
declareconstant "TAB_IF_2";
declareconstant "TAB_IF";
declareconstant "TAB_OR_2";
declareconstant "TAB_OR";
declareconstant "TAB_AND_2";
declareconstant "TAB_AND";
declareconstant "TAB_NOT_2";
declareconstant "TAB_NOT";
declareconstant "FORALL_IMP_FORSOME_EQ";
declareconstant "FORSOME_NOTFORALL";
declareconstant "FORALL_NOTFORSOME";
declareconstant "FORSOMEDIST2";
declareconstant "FORALLORDIST";
declareconstant "FORALLOR";
declareconstant "FORALLNOT";
declareconstant "NOTFORALL";
declareconstant "FORALLSWITCH2";
declareconstant "FORSOMEDROP";
declareconstant "FORALLDROP";
declareconstant "FORALLSWITCH";
declareconstant "FORALLDIST";
declareconstant "DINSTANTIATEF1";
declareconstant "DINSTANTIATE";
declareconstant "INSTANTIATE";
declareconstant "TESTSIMP";
declareconstant "CONDSIMP";
declareconstant "XORALTDEF";
declareconstant "CASEPREP";
declareconstant "CONDCASES2";
declareconstant "IMPTOCOND";
declareconstant "CONDCASES";
declareconstant "CONDCASESL1F";
declareconstant "CONDCASESL1";
declareconstant "BEQSUBS";
declareconstant "ASRTCOND";
declareconstant "EQSYMM2";
declareconstant "CONVORAND";
declareconstant "CONVORIMP";
declareconstant "CONVANDOR";
declareconstant "CONVANDIMP";
declareconstant "CONVIMPOR";
declareconstant "CONVIMPAND";
declareconstant "IDIS4";
declareconstant "IDIS3";
declareconstant "IDIS2";
declareconstant "IDIS1";
declareconstant "3pt89";
declareconstant "AP3pt88";
declareconstant "3pt88";
declareconstant "3pt87";
declareconstant "AP3pt86b";
declareconstant "3pt86b";
declareconstant "AP3pt86a";
declareconstant "3pt86a";
declareconstant "3pt85b";
declareconstant "3pt85a";
declareconstant "3pt84c";
declareconstant "3pt84b";
declareconstant "3pt83F";
declareconstant "3pt83";
declareconstant "3pt82cF";
declareconstant "3pt82c";
declareconstant "3pt82bF";
declareconstant "3pt82b";
declareconstant "3pt82aF";
declareconstant "3pt82a";
declareconstant "3pt81F";
declareconstant "3pt81";
declareconstant "3pt80";
declareconstant "3pt79F";
declareconstant "3pt79";
declareconstant "3pt78";
declareconstant "MOPF";
declareconstant "MOP";
declareconstant "3pt76eF";
declareconstant "3pt76e";
declareconstant "3pt76dF";
declareconstant "3pt76d";
declareconstant "3pt76cF";
declareconstant "3pt76c";
declareconstant "3pt76bF";
declareconstant "3pt76b";
declareconstant "3pt76aF";
declareconstant "3pt76a";
declareconstant "3pt75F";
declareconstant "3pt75";
declareconstant "3pt74";
declareconstant "ILID";
declareconstant "IRZERF";
declareconstant "IRZER";
declareconstant "IREFF";
declareconstant "IREF";
declareconstant "3pt70";
declareconstant "3pt69";
declareconstant "3pt68F";
declareconstant "3pt68";
declareconstant "3pt67F";
declareconstant "3pt67";
declareconstant "3pt66";
declareconstant "3pt64";
declareconstant "3pt65";
declareconstant "3pt62";
declareconstant "IDISB";
declareconstant "CONTP";
declareconstant "IDEF3";
declareconstant "IDEF2";
declareconstant "XALTDEF";
declareconstant "BALTDEF";
declareconstant "REPL";
declareconstant "3pt50";
declareconstant "3pt49";
declareconstant "3pt48";
declareconstant "CDISD";
declareconstant "DDISC";
declareconstant "3pt44b";
declareconstant "3pt44a";
declareconstant "L3pt43";
declareconstant "3pt43bF";
declareconstant "3pt43b";
declareconstant "3pt43aF";
declareconstant "3pt43a";
declareconstant "CCON";
declareconstant "CDISC";
declareconstant "CZERF";
declareconstant "CZER";
declareconstant "CID";
declareconstant "CIDEM";
declareconstant "CASSOC";
declareconstant "CSYM";
declareconstant "DUAL";
declareconstant "REMFLIP";
declareconstant "SREMFLIP";
declareconstant "NOTCLEAN";
declareconstant "ASSERTCLEAN";
declareconstant "REMA";
declareconstant "AF";
declareconstant "AT";
declareconstant "FLIPALL";
declareconstant "FLIPPASTC";
declareconstant "FLIPPASTD";
declareconstant "FLIPPASTX";
declareconstant "FLIPPASTB";
declareconstant "FLIPPASTN";
declareconstant "FLIPPASTA";
declareconstant "SFLIPALL";
declareconstant "XORFLIP";
declareconstant "BFLIP";
declareconstant "DEMa";
declareconstant "DEMb";
declareconstant "GR3";
declareconstant "GR2";
declareconstant "3pt32F";
declareconstant "3pt32";
declareconstant "DID";
declareconstant "DDISD";
declareconstant "DZERF";
declareconstant "DZER";
declareconstant "MUTINT";
declareconstant "MUTASSOC";
declareconstant "XORASSOC";
declareconstant "XORSYM";
declareconstant "NEQ";
declareconstant "DUBNEG2";
declareconstant "NEGF";
declareconstant "3pt15bF";
declareconstant "3pt15b";
declareconstant "3pt15a";
declareconstant "3pt14";
declareconstant "3pt11";
declareconstant "APLZ";
declareconstant "THMAP";
declareconstant "ASRTRIGHT";
declareconstant "ASRTLEFT";
declareconstant "ASSRTBOTH";
declareconstant "MKASRT";
declareconstant "GCLEAN";
declareconstant "STT";
declareconstant "STR";
declareconstant "STL";
declareconstant "EQT";
declareconstant "BCONV";
declareconstant "ASRTEQ";
declareconstant "LZ";
declareconstant "CONS";
declareconstant "IDEF";
declareconstant "GR";
declareconstant "DXMF";
declareconstant "BIDF";
declareconstant "DXM";
declareconstant "DDIS";
declareconstant "DIDEM";
declareconstant "DSYM";
declareconstant "DASSOC";
declareconstant "XORDEF";
declareconstant "BDIS";
declareconstant "FDEF";
declareconstant "BID2";
declareconstant "BID";
declareconstant "BSYM";
declareconstant "BASSOC";
declareconstant "PROVETAUT2";
declareconstant "PROVETAUT";
declareconstant "CNRULE3";
declareconstant "CNRULE2";
declareconstant "CNRULE1";
declareconstant "IRULE3";
declareconstant "IRULE2";
declareconstant "IRULE1";
declareconstant "NRULE2";
declareconstant "NRULE1";
declareconstant "XRULE3";
declareconstant "XRULE2";
declareconstant "XRULE1";
declareconstant "CRULE3";
declareconstant "CRULE2";
declareconstant "CRULE1";
declareconstant "DRULE3";
declareconstant "DRULE2";
declareconstant "DRULE1";
declareconstant "BRULE3";
declareconstant "BRULE2";
declareconstant "BRULE1";
declareconstant "NEWTAUT";
declareconstant "ALL_EXP";
declareconstant "ALT_PUSH";
declareconstant "CN_EXP";
declareconstant "XOR_EXP";
declareconstant "IFF_EXP";
declareconstant "NONTRIV2a";
declareconstant "IF_EXP";
declareconstant "OR_EXP";
declareconstant "AND_EXP";
declareconstant "NOT_EXP";
declareconstant "ASSERT_EXP";
declareconstant "MAKE_CASE";
declareconstant "FORSOMEBOOL2";
declareconstant "FORALLBOOL2";
declareconstant "BOOLDEF2";
declareconstant "ASSERT_UNEXP";
declareconstant "ANDUNPACK";
declareconstant "DUBNEG";
declareconstant "BOOLDEF0";
declareconstant "UNPACK";
declareconstant "EXAMPLE1";
declareconstant "CNBOOL";
declareconstant "CONSCIN";
declareconstant "CONTYPE";
declareconstant "CONVIF";
declareconstant "IMPTYPE";
declareconstant "CTYPE";
declareconstant "DTYPE";
declareconstant "NTYPE";
declareconstant "XORBOOL";
declareconstant "XORSCIN";
declareconstant "XORTYPE";
declareconstant "XOR";
declareconstant "ALLASSERTS";
declareconstant "BTYPE";
declareconstant "ASSERT2";
declareconstant "TWOASSERTS";
declareconstant "ASSERTSCOUT";
declareconstant "ASSERT";
declareconstant "IFFSCIN";
declareconstant "IFSCIN";
declareconstant "ORSCIN";
declareconstant "NOTBOOLDROP";
declareconstant "ANDSCIN";
declareconstant "IFFBOOL";
declareconstant "IFF";
declareconstant "IFBOOL";
declareconstant "IF";
declareconstant "ALTORDEF";
declareconstant "NOT";
declareconstant "ORBOOL";
declareconstant "OR";
declareconstant "ANDBOOL";
declareconstant "AND";
declareconstant "BOOLDEF";
declareconstant "FALSEBOOL";
declareconstant "TRUEBOOL";
declareconstant "forsome2";
declareconstant "FORSOMEBOOL";
declareconstant "forsome";
declareconstant "NOTBOOL";
declareconstant "NOT1";
declareconstant "forall2";
declareconstant "FORALLBOOL";
declareconstant "forall";
declareconstant "EQBOOL";
declareconstant "bool";
declareconstant "EQSYMM";
declareconstant "LAMBDAREMOVE3";
declareconstant "LAMBDAREMOVE2";
declareconstant "LAMBDAREMOVE1";
declareconstant "LAMBDAREMOVE";
declareconstant "LAMBDAINTRO3";
declareconstant "LAMBDAINTRO2";
declareconstant "LAMBDAINTRO1";
declareconstant "LAMBDAINTRO";
declareconstant "LABELINTRO";
declareconstant "goto";
declareconstant "INPUT_AT";
declareconstant "value";
declareconstant "left_case";
declareconstant "right_case";
declareconstant "left";
declareconstant "right";
declareconstant "INPUTS2";
declareconstant "up";
declareconstant "upfun";
declareconstant "BINDLABELS";
declareconstant "APPLYATLABELS";
declareconstant "APPLYATLABEL";
declareconstant "APPLYATLABEL0";
declareconstant "LABELTERM";
declareconstant "LABELTERMS_CASE";
declareconstant "LABELTERMS_UNARY";
declareconstant "LABELTERMS_ABSTRACT";
declareconstant "LABELTERMS_SPLIT";
declareconstant "LABELTERMS_FOUND";
declareconstant "LABELTERMS";
declareconstant "POP_CASE";
declareconstant "POP_CASE_1";
declareconstant "POP_CASE_2";
declareconstant "ANTI_UNEVAL_TAC";
declareconstant "TYPEBIND";
declareconstant "UNEVAL_TAC";
declareconstant "GET";
declareconstant "GET2";
declareconstant "GET1";
declareconstant "GET0";
declareconstant "ALLASSOCS";
declareconstant "ASSOCS";
declareconstant "VIEWCASES";
declareconstant "LOOP_TAC";
declareconstant "ALL_STEPS";
declareconstant "STOPLOOP";
declareconstant "STARTLOOP";
declareconstant "LISTBIND";
declareconstant "PAIRBIND";
declareconstant "VALUE";
declareconstant "VALUE0";
declareconstant "PI2F";
declareconstant "PI1F";
declareconstant "REVPIVOT";
declareconstant "PIVOT";
declareconstant "TOPDOWN_PREFIX";
declareconstant "TOPDOWN_INFIX";
declareconstant "TOPDOWN_CASE";
declareconstant "TOPDOWN";
declareconstant "EVERYWHERE2";
declareconstant "EVERYWHERE";
declareconstant "EVERYWHERE_INFIX";
declareconstant "EVERYWHERE_PREFIX";
declareconstant "EVERYWHERE_ABS";
declareconstant "STRONG_EVERYWHERE_CASE";
declareconstant "EVERYWHERE_CASE";
declareconstant "BOTH_CASES";
declareconstant "RIGHT_CASE";
declareconstant "LEFT_CASE";
declareconstant "RL";
declareconstant "RIGHT";
declareconstant "RIGHT2";
declareconstant "RIGHT1";
declareconstant "LEFT";
declareconstant "LEFT2";
declareconstant "LEFT1";
declareconstant "PCASEINTRO";
declareconstant "ID";
declareconstant "PI2";
declareconstant "PI1";
declareconstant "IGNOREFIRST";
declareconstant "HYP";
declareconstant "ODDCHOICE";
declareconstant "EQUATION";
declareconstant "NONTRIV";
declareconstant "REFLEX";
declareconstant "CASEINTRO";
declareconstant "FNDIST";
declareconstant "Id";
declareconstant "P2";
declareconstant "P1";
declareconstant "COMP";
declareconstant "TYPES";
declareconstant "OUTPUT";
declareconstant "INPUT";
declareconstant "FLIP";
declareconstant "UNEVAL";
declareconstant "EVAL";
declareconstant "BIND";
declareconstant "false";
declareconstant "true";
addoperator ".<." "(0) , 0";
addoperator ".+." "(0) , 0";
addoperator "~=" "(0) , 0";
addoperator ">=" "(0) , 0";
addoperator "=<" "(0) , 0";
addoperator ">" "(0) , 0";
addoperator ".-." "(0) , 0";
addoperator "%" "(0) , 0";
addoperator "./." "(0) , 0";
addoperator "<" "(0) , 0";
addoperator "/" "(0) , 0";
addoperator "*" "(0) , 0";
addoperator "-" "(0) , 0";
addoperator "+" "(0) , 0";
addoperator "<+>" "(0) , 0";
addoperator "<*>" "(0) , 0";
addoperator "->>" "(0) , 0";
addoperator "|||" "(0) , 0";
addoperator "||=" "(0) , 0";
addoperator "^" "(0) , 0";
addoperator "|=" "(0) , 0";
addoperator "--" "(0) , 0";
addoperator "&&" "(0) , 0";
addoperator "++" "(0) , 0";
addoperator "===" "(0) , 0";
addoperator "<<" "(0) , 1";
addoperator "|/" "(0) , 0";
addoperator "***" "(0) , 1";
addoperator "!!!" "(0) , 1";
addoperator "<-" "(0) , 0";
addoperator "=/=" "(0) , 0";
addoperator "|-" "(0) , 0";
addoperator "==" "(0) , 0";
addoperator "->" "(0) , 0";
addoperator "|" "(0) , 0";
addoperator "&" "(0) , 0";
addoperator "~" "(0) , 0";
addoperator "^+" "(0) , 0";
addoperator "^--" "(0) , 0";
addoperator "^-" "(0) , 0";
addoperator "$" "(0) , 0";
addoperator "**" "(0) , 0";
addoperator "." "(0) , 0";
addoperator "@@" "(0) , 0";
addscout "<<" "INSCOUT";
addscout "forsomer" "FORSOMERBOOL";
addscout "forallr" "FORALLRBOOL";
addscout "|-" "ASSERTSCOUT";
addscout "==" "IFFBOOL";
addscout "->" "IFBOOL";
addscout "|" "ORBOOL";
addscout "&" "ANDBOOL";
addscout "forsome" "FORSOMEBOOL";
addscout "~" "NOTBOOL";
addscout "forall" "FORALLBOOL";
addscout "=" "EQBOOL";
addscinleft ".<." "NATLESSSCIN";
addscinleft ".+." "PLUSSCIN_NAT";
addscinleft "Pred" "PREDSCIN";
addscinleft ".-." "NATMINUSSCIN";
addscinleft "/" "DIVSCIN";
addscinleft "%" "MODSCIN";
addscinleft "./." "INT_DIVSCIN";
addscinleft "*" "TIMESSCIN";
addscinleft "-" "MINUSSCIN";
addscinleft "+" "PLUSSCIN";
addscinleft "<-" "CONSCIN";
addscinleft "=/=" "XORSCIN";
addscinleft "==" "IFFSCIN";
addscinleft "->" "IFSCIN";
addscinleft "|" "ORSCIN";
addscinleft "&" "ANDSCIN";
addscinright ".<." "NATLESSSCIN";
addscinright ".+." "PLUSSCIN_NAT";
addscinright "Pred" "PREDSCIN";
addscinright ".-." "NATMINUSSCIN";
addscinright "/" "DIVSCIN";
addscinright "%" "MODSCIN";
addscinright "./." "INT_DIVSCIN";
addscinright "*" "TIMESSCIN";
addscinright "-" "MINUSSCIN";
addscinright "+" "PLUSSCIN";
addscinright "<-" "CONSCIN";
addscinright "=/=" "XORSCIN";
addscinright "==" "IFFSCIN";
addscinright "->" "IFSCIN";
addscinright "|" "ORSCIN";
addscinright "&" "ANDSCIN";
setdefaultprec 0;
prefixreader "-" "0";
prefixreader "^" "";
prefixreader "***" "";
prefixreader "!!!" "";
prefixreader "|-" "";
prefixreader "~" "";
prefixreader "^--" "";
prefixreader "^-" "";
prefixreader "$" "";
prefixreader "!$" "";
prefixreader "!@" "";
addopaque "<+>";
addopaque "<*>";
addopaque "->>";
addopaque "^+";
addopaque "^--";
addopaque "^-";
forcetheorem "COMP" "COMP , ((?f @@ ?g) @ ?x) , (?f @ ?g @ ?x) , COMP , 0";
forcetheorem "P1" "P1 , (P1 @ ?x , ?y) , ?x , P1 , 0";
forcetheorem "P2" "P2 , (P2 @ ?x , ?y) , ?y , P2 , 0";
forcetheorem "Id" "Id , (Id @ ?x) , ?x , Id , 0";
forcetheorem "}P1" "P1 , (P1 @ ?x , ?y) , ?x , P1 , 0";
forcetheorem "}P2" "P2 , (P2 @ ?x , ?y) , ?y , P2 , 0";
forcetheorem "ID" "ID , (Id @ ?x) , ?x , Id , 0";
forcetheorem "}Id" "Id , (Id @ ?x) , ?x , Id , 0";
forcetheorem "VALUE0" "(VALUE0 @ ?thm) , [?P @ ?1] , [?thm => ?P @ ?1] , 0";
forcetheorem "LISTBIND" "(LISTBIND @ ?x , ?y) , ?t , ((PAIRBIND @ ?x , ?y) => ((PAIRBIND @ ?y) *> EVAL) => ((LISTBIND @ ?y) *> EVAL) => ?t) , 0";
forcetheorem "STARTLOOP" "STARTLOOP , ?x , (?x . ?x) , IGNOREFIRST , 0";
forcetheorem "STOPLOOP" "STOPLOOP , (?x . ?x) , ?x , IGNOREFIRST , 0";
forcetheorem "ALL_STEPS" "(ALL_STEPS @ ?ONE_STEP) , (?x . ?y) , ((STOPLOOP =>> ALL_STEPS @ ?ONE_STEP) => (RIGHT @ ?ONE_STEP) => STARTLOOP => IGNOREFIRST => ?x . ?y) , 0";
forcetheorem "LOOP_TAC" "(LOOP_TAC @ ?ONE_STEP) , ?x , ((ALL_STEPS @ ?ONE_STEP) => STARTLOOP => ?x) , 0";
forcetheorem "VIEWCASES" "VIEWCASES , (?x || ?y , ?z) , (?x || ((VIEWCASES =>> INPUT) => ?y) , (VIEWCASES =>> INPUT) => ?z) , 0";
forcetheorem "TYPEBIND" "(TYPEBIND @ ?t) , ?x , ((EVERYWHERE2 @ TYPES) => (BIND @ ?t) => (EVERYWHERE2 @ $ TYPES) => ?x) , 0";
forcetheorem "ANTI_UNEVAL_TAC" "(ANTI_UNEVAL_TAC @ ?f) , (?x || ?y , ?z) , (EVAL => FNDIST <= (BOTH_CASES @ UNEVAL @ ?f) => ?x || ?y , ?z) , 0";
forcetheorem "POP_CASE_1" "POP_CASE_1 , (?n . ?x || ?y , ?z) , (IGNOREFIRST => ?n . (((2 |-| ?n) @ 0) *> POP_CASE_2 @ ?n) <= ?x || ?y , ?z) , 0";
forcetheorem "POP_CASE_2" "(POP_CASE_2 @ ?n) , (?x || ?y , ?z) , (((1 |-| ?n) =>> ((!$ IGNOREFIRST) @ 1 +! ?n) ** POP_CASE_1) => (1 |-| ?n) => ?x || ?y , ?z) , 0";
forcetheorem "POP_CASE" "POP_CASE , (?x || ?y , ?z) , ((((!$ IGNOREFIRST) @ 1) ** POP_CASE_1) => ?x || ?y , ?z) , 0";
forcetheorem "LABELTERMS_FOUND" "(LABELTERMS_FOUND @ ?a , ?no) , ?a , (((!$ IGNOREFIRST) @ ?no) => ?a) , 0";
forcetheorem "LABELTERMS_SPLIT" "(LABELTERMS_SPLIT @ ?a , ?no) , (?x ^+ ?y) , (((LABELTERMS @ ?a , 2 *! ?no) => ?x) ^+ (LABELTERMS @ ?a , 1 +! 2 *! ?no) => ?y) , 0";
forcetheorem "LABELTERMS_ABSTRACT" "(LABELTERMS_ABSTRACT @ ?a , ?no) , [?x @ ?1] , [(LABELTERMS @ ?a , ?no) => ?x @ ?1] , 0";
forcetheorem "LABELTERMS_UNARY" "(LABELTERMS_UNARY @ ?a , ?no) , (^-- ?x) , (^-- (LABELTERMS @ ?a , ?no) => ?x) , 0";
forcetheorem "LABELTERMS_CASE" "(LABELTERMS_CASE @ ?a , ?no) , (?x || ?y , ?z) , (((LABELTERMS @ ?a , 2 *! ?no) => ?x) || ((LABELTERMS @ ?a , 2 *! 1 +! 2 *! ?no) => ?y) , (LABELTERMS @ ?a , 1 +! 2 *! 1 +! 2 *! ?no) => ?z) , 0";
forcetheorem "LABELTERMS" "(LABELTERMS @ ?a , ?no) , ?x , (((LABELTERMS_FOUND @ ?a , ?no) =>> (LABELTERMS_SPLIT @ ?a , ?no) =>> (LABELTERMS_ABSTRACT @ ?a , ?no) =>> (LABELTERMS_UNARY @ ?a , ?no) =>> LABELTERMS_CASE @ ?a , ?no) => ?x) , 0";
forcetheorem "LABELTERM" "(LABELTERM @ ?a) , ?x , ((LABELTERMS @ ?a , 1) => ?x) , 0";
forcetheorem "APPLYATLABEL0" "(APPLYATLABEL0 @ ?thm , ?label) , (?label . ?x) , (?thm => IGNOREFIRST => ?label . ?x) , 0";
forcetheorem "APPLYATLABEL" "(APPLYATLABEL @ ?thm , ?label) , ?x , ((EVERYWHERE2 @ APPLYATLABEL0 @ ?thm , ?label) => ?x) , 0";
forcetheorem "APPLYATLABELS" "(APPLYATLABELS @ ?thm , ?first , ?rest) , ?x , ((APPLYATLABELS @ ?thm , ?rest) => (APPLYATLABEL @ ?thm , ?first) => ?x) , 0";
forcetheorem "BINDLABELS" "(BINDLABELS @ ?y , ?list) , ?x , ((LEFT @ EVERYWHERE2 @ IGNOREFIRST) => (RIGHT @ ID) => (BIND @ Id @ ?y) => (APPLYATLABELS @ ($ ID) , ?list) => ?x) , 0";
forcetheorem "upfun" "upfun , (upfun @ ?x) , ?x , upfun , 0";
forcetheorem "up" "up , ?x , (upfun @ ?x) , upfun , 0";
forcetheorem "INPUTS2" "INPUTS2 , ?x , ((upfun =>> INPUT ** INPUTS2) => ?x) , 0";
forcetheorem "right" "right , ?x , (((RIGHT @ INPUTS2) ** INPUT) => ?x) , 0";
forcetheorem "left" "left , ?x , (((LEFT @ INPUTS2) ** INPUT) => ?x) , 0";
forcetheorem "right_case" "right_case , ?x , (((RIGHT_CASE @ INPUTS2) ** INPUT) => ?x) , 0";
forcetheorem "left_case" "left_case , ?x , (((LEFT_CASE @ INPUTS2) ** INPUT) => ?x) , 0";
forcetheorem "value" "value , ?x , (((VALUE @ INPUTS2) ** INPUT) => ?x) , 0";
forcetheorem "INPUT_AT" "(INPUT_AT @ ?x) , ?x , ((INPUTS2 ** upfun) => ?x) , 0";
forcetheorem "goto" "(goto @ ?a) , ?x , ((EVERYWHERE2 @ INPUT_AT @ ?a) => ?x) , 0";
forcetheorem "LAMBDAINTRO" "LAMBDAINTRO , ?x , (LAMBDAINTRO3 => LAMBDAINTRO2 => LAMBDAINTRO1 => ?x) , 0";
forcetheorem "LAMBDAINTRO1" "LAMBDAINTRO1 , (?x ^+ ?y) , ((RL @ LAMBDAINTRO) => ?x ^+ ?y) , 0";
forcetheorem "LAMBDAINTRO2" "LAMBDAINTRO2 , [?f @ ?1] , [(LABELINTRO @ ?1) => LAMBDAINTRO => ?f @ ?1] , 0";
forcetheorem "LAMBDAINTRO3" "LAMBDAINTRO3 , (?x || ?y , ?z) , ((BOTH_CASES @ LAMBDAINTRO) => (LEFT @ LAMBDAINTRO) => ?x || ?y , ?z) , 0";
forcetheorem "LAMBDAREMOVE" "LAMBDAREMOVE , ?x , (LAMBDAREMOVE3 => LAMBDAREMOVE2 => LAMBDAREMOVE1 => ?x) , 0";
forcetheorem "LAMBDAREMOVE1" "LAMBDAREMOVE1 , (?x ^+ ?y) , ((RL @ LAMBDAREMOVE) => ?x ^+ ?y) , 0";
forcetheorem "LAMBDAREMOVE2" "LAMBDAREMOVE2 , [?f @ ?1] , [IGNOREFIRST => LAMBDAREMOVE => ?f @ ?1] , 0";
forcetheorem "LAMBDAREMOVE3" "LAMBDAREMOVE3 , (?x || ?y , ?z) , ((BOTH_CASES @ LAMBDAREMOVE) => (LEFT @ LAMBDAREMOVE) => ?x || ?y , ?z) , 0";
forcetheorem "FALSEBOOL" "FALSEBOOL , false , (bool : false) , EQBOOL , NONTRIV , 0";
forcetheorem "}NOT1" "NOT1 , (~ ?y) , (?y || false , true) , NOT1 , 0";
forcetheorem "IFFSCIN" "IFFSCIN , ((bool : ?x) == bool : ?y) , (?x == ?y) , IFF , TYPES , 0";
forcetheorem "XORSCIN" "XORSCIN , ((bool : ?x) =/= bool : ?y) , (?x =/= ?y) , EQBOOL , FNDIST , IFF , NONTRIV , NOT1 , REFLEX , TYPES , XOR , 0";
forcetheorem "XORBOOL" "XORBOOL , (?x =/= ?y) , (bool : ?x =/= ?y) , EQBOOL , FNDIST , NONTRIV , NOT1 , REFLEX , XOR , 0";
forcetheorem "IFSCIN" "IFSCIN , ((bool : ?x) -> bool : ?y) , (?x -> ?y) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , 0";
forcetheorem "CONSCIN" "CONSCIN , ((bool : ?x) <- bool : ?y) , (?x <- ?y) , BOOLDEF , CASEINTRO , CONVIF , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , TYPES , 0";
forcetheorem "CNBOOL" "CNBOOL , (?x <- ?y) , (bool : ?x <- ?y) , CONVIF , EQBOOL , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , 0";
forcetheorem "EXAMPLE1" "EXAMPLE1 , (forall @ [forsome @ [?1 = ?2]]) , true , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , forall , forsome , 0";
forcetheorem "BOOLDEF2" "BOOLDEF2 , ((bool : ?x) || ?y , ?z) , (?x || ?y , ?z) , BOOLDEF , 0";
forcetheorem "FORSOMEBOOL2" "FORSOMEBOOL2 , (forsome @ [bool : ?P @ ?1]) , (forsome @ [?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , forsome , 0";
forcetheorem "NONTRIV2a" "NONTRIV2a , (false = true) , false , CASEINTRO , EQUATION , 0";
forcetheorem "XOR" "XOR , (?x =/= ?y) , (~ ?x == ?y) , XOR , 0";
forcetheorem "CONVIF" "CONVIF , (?p <- ?q) , (?q -> ?p) , CONVIF , 0";
forcetheorem "XRULE2" "XRULE2 , ((|- ?p) =/= ?q) , (?p =/= ?q) , ASSERT , EQBOOL , FNDIST , IFF , NONTRIV , NOT1 , REFLEX , TYPES , XOR , 0";
forcetheorem "XORTYPE" "XORTYPE , (?x =/= ?y) , (|- (|- ?x) =/= |- ?y) , ASSERT , EQBOOL , FNDIST , IFF , NONTRIV , NOT1 , REFLEX , TYPES , XOR , 0";
forcetheorem "XRULE3" "XRULE3 , (?p =/= |- ?q) , (?p =/= ?q) , ASSERT , EQBOOL , FNDIST , IFF , NONTRIV , NOT1 , REFLEX , TYPES , XOR , 0";
forcetheorem "NTYPE" "NTYPE , (~ ?p) , (|- ~ |- ?p) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , 0";
forcetheorem "CNRULE2" "CNRULE2 , ((|- ?p) <- ?q) , (?p <- ?q) , ASSERT , BOOLDEF , CASEINTRO , CONVIF , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , TYPES , 0";
forcetheorem "CONTYPE" "CONTYPE , (?p <- ?q) , (|- (|- ?p) <- |- ?q) , ASSERT , BOOLDEF , CASEINTRO , CONVIF , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , 0";
forcetheorem "CNRULE3" "CNRULE3 , (?p <- |- ?q) , (?p <- ?q) , ASSERT , BOOLDEF , CASEINTRO , CONVIF , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , TYPES , 0";
forcetheorem "BIDF" "(BIDF @ ?p) , true , (?p == ?p) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , IFF , ODDCHOICE , REFLEX , 0";
forcetheorem "}BID" "BID , true , (?p == ?p) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , IFF , ODDCHOICE , REFLEX , 0";
forcetheorem "}DXM" "DXM , true , (?p | ~ ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , 0";
forcetheorem "CONS" "CONS , (?p -> ?q) , (?q <- ?p) , AND , BOOLDEF , CASEINTRO , CONVIF , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "THMAP" "(THMAP @ ?dir , ?astrm , ?thm) , (?x ^+ ?y) , ((?dir @ EVAL) => ?thm => (?dir @ (MKASRT @ ?astrm) ** BIND @ |- ?astrm) => ?x ^+ ?y) , 0";
forcetheorem "}3pt15b" "3pt15b , false , ((~ ?p) == ?p) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "XORSYM" "XORSYM , (?p =/= ?q) , (?q =/= ?p) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "XORASSOC" "XORASSOC , ((?p =/= ?q) =/= ?r) , (?p =/= ?q =/= ?r) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "MUTASSOC" "MUTASSOC , ((?p =/= ?q) == ?r) , (?p =/= ?q == ?r) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "MUTINT" "MUTINT , (?p =/= ?q == ?r) , (?p == ?q =/= ?r) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "DZERF" "(DZERF @ ?p) , true , (?p | true) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}DZER" "DZER , true , (?p | true) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt15bF" "(3pt15bF @ ?p) , false , ((~ ?p) == ?p) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "3pt32" "3pt32 , ((?p | ?q) == ?p | ~ ?q) , (|- ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt32F" "(3pt32F @ ?q) , (|- ?p) , ((?p | ?q) == ?p | ~ ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt32" "3pt32 , (|- ?p) , ((?p | ?q) == ?p | ~ ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "GR" "GR , ((?p & ?q) == ?p | ?q) , (?p == ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , IFF , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CTYPE" "CTYPE , (?p & ?q) , (|- (|- ?p) & |- ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , REFLEX , TYPES , 0";
forcetheorem "XORDEF" "XORDEF , (?p =/= ?q) , (~ ?p == ?q) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "CZERF" "(CZERF @ ?p) , false , (?p & false) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "}CZER" "CZER , false , (?p & false) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "}3pt43a" "3pt43a , (|- ?p) , (?p & ?p | ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt43b" "3pt43b , (?p | ?p & ?q) , (|- ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt43b" "3pt43b , (|- ?p) , (?p | ?p & ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "DUAL" "(DUAL @ ?thm) , ?x , (REMFLIP => (RIGHT @ ?thm) => FLIPALL => ?x) , 0";
forcetheorem "3pt48" "3pt48 , ((?p & ~ ?q) == ~ ?p) , (?p & ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "L3pt43" "L3pt43 , (?p == (~ ?p) | ?q) , (?p & ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt49" "3pt49 , ((?p & ?q) == (?p & ?r) == ?p) , (?p & ?q == ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "REPL" "REPL , ((?p == ?q) & ?r == ?p) , ((?p == ?q) & ?r == ?q) , AND , BOOLDEF , EQBOOL , IFF , 0";
forcetheorem "3pt50" "3pt50 , (?p & ?q == ?p) , (?p & ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "GR3" "GR3 , ((?p == ?q) == ?p & ?q) , (?p | ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IDISB" "IDISB , (?p -> ?q == ?r) , ((?p -> ?q) == ?p -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt67" "3pt67 , (?p & ?q -> ?p) , (|- ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt67F" "(3pt67F @ ?q) , (|- ?p) , (?p & ?q -> ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt67" "3pt67 , (|- ?p) , (?p & ?q -> ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt68" "3pt68 , (?p | ?p -> ?q) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt68F" "(3pt68F @ ?p , ?q) , true , (?p | ?p -> ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt68" "3pt68 , true , (?p | ?p -> ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "DDIS" "DDIS , (?p | ?q == ?r) , ((?p | ?q) == ?p | ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt69" "3pt69 , (?p | ?q -> ?p) , (?q -> ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "BALTDEF" "BALTDEF , (?p == ?q) , ((?p & ?q) | (~ ?p) & ~ ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt70" "3pt70 , ((?p | ?q) -> ?p & ?q) , (?p == ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IREFF" "(IREFF @ ?p) , true , (?p -> ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}IREF" "IREF , true , (?p -> ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IRZERF" "(IRZERF @ ?p) , true , (?p -> true) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}IRZER" "IRZER , true , (?p -> true) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt74" "3pt74 , (?p -> false) , (~ ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt75F" "(3pt75F @ ?p) , true , (false -> ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt75" "3pt75 , true , (false -> ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt76aF" "(3pt76aF @ ?p , ?q) , true , (?p -> ?p | ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt76a" "3pt76a , true , (?p -> ?p | ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt76bF" "(3pt76bF @ ?p , ?q) , true , ((?p & ?q) -> ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt76b" "3pt76b , true , ((?p & ?q) -> ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt76c" "3pt76c , ((?p & ?q) -> ?p | ?q) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt76cF" "(3pt76cF @ ?p , ?q) , true , ((?p & ?q) -> ?p | ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt76c" "3pt76c , true , ((?p & ?q) -> ?p | ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt76dF" "(3pt76dF @ ?p , ?q , ?r) , true , ((?p | ?q & ?r) -> ?p | ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt76d" "3pt76d , true , ((?p | ?q & ?r) -> ?p | ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt76d" "3pt76d , ((?p | ?q & ?r) -> ?p | ?q) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt76e" "3pt76e , ((?p & ?q) -> ?p & ?q | ?r) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt76eF" "(3pt76eF @ ?p , ?q , ?r) , true , ((?p & ?q) -> ?p & ?q | ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt76e" "3pt76e , true , ((?p & ?q) -> ?p & ?q | ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "MOP" "MOP , ((?p & ?p -> ?q) -> ?q) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "MOPF" "(MOPF @ ?p , ?q) , true , ((?p & ?p -> ?q) -> ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}MOP" "MOP , true , ((?p & ?p -> ?q) -> ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt79" "3pt79 , ((?p -> ?r) & (~ ?p) -> ?r) , (|- ?r) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt79F" "(3pt79F @ ?p) , (|- ?r) , ((?p -> ?r) & (~ ?p) -> ?r) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt79" "3pt79 , (|- ?r) , ((?p -> ?r) & (~ ?p) -> ?r) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "XALTDEF" "XALTDEF , (?p =/= ?q) , (((~ ?p) & ?q) | ?p & ~ ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , XOR , 0";
forcetheorem "3pt81" "3pt81 , (((?p -> ?q) & ?q -> ?p) -> ?p == ?q) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt81F" "(3pt81F @ ?p , ?q) , true , (((?p -> ?q) & ?q -> ?p) -> ?p == ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt81" "3pt81 , true , (((?p -> ?q) & ?q -> ?p) -> ?p == ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt82aF" "(3pt82aF @ ?p , ?q , ?r) , true , (((?p -> ?q) & ?q -> ?r) -> ?p -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt82a" "3pt82a , true , (((?p -> ?q) & ?q -> ?r) -> ?p -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt82bF" "(3pt82bF @ ?p , ?q , ?r) , true , (((?p == ?q) & ?q -> ?r) -> ?p -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt82b" "3pt82b , true , (((?p == ?q) & ?q -> ?r) -> ?p -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt82b" "3pt82b , (((?p == ?q) & ?q -> ?r) -> ?p -> ?r) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt82c" "3pt82c , (((?p -> ?q) & ?q == ?r) -> ?p -> ?r) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt82cF" "(3pt82cF @ ?p , ?q , ?r) , true , (((?p -> ?q) & ?q == ?r) -> ?p -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt82c" "3pt82c , true , (((?p -> ?q) & ?q == ?r) -> ?p -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt83" "3pt83 , ((?e = ?f) -> (?F @ ?e) = ?F @ ?f) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt83F" "(3pt83F @ ?F , ?e , ?f) , true , ((?e = ?f) -> (?F @ ?e) = ?F @ ?f) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}3pt83" "3pt83 , true , ((?e = ?f) -> (?F @ ?e) = ?F @ ?f) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "REMFLIP" "REMFLIP , ?x , ((BRULE1 =>> CRULE1 =>> DRULE1 =>> NRULE1 =>> XRULE1 =>> AT =>> AF) => TWOASSERTS => DUBNEG2 => SREMFLIP => ?x) , 0";
forcetheorem "SREMFLIP" "SREMFLIP , ?x , ((FDEF <<= NEGF <<= BFLIP <<= XORFLIP =>> DEMa =>> DEMb =>> REMA) => NOTCLEAN => ASSERTCLEAN => (LEFT @ SREMFLIP) => (RIGHT @ SREMFLIP) => ?x) , 0";
forcetheorem "ASSERTCLEAN" "ASSERTCLEAN , (|- ?y) , (|- ?y) , ASSERT , 0";
forcetheorem "NOTCLEAN" "NOTCLEAN , (~ ?y) , (~ ?y) , NOT1 , 0";
forcetheorem "BFLIP" "BFLIP , (~ ?p == ?q) , ((~ ?p) =/= ~ ?q) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "XORFLIP" "XORFLIP , (~ ?p =/= ?q) , ((~ ?p) == ~ ?q) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "3pt84c" "3pt84c , ((?q & ?e = ?f) -> ?F @ ?e) , ((?q & ?e = ?f) -> ?F @ ?f) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt85b" "3pt85b , ((?q & ?p) -> ?F @ ?p) , ((?q & ?p) -> ?F @ true) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "APLZ" "APLZ , ((?e = ?f) & ?x) , (((RIGHT @ BIND @ ?e) ** LZ ** RIGHT @ EVAL) => (?e = ?f) & ?x) , 0";
forcetheorem "AP3pt86a" "AP3pt86a , (?x -> ?p) , ((THMAP @ LEFT , ?p , 3pt86a) => ?x -> ?p) , 0";
forcetheorem "3pt86b" "3pt86b , ((?F @ |- ?p) -> ?p | ?q) , ((?F @ false) -> ?p | ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "AP3pt86b" "AP3pt86b , (?x -> ?p | ?q) , ((THMAP @ LEFT , ?p , 3pt86b) => ?x -> ?p | ?q) , 0";
forcetheorem "3pt85a" "3pt85a , (?p -> ?F @ ?p) , (?p -> ?F @ true) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt88" "3pt88 , (?p | ?F @ |- ?p) , (?p | ?F @ false) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "AP3pt88" "AP3pt88 , (?p | ?x) , ((THMAP @ RIGHT , ?p , 3pt88) => ?p | ?x) , 0";
forcetheorem "3pt87" "3pt87 , (?p & ?F @ ?p) , (?p & ?F @ true) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "FLIPALL" "FLIPALL , ?x , (SFLIPALL => DUBNEG2 <= (BRULE1 <<= XRULE1 <<= DRULE1 <<= CRULE1) <= ?x) , 0";
forcetheorem "SFLIPALL" "SFLIPALL , ?x , ((FLIPPASTA =>> FLIPPASTN =>> FLIPPASTB =>> FLIPPASTX =>> FLIPPASTD =>> FLIPPASTC <<= FDEF =>> NEGF) => ?x) , 0";
forcetheorem "FLIPPASTA" "FLIPPASTA , (~ |- ?p) , (|- SFLIPALL => ~ ?p) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , TYPES , 0";
forcetheorem "FLIPPASTN" "FLIPPASTN , (~ ~ ?x) , (~ SFLIPALL => ~ ?x) , 0";
forcetheorem "FLIPPASTB" "FLIPPASTB , (~ ?x == ?y) , ((SFLIPALL => ~ ?x) =/= SFLIPALL => ~ ?y) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "FLIPPASTX" "FLIPPASTX , (~ ?x =/= ?y) , ((SFLIPALL => ~ ?x) == SFLIPALL => ~ ?y) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "FLIPPASTD" "FLIPPASTD , (~ ?x | ?y) , ((SFLIPALL => ~ ?x) & SFLIPALL => ~ ?y) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "FLIPPASTC" "FLIPPASTC , (~ ?x & ?y) , ((SFLIPALL => ~ ?x) | SFLIPALL => ~ ?y) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt86a" "3pt86a , ((?F @ |- ?p) -> ?p) , ((?F @ false) -> ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt89" "3pt89 , ((?p & ?F @ true) | (~ ?p) & ?F @ false) , (|- ?F @ |- ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IDIS1" "IDIS1 , ((?p | ?q) -> ?r) , ((?p -> ?r) & ?q -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IDIS2" "IDIS2 , ((?p & ?q) -> ?r) , ((?p -> ?r) | ?q -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IDIS3" "IDIS3 , (?p -> ?q & ?r) , ((?p -> ?q) & ?p -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "DDISD" "DDISD , (?p | ?q | ?r) , ((?p | ?q) | ?p | ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IDIS4" "IDIS4 , (?p -> ?q | ?r) , ((?p -> ?q) | ?p -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CONVIMPAND" "(CONVIMPAND @ ?thm) , (?p & ?q) , (CID => ?p & ?thm => ?p -> ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CONVIMPOR" "(CONVIMPOR @ ?thm) , (?p | ?q) , (DID => ?q | FDEF <= ~ ?thm => ?p -> ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CONVANDIMP" "(CONVANDIMP @ ?thm) , (?p -> ?q) , (BID => BRULE2 => (?thm => ?p & ?q) == ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CONVANDOR" "(CONVANDOR @ ?thm) , (?p | ?q) , (DID => ?q | FDEF <= ~ (CONVANDIMP @ ?thm) => ?p -> ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CONVORIMP" "(CONVORIMP @ ?thm) , (?p -> ?q) , (BID => BRULE2 => (?thm => ?p | ?q) == ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "GR2" "GR2 , ((?p == ?q) == ?p | ?q) , (?p & ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CONVORAND" "(CONVORAND @ ?thm) , (?p & ?q) , (BID2 => (RIGHT @ BID) => BASSOC => BRULE3 => (?p == ?q) == ?thm => ?p | ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "EQSYMM2" "EQSYMM2 , (?x || ?y , ?z) , ((?x = true) || ?y , ?z) , CASEINTRO , EQUATION , REFLEX , 0";
forcetheorem "EQT" "EQT , ((|- ?p) = true) , (?p = true) , ASSERT , BOOLDEF , CASEINTRO , EQUATION , REFLEX , TYPES , 0";
forcetheorem "ASRTRIGHT" "(ASRTRIGHT @ ?p) , (?q ^+ ?p) , ((LEFT @ MKASRT @ ?p) => ((?r ^+ |- ?s) = ?r ^+ ?s) <= ?q ^+ ?p) , 0";
forcetheorem "3pt84b" "3pt84b , ((?e = ?f) -> ?F @ ?e) , ((?e = ?f) -> ?F @ ?f) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "BTYPE" "BTYPE , (?p == ?q) , (|- (|- ?p) == |- ?q) , ASSERT , EQBOOL , IFF , TYPES , 0";
forcetheorem "ASSRTBOTH" "(ASSRTBOTH @ ?p) , (?p ^+ ?p) , (((?r ^+ |- ?s) = ?r ^+ ?s) <= (((|- ?r) ^+ ?s) = ?r ^+ ?s) <= ?p ^+ ?p) , 0";
forcetheorem "ASRTLEFT" "(ASRTLEFT @ ?p) , (?p ^+ ?q) , ((RIGHT @ MKASRT @ ?p) => (((|- ?r) ^+ ?s) = ?r ^+ ?s) <= ?p ^+ ?q) , 0";
forcetheorem "MKASRT" "(MKASRT @ ?p) , (?r ^+ ?s) , (((ASSRTBOTH @ ?p) =>> (ASRTLEFT @ ?p) =>> (ASRTRIGHT @ ?p) =>> RL @ MKASRT @ ?p) => ?r ^+ ?s) , 0";
forcetheorem "ASRTCOND" "ASRTCOND , (?a || ?b , ?c) , ((|- ?a) || ?b , ?c) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "LZ" "LZ , ((?e = ?f) & ?F @ ?e) , ((?e = ?f) & ?F @ ?f) , AND , BOOLDEF , EQBOOL , 0";
forcetheorem "REMA" "REMA , (|- ~ ?p) , (~ |- ?p) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , TYPES , 0";
forcetheorem "}CONDCASESL1" "CONDCASESL1 , true , ((?a || ?b , ?c) == (?a & ?b) | (~ ?a) & ?c) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "DTYPE" "DTYPE , (?p | ?q) , (|- (|- ?p) | |- ?q) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , OR , REFLEX , 0";
forcetheorem "CONDCASESL1F" "(CONDCASESL1F @ ?a , ?b , ?c) , true , ((?a || ?b , ?c) == (?a & ?b) | (~ ?a) & ?c) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "BEQSUBS" "BEQSUBS , ((?a == ?b) -> ?a) , ((?a == ?b) -> ?b) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CONDCASESL1" "CONDCASESL1 , ((?a || ?b , ?c) == (?a & ?b) | (~ ?a) & ?c) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IMPTYPE" "IMPTYPE , (?p -> ?q) , (|- (|- ?p) -> |- ?q) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , 0";
forcetheorem "3pt43a" "3pt43a , (?p & ?p | ?q) , (|- ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CONDCASES" "CONDCASES , ((?a & ?b) | (~ ?a) & ?c) , (|- ?a || ?b , ?c) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CASEPREP" "CASEPREP , (?a || ?b , ?c) , (?a || (ALLASSERTS => (?b = |- ?b) => ?b) , ALLASSERTS => (?c = |- ?c) => ?c) , 0";
forcetheorem "XORALTDEF" "XORALTDEF , ((?a & ~ ?b) | (~ ?a) & ?b) , (~ ?a == ?b) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CONDCASES2" "CONDCASES2 , (?a || (|- ?b) , |- ?c) , ((?a & ?b) | (~ ?a) & ?c) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CONDSIMP" "CONDSIMP , (?a || (|- ?b) , |- ?c) , ((DID =>> DZER =>> DSYM) => DSYM => (DID ** DZER) => XORALTDEF => BALTDEF <= (DRULE1 ** DRULE2) => (RL @ CRULE1 ** CRULE2 ** CID ** CZER) => (?a & ?b) | (~ ?a) & ?c) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "TESTSIMP" "TESTSIMP , (?a || ?b , ?c) , ((EVERYWHERE @ $ XOR) => (EVERYWHERE @ $ IDEF2) => (EVERYWHERE @ CASEPREP ** CONDSIMP) => ?a || ?b , ?c) , 0";
forcetheorem "DINSTANTIATE" "DINSTANTIATE , ((?P @ ?x) | forsome @ [?P @ ?1]) , (forsome @ ?P) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , OR , REFLEX , forall , forsome , 0";
forcetheorem "}DINSTANTIATE" "DINSTANTIATE , (forsome @ ?P) , ((?P @ ?x) | forsome @ [?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , OR , REFLEX , forall , forsome , 0";
forcetheorem "3pt43bF" "(3pt43bF @ ?q) , (|- ?p) , (?p | ?p & ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "FORALLSWITCH2" "FORALLSWITCH2 , (forall @ [forall @ [(?P @ ?1) @ ?2]]) , (forall @ [forall @ [bool : (?P @ ?2) @ ?1]]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , forall , 0";
forcetheorem "3pt43aF" "(3pt43aF @ ?q) , (|- ?p) , (?p & ?p | ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "NOTFORALL" "NOTFORALL , (~ forall @ [?P @ ?1]) , ((forall @ [~ ?P @ ?1]) | ~ forall @ [?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , 0";
forcetheorem "FORALLNOT" "FORALLNOT , (forall @ [~ ?P @ ?1]) , ((forall @ [~ ?P @ ?1]) & ~ forall @ [?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , forall , 0";
forcetheorem "FORALLOR" "FORALLOR , (forall @ [(?P @ ?1) | ?Q @ ?1]) , ((forall @ [?P @ ?1]) | forall @ [(?P @ ?1) | ?Q @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , 0";
forcetheorem "GCLEAN" "GCLEAN , ?x , ((RL @ GCLEAN) => NRULE2 => NRULE1 => STL => STR => STT => (ALLASSERTS ** RIGHT @ (RIGHT @ ALLASSERTS) ** LEFT @ ALLASSERTS) => ?x) , 0";
forcetheorem "ALLASSERTS" "ALLASSERTS , (|- |- ?x) , (ALLASSERTS => |- ?x) , ASSERT , TYPES , 0";
forcetheorem "STT" "STT , (|- ?x ^+ ?y) , (((|- ?p ^+ ?q) = ?p ^+ ?q) => |- ?x ^+ ?y) , 0";
forcetheorem "STR" "STR , ((|- ?x) ^+ ?y) , ((((|- ?p) ^+ ?q) = ?p ^+ ?q) => (|- ?x) ^+ ?y) , 0";
forcetheorem "STL" "STL , (?x ^+ |- ?y) , (((?p ^+ |- ?q) = ?p ^+ ?q) => ?x ^+ |- ?y) , 0";
forcetheorem "ANDSCIN" "ANDSCIN , ((bool : ?x) & bool : ?y) , (?x & ?y) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , REFLEX , TYPES , 0";
forcetheorem "ORSCIN" "ORSCIN , ((bool : ?x) | bool : ?y) , (?x | ?y) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , NOT1 , OR , REFLEX , 0";
forcetheorem "TAB_IF_2" "TAB_IF_2 , ((?p -> ?q) || ?a , ?b) , (?p || (?q || ?a , ?b) , ?a) , AND , CASEINTRO , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , 0";
forcetheorem "TAB_IFF_2" "TAB_IFF_2 , ((?x == ?y) || ?a , ?b) , (?x || (?y || ?a , ?b) , ?y || ?b , ?a) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , IFF , ODDCHOICE , REFLEX , 0";
forcetheorem "3pt14" "3pt14 , (?p =/= ?q) , ((~ ?p) == ?q) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "TAB_XOR" "TAB_XOR , (?x =/= ?y) , (?x || (?y || false , true) , ?y || true , false) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "TAB_XOR_2" "TAB_XOR_2 , ((?x =/= ?y) || ?a , ?b) , (?x || (?y || ?b , ?a) , ?y || ?a , ?b) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , XOR , 0";
forcetheorem "TAB_NOT" "TAB_NOT , (~ ?p) , (?p || false , true) , NOT1 , ODDCHOICE , 0";
forcetheorem "TAB_ALL" "(TAB_ALL @ ?x) , (forall @ [?P @ ?1]) , ((forall @ [?P @ ?1]) || ((EVAL => ?P @ ?x) || true , false) , false) , CASEINTRO , EQUATION , forall , 0";
forcetheorem "TAB_SOME" "(TAB_SOME @ ?x) , (forsome @ [?P @ ?1]) , ((forsome @ [?P @ ?1]) || true , (EVAL => ?P @ ?x) || true , false) , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , forall , forsome , 0";
forcetheorem "TAB_SOME_NEW_1" "TAB_SOME_NEW_1 , ((forsome @ [?P @ ?1]) || ?a , ?b) , ((forsome @ [?P @ ?1]) || (([?a] = [(EVAL => ?P @ ?1) || ?a , ?a]) || ?a , true) , ?b) , CASEINTRO , REFLEX , 0";
forcetheorem "TAB_ALL_NEW_1" "TAB_ALL_NEW_1 , ((forall @ [?P @ ?1]) || ?a , ?b) , ((forall @ [?P @ ?1]) || ?a , ([?b] = [(EVAL => ?P @ ?1) || ?b , ?b]) || ?b , true) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , forall , 0";
forcetheorem "TAB_ALL_NEW_2" "TAB_ALL_NEW_2 , ((forall @ [?P @ ?1]) || ?a , ([?b] = [(?P @ ?1) || ?b , true]) || ?b , true) , ((forall @ [?P @ ?1]) || ?a , true) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , forall , 0";
forcetheorem "TAB_SOME_NEW_2" "TAB_SOME_NEW_2 , ((forsome @ [?P @ ?1]) || (([?a] = [(?P @ ?1) || true , ?a]) || ?a , true) , ?b) , ((forsome @ [?P @ ?1]) || true , ?b) , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , forall , forsome , 0";
forcetheorem "ALT_QUANT_IMP" "ALT_QUANT_IMP , ((forsome @ [forall @ [?P @ ?1 , ?2]]) -> forall @ [forsome @ [?P @ ?2 , ?1]]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , forall , forsome , 0";
forcetheorem "COUNTER1" "COUNTER1 , (*** ?P) , (!!! [~ ?P @ ?1]) , COUNTER1 , 0";
forcetheorem "SUBTYPE" "SUBTYPE , ((?t |/ ?P) : ?x) , ((?P @ ?t : ?x) || (?t : ?x) , ?t : !!! [?P @ ?t : ?1]) , SUBTYPE , 0";
forcetheorem "COUNTER" "COUNTER , (*** [?P @ ?1]) , (!!! [~ ?P @ ?1]) , COUNTER1 , EQBOOL , FNDIST , NONTRIV , NOT1 , REFLEX , 0";
forcetheorem "CEX" "CEX , (forall @ [?P @ ?1]) , (bool : ?P @ *** [?P @ ?1]) , BOOLDEF , CASEINTRO , CHOICE , COUNTER1 , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , forall , forsome , 0";
forcetheorem "forsomecase" "forsomecase , (forsome @ [?P @ ?1]) , ((forsome @ [?P @ ?1]) || true , false) , BOOLDEF , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , forsome , 0";
forcetheorem "forallcase" "forallcase , (forall @ [?P @ ?1]) , ((forall @ [?P @ ?1]) || true , false) , BOOLDEF , EQBOOL , EQUATION , ODDCHOICE , forall , 0";
forcetheorem "CHOICE" "CHOICE , (forsome @ [?P @ ?1]) , (?P @ !!! [?P @ ?1]) , CHOICE , 0";
forcetheorem "ANY_INSTANCE" "ANY_INSTANCE , ((?P @ ?x) -> ?P @ !!! [?P @ ?1]) , true , AND , CASEINTRO , CHOICE , EQBOOL , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , forall , forsome , 0";
forcetheorem "TAB_WITNESS" "TAB_WITNESS , ((forsome @ [?P @ ?1]) || ?a , ?b) , ((forsome @ [?P @ ?1]) || ((CHOICE_TAC => forsome @ [?P @ ?1]) || ?a , ?b) , ?b) , ODDCHOICE , 0";
forcetheorem "CHOICE_TAC" "CHOICE_TAC , (forsome @ [?P @ ?1]) , (EVAL => ?P @ !!! [?P @ ?1]) , CHOICE , 0";
forcetheorem "TAB_SOME_2" "(TAB_SOME_2 @ ?x) , ((forsome @ [?P @ ?1]) || ?a , ?b) , ((forsome @ [?P @ ?1]) || ?a , (EVAL => ?P @ ?x) || ?a , ?b) , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , forall , forsome , 0";
forcetheorem "ALT_QUANT_AGAIN" "ALT_QUANT_AGAIN , ((forsome @ [forall @ [?P @ ?1 , ?2]]) -> forall @ [forsome @ [?P @ ?2 , ?1]]) , true , AND , BOOLDEF , CASEINTRO , CHOICE , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , forall , forsome , 0";
forcetheorem "TAB_IFF" "TAB_IFF , (?x == ?y) , (?x || (?y || true , false) , ?y || false , true) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , IFF , ODDCHOICE , REFLEX , 0";
forcetheorem "TAB_CEX" "TAB_CEX , ((forall @ [?P @ ?1]) || ?a , ?b) , ((forall @ [?P @ ?1]) || ?a , ODDCHOICE <= (BOOLDEF => CEX_TAC => forall @ [?P @ ?1]) || ?a , ?b) , ODDCHOICE , 0";
forcetheorem "CEX_TAC" "CEX_TAC , (forall @ [?P @ ?1]) , (bool : EVAL => ?P @ *** [?P @ ?1]) , BOOLDEF , CASEINTRO , CHOICE , COUNTER1 , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , forall , forsome , 0";
forcetheorem "TAB_ALL_2" "(TAB_ALL_2 @ ?x) , ((forall @ [?P @ ?1]) || ?a , ?b) , ((forall @ [?P @ ?1]) || ((EVAL => ?P @ ?x) || ?a , ?b) , ?b) , CASEINTRO , EQUATION , forall , 0";
forcetheorem "COMMUTE_LEVEL_QUANT" "COMMUTE_LEVEL_QUANT , ((forall @ [forall @ [?P @ ?1 , ?2]]) == forall @ [forall @ [?P @ ?2 , ?1]]) , true , BOOLDEF , CASEINTRO , CHOICE , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , forall , forsome , 0";
forcetheorem "EQ_TRANS" "EQ_TRANS , (((?x = ?y) & ?y = ?z) -> ?x = ?z) , true , AND , CASEINTRO , EQUATION , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , 0";
forcetheorem "forallr" "forallr , (forallr @ ?x) , (forall @ [((P1 @ ?x) @ ?1) -> (P2 @ ?x) @ ?1]) , forallr , 0";
forcetheorem "FORSOMERBOOL" "FORSOMERBOOL , (forsomer @ ?x) , (bool : forsomer @ ?x) , EQBOOL , FNDIST , NONTRIV , NOT1 , REFLEX , forsomer , 0";
forcetheorem "forsomer" "forsomer , (forsomer @ ?x) , (~ forallr @ (P1 @ ?x) , [~ (P2 @ ?x) @ ?1]) , forsomer , 0";
forcetheorem "ONEPOINT" "ONEPOINT , (forallr @ [?1 = ?e] , [?P @ ?1]) , (|- EVAL => ?P @ ?e) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "CONVERT_IMP_1" "(CONVERT_IMP_1 @ ?thm) , (?p -> ?q) , (3pt76b => (LEFT @ ?thm) => ($ IRULE2) => ?p -> ?q) , 0";
forcetheorem "DXMF" "(DXMF @ ?p) , true , (?p | ~ ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , 0";
forcetheorem "CONVERT_IMP_2" "(CONVERT_IMP_2 @ ?thm , ?q) , (|- ?p) , (CRULE1 => DID => (?p & ?q) | FDEF <= ~ ?thm => ?p -> ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "PRE9pt12" "PRE9pt12 , ((forall @ [(?P @ ?1) -> ?Q @ ?1]) -> (forall @ [?P @ ?1]) -> forall @ [?Q @ ?1]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , 0";
forcetheorem "forall2" "forall2 , (forall @ [?P @ ?1]) , ([?P @ ?1] = [true]) , forall , 0";
forcetheorem "9pt16a1" "(9pt16a1 @ ?thm) , (?P @ ?x) , ((LEFT @ ?thm) => (forall @ [?P @ ?1]) || true , [?P @ ?1] @ ?x) , CASEINTRO , forall , 0";
forcetheorem "9pt16a" "(9pt16a @ ?x , ?thm) , ?y , ((9pt16a1 @ ?thm) => (BIND @ ?x) => ?y) , 0";
forcetheorem "9pt16b" "(9pt16b @ ?thm) , (forall @ [?P @ ?1]) , ((FORALLDROP ** AT) => forall @ [?thm => ?P @ ?1]) , 0";
forcetheorem "9pt30a" "(9pt30a @ ?thm) , ((?P @ ?x) -> ?Q) , ((LEFT @ ?thm) => ((forsome @ [?P @ ?1]) -> ?Q) || true , [(?P @ ?1) -> ?Q] @ ?x) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "9pt30b" "(9pt30b @ ?thm) , ((forsome @ [?P @ ?1]) -> ?Q) , ((FORALLDROP ** AT) => forall @ [?thm => (?P @ ?1) -> ?Q]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "}ONEPOINT" "ONEPOINT , (forallr @ [?1 = ?e] , [?P @ ?1]) , (|- EVAL => ?P @ ?e) , EQBOOL , AND , ASSERT , BOOLDEF , CASEINTRO , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "}RIGHT" "(RIGHT @ ?thm) , ?x , (((RIGHT1 @ ?thm) =>> RIGHT2 @ ?thm) => ?x) , 0";
forcetheorem "}LEFT" "(LEFT @ ?thm) , ?x , (((LEFT1 @ ?thm) =>> LEFT2 @ ?thm) => ?x) , 0";
forcetheorem "8pt14U" "8pt14U , (forallr @ [?1 = ?e] , [?P @ ?1]) , (|- EVAL => ?P @ ?e) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "8pt14E" "8pt14E , (forsomer @ [?1 = ?e] , [?P @ ?1]) , (|- EVAL => ?P @ ?e) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsomer , 0";
forcetheorem "UNIV_RANGE_1" "UNIV_RANGE_1 , (forallr @ [true] , [?P @ ?1]) , (forall @ [?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "UNIV_RANGE_2" "UNIV_RANGE_2 , (forsomer @ [true] , [?P @ ?1]) , (forsome @ [?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsome , forsomer , 0";
forcetheorem "FORALLRBOOL2" "FORALLRBOOL2 , (forallr @ [?R @ ?1] , [?P @ ?1]) , (forallr @ [bool : ?R @ ?1] , [?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , P1 , P2 , REFLEX , TYPES , forallr , 0";
forcetheorem "FORSOMERBOOL2" "FORSOMERBOOL2 , (forsomer @ [?R @ ?1] , [?P @ ?1]) , (forsomer @ [bool : ?R @ ?1] , [?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , P1 , P2 , REFLEX , TYPES , forallr , forsomer , 0";
forcetheorem "NOTBOOLDROP" "NOTBOOLDROP , (~ bool : ?x) , (~ ?x) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , NOT1 , REFLEX , 0";
forcetheorem "FORSOMERBOOL3" "FORSOMERBOOL3 , (forsomer @ [?R @ ?1] , [?P @ ?1]) , (forsomer @ [?R @ ?1] , [bool : ?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , P1 , P2 , REFLEX , forsomer , 0";
forcetheorem "8pt13U" "8pt13U , (forallr @ [false] , [?P @ ?1]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "8pt13E" "8pt13E , (forsomer @ [false] , [?P @ ?1]) , false , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsomer , 0";
forcetheorem "8pt15E" "8pt15E , ((forsomer @ [?R @ ?1] , [?P @ ?1]) | forsomer @ [?R @ ?1] , [?Q @ ?1]) , (forsomer @ [?R @ ?1] , [(?P @ ?1) | ?Q @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsomer , 0";
forcetheorem "8pt16E" "8pt16E , (forsomer @ [(?R @ ?1) | ?S @ ?1] , [?P @ ?1]) , ((forsomer @ [?R @ ?1] , [?P @ ?1]) | forsomer @ [?S @ ?1] , [?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsomer , 0";
forcetheorem "PAIRBIND" "(PAIRBIND @ ?x , ?y) , ?t , ((BIND @ ?x , ?y) => EVAL => (LEFT @ VALUE @ [EVAL]) => (LEFT @ VALUE @ [LEFT @ VALUE @ [EVAL]]) => (LEFT @ VALUE @ [LEFT @ VALUE @ [RIGHT @ PI2F @ ?x]]) => (LEFT @ VALUE @ [LEFT @ VALUE @ [BIND @ ?y]]) => (LEFT @ VALUE @ [RIGHT @ PI1F @ ?y]) => (LEFT @ VALUE @ [BIND @ ?x]) => (BIND @ ?x , ?y) => ?t) , 0";
forcetheorem "PI1F" "(PI1F @ ?y) , ?x , (P1 @ ?x , ?y) , P1 , 0";
forcetheorem "PI2F" "(PI2F @ ?y) , ?x , (P2 @ ?y , ?x) , P2 , 0";
forcetheorem "FORALLSWITCH" "FORALLSWITCH , (forall @ [forall @ [?P @ ?1 , ?2]]) , (forall @ [forall @ [?P @ ?2 , ?1]]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , REFLEX , forall , 0";
forcetheorem "8pt19U" "8pt19U , (forallr @ [?R @ ?1] , [forallr @ [?Q @ ?2] , [?P @ ?1 , ?2]]) , (forallr @ [?Q @ ?1] , [forallr @ [?R @ ?2] , [?P @ ?2 , ?1]]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "8pt19E" "8pt19E , (forsomer @ [?R @ ?1] , [forsomer @ [?Q @ ?2] , [?P @ ?1 , ?2]]) , (forsomer @ [?Q @ ?1] , [forsomer @ [?R @ ?2] , [?P @ ?2 , ?1]]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsomer , 0";
forcetheorem "9pt3b" "9pt3b , (forallr @ [?R @ ?1] , [?P @ ?1]) , (forall @ [((?R @ ?1) & ?P @ ?1) == ?R @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forallr , 0";
forcetheorem "9pt3c" "9pt3c , (forallr @ [?R @ ?1] , [?P @ ?1]) , (forall @ [((?R @ ?1) | ?P @ ?1) == ?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forallr , 0";
forcetheorem "9pt4b" "9pt4b , (forallr @ [(?Q @ ?1) & ?R @ ?1] , [?P @ ?1]) , (forallr @ [?Q @ ?1] , [(~ ?R @ ?1) | ?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forallr , 0";
forcetheorem "9pt4c" "9pt4c , (forallr @ [(?Q @ ?1) & ?R @ ?1] , [?P @ ?1]) , (forallr @ [?Q @ ?1] , [((?R @ ?1) & ?P @ ?1) == ?R @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forallr , 0";
forcetheorem "9pt4a" "9pt4a , (forallr @ [(?Q @ ?1) & ?R @ ?1] , [?P @ ?1]) , (forallr @ [?Q @ ?1] , [(?R @ ?1) -> ?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forallr , 0";
forcetheorem "9pt4d" "9pt4d , (forallr @ [(?Q @ ?1) & ?R @ ?1] , [?P @ ?1]) , (forallr @ [?Q @ ?1] , [((?R @ ?1) | ?P @ ?1) == ?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forallr , 0";
forcetheorem "9pt3a" "9pt3a , (forallr @ [?R @ ?1] , [?P @ ?1]) , (forall @ [(~ ?R @ ?1) | ?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forallr , 0";
forcetheorem "9pt6" "9pt6 , (forallr @ [?R @ ?1] , [?P]) , (?P | forall @ [~ ?R @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "3pt44a" "3pt44a , (?p & (~ ?p) | ?q) , (?p & ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "3pt62" "3pt62 , (?p -> ?q == ?r) , ((?p & ?q) == ?p & ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "forallr2" "forallr2 , (forallr @ [?R @ ?1] , [?P @ ?1]) , (forall @ [(?R @ ?1) -> ?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , P1 , P2 , REFLEX , forallr , 0";
forcetheorem "8pt16U" "8pt16U , (forallr @ [(?R @ ?1) | ?S @ ?1] , [?P @ ?1]) , ((forallr @ [?R @ ?1] , [?P @ ?1]) & forallr @ [?S @ ?1] , [?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "8pt15U" "8pt15U , ((forallr @ [?R @ ?1] , [?P @ ?1]) & forallr @ [?R @ ?1] , [?Q @ ?1]) , (forallr @ [?R @ ?1] , [(?P @ ?1) & ?Q @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "9pt11" "9pt11 , ((forallr @ [?R @ ?1] , [(?P @ ?1) & ?Q @ ?1]) -> forallr @ [?R @ ?1] , [?P @ ?1]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "9pt18a" "9pt18a , (~ forsomer @ [?R @ ?1] , [~ ?P @ ?1]) , (forallr @ [?R @ ?1] , [?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsomer , 0";
forcetheorem "9pt18b" "9pt18b , (~ forsomer @ [?R @ ?1] , [?P @ ?1]) , (forallr @ [?R @ ?1] , [~ ?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , P1 , P2 , REFLEX , forall , forallr , forsomer , 0";
forcetheorem "FORALLRBOOL3" "FORALLRBOOL3 , (forallr @ [?R @ ?1] , [?P @ ?1]) , (forallr @ [?R @ ?1] , [bool : ?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , P1 , P2 , REFLEX , TYPES , forallr , 0";
forcetheorem "9pt18c" "9pt18c , (forsomer @ [?R @ ?1] , [~ ?P @ ?1]) , (~ forallr @ [?R @ ?1] , [?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , P1 , P2 , REFLEX , TYPES , forallr , forsomer , 0";
forcetheorem "9pt20" "9pt20 , (forsomer @ [(?Q @ ?1) & ?R @ ?1] , [?P @ ?1]) , (forsomer @ [?Q @ ?1] , [(?R @ ?1) & ?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forallr , forsomer , 0";
forcetheorem "9pt5" "9pt5 , (?P | forallr @ [?R @ ?1] , [?Q @ ?1]) , (forallr @ [?R @ ?1] , [?P | ?Q @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "9pt21" "9pt21 , (forsomer @ [?R @ ?1] , [?P & ?Q @ ?1]) , (?P & forsomer @ [?R @ ?1] , [?Q @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsomer , 0";
forcetheorem "FORSOMEDIST2" "FORSOMEDIST2 , (forsome @ [(?P @ ?1) & ?Q]) , ((forsome @ [?P @ ?1]) & ?Q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "9pt22" "9pt22 , (forsomer @ [?R @ ?1] , [?P]) , (?P & forsome @ [?R @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsome , forsomer , 0";
forcetheorem "FORALLRBOOL" "FORALLRBOOL , (forallr @ ?x) , (bool : forallr @ ?x) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , forall , forallr , 0";
forcetheorem "9pt7" "9pt7 , ((~ forall @ [~ ?R @ ?1]) -> (forallr @ [?R @ ?1] , [?P & ?Q @ ?1]) == ?P & forallr @ [?R @ ?1] , [?Q @ ?1]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "9pt23" "9pt23 , ((forsome @ [?R @ ?1]) -> (forsomer @ [?R @ ?1] , [?P | ?Q @ ?1]) == ?P | forsomer @ [?R @ ?1] , [?Q @ ?1]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsome , forsomer , 0";
forcetheorem "9pt8" "9pt8 , (forallr @ [?R @ ?1] , [true]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "9pt24" "9pt24 , (forsomer @ [?R @ ?1] , [false]) , false , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsomer , 0";
forcetheorem "forsomer2" "forsomer2 , (forsomer @ [?R @ ?1] , [?P @ ?1]) , (~ forallr @ [?R @ ?1] , [~ ?P @ ?1]) , EQBOOL , FNDIST , NONTRIV , NOT1 , P1 , P2 , REFLEX , forsomer , 0";
forcetheorem "9pt10" "9pt10 , ((forallr @ [(?Q @ ?1) | ?R @ ?1] , [?P @ ?1]) -> forallr @ [?Q @ ?1] , [?P @ ?1]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , 0";
forcetheorem "forsomer3" "forsomer3 , (forsomer @ [?R @ ?1] , [?P @ ?1]) , (forsome @ [(?R @ ?1) & ?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forallr , forsome , forsomer , 0";
forcetheorem "R" "(R @ ?thm) , ?x , (((RIGHT1 @ ?thm) =>> RIGHT2 @ ?thm) => ?x) , 0";
forcetheorem "L" "(L @ ?thm) , ?x , (((LEFT1 @ ?thm) =>> LEFT2 @ ?thm) => ?x) , 0";
forcetheorem "VALUE" "(VALUE @ ?thm) , [?P @ ?1] , [(?thm @ ?1) => ?P @ ?1] , 0";
forcetheorem "9pt25" "9pt25 , ((forsomer @ [?R @ ?1] , [?P @ ?1]) -> forsomer @ [(?Q @ ?1) | ?R @ ?1] , [?P @ ?1]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsomer , 0";
forcetheorem "9pt26" "9pt26 , ((forsomer @ [?R @ ?1] , [?P @ ?1]) -> forsomer @ [?R @ ?1] , [(?P @ ?1) | ?Q @ ?1]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , P1 , P2 , REFLEX , TYPES , forall , forallr , forsomer , 0";
forcetheorem "UNIV_TAC" "UNIV_TAC , ((forall @ ?t) || ?x , ?y) , ((LEFT @ $ forall) => (LEFT_CASE @ EVERYWHERE2 @ EVAL) => PIVOT => (LEFT_CASE @ EVERYWHERE2 @ UNEVAL @ ?t) => (LEFT @ forall) => (forall @ ?t) || ?x , ?y) , 0";
forcetheorem "PIVOT" "PIVOT , ((?a = ?b) || ?T , ?U) , ((LEFT_CASE @ EVAL) => HYP => (?a = ?b) || ((BIND @ ?a) => ?T) , ?U) , 0";
forcetheorem "GETL" "(GETL @ ?z) , (?x & ?y) , ((GET @ ?z , CSYM , CASSOC) => ?x & ?y) , 0";
forcetheorem "LABELINTRO" "(LABELINTRO @ ?x) , ?y , (?x . ?y) , IGNOREFIRST , 0";
forcetheorem "NEGL" "NEGL , (((~ ?P) & ?gamma) -> ?delta) , ((((~ ?P) & ?gamma) -> ?delta) . ?gamma -> ?P | ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "NEGR" "NEGR , (?gamma -> (~ ?P) | ?delta) , ((?gamma -> (~ ?P) | ?delta) . (?P & ?gamma) -> ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "ANDL" "ANDL , (((?P & ?Q) & ?gamma) -> ?delta) , ((((?P & ?Q) & ?gamma) -> ?delta) . (?P & ?Q & ?gamma) -> ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "ANDR" "ANDR , (?gamma -> (?P & ?Q) | ?delta) , ((?gamma -> (?P & ?Q) | ?delta) . (?gamma -> ?P | ?delta) & ?gamma -> ?Q | ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "ORL" "ORL , (((?P | ?Q) & ?gamma) -> ?delta) , ((((?P | ?Q) & ?gamma) -> ?delta) . ((?P & ?gamma) -> ?delta) & (?Q & ?gamma) -> ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "ORR" "ORR , (?gamma -> (?P | ?Q) | ?delta) , ((?gamma -> (?P | ?Q) | ?delta) . ?gamma -> ?P | ?Q | ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IFL" "IFL , (((?P -> ?Q) & ?gamma) -> ?delta) , ((((?P -> ?Q) & ?gamma) -> ?delta) . (?gamma -> ?P | ?delta) & (?Q & ?gamma) -> ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "EXL" "(EXL @ ?P) , (?gamma -> ?delta) , ((?gamma -> ?delta) . ((GETL @ ?P) => ?gamma) -> ?delta) , IGNOREFIRST , 0";
forcetheorem "WEAKL" "WEAKL , ((?P & ?gamma) -> ?delta) , (((?P & ?gamma) -> ?delta) . (?P & ?P & ?gamma) -> ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "WEAKR" "WEAKR , (?gamma -> ?Q | ?delta) , ((?gamma -> ?Q | ?delta) . ?gamma -> ?Q | ?Q | ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IFFL" "IFFL , (((?P == ?Q) & ?gamma) -> ?delta) , ((((?P == ?Q) & ?gamma) -> ?delta) . ((?P & ?Q & ?gamma) -> ?delta) & ?gamma -> ?P | ?Q | ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IFFR" "IFFR , (?gamma -> (?P == ?Q) | ?delta) , ((?gamma -> (?P == ?Q) | ?delta) . ((?P & ?gamma) -> ?Q | ?delta) & (?Q & ?gamma) -> ?P | ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CUT" "(CUT @ ?P) , (?gamma -> ?delta) , ((?gamma -> ?delta) . ((?P & ?gamma) -> ?delta) & ?gamma -> ?P | ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "UNIVL" "(UNIVL @ ?t) , (((forall @ [?P @ ?1]) & ?gamma) -> ?delta) , ((((forall @ [?P @ ?1]) & ?gamma) -> ?delta) . ((EVAL => ?P @ ?t) & (forall @ [?P @ ?1]) & ?gamma) -> ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IGNOREFIRST , NONTRIV , ODDCHOICE , REFLEX , TYPES , forall , 0";
forcetheorem "FORSOMEANDDIST" "FORSOMEANDDIST , (?Q & forsome @ [?P @ ?1]) , (forsome @ [?Q & ?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "FORALLORDIST" "FORALLORDIST , (forall @ [?P | ?Q @ ?1]) , (?P | forall @ [?Q @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , 0";
forcetheorem "EXISTL" "EXISTL , (((forsome @ [?P @ ?1]) & ?gamma) -> ?delta) , ((((forsome @ [?P @ ?1]) & ?gamma) -> ?delta) . forall @ [((?P @ ?1) & ?gamma) -> ?delta]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "INSCOUT" "INSCOUT , (?x << ?y) , (bool : ?x << ?y) , ASSERT , IN , TYPES , 0";
forcetheorem "INL" "INL , (((?x << [?P @ ?1]) & ?gamma) -> ?delta) , ((((?x << [?P @ ?1]) & ?gamma) -> ?delta) . ((EVAL => ?P @ ?x) & ?gamma) -> ?delta) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IGNOREFIRST , IN , NONTRIV , REFLEX , TYPES , 0";
forcetheorem "SELFLABEL" "SELFLABEL , ?x , (?x . ?x) , IGNOREFIRST , 0";
forcetheorem "INR" "INR , (?gamma -> (?x << [?P @ ?1]) | ?delta) , ((?gamma -> (?x << [?P @ ?1]) | ?delta) . ?gamma -> (EVAL => ?P @ ?x) | ?delta) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IGNOREFIRST , IN , NONTRIV , NOT1 , OR , REFLEX , TYPES , 0";
forcetheorem "PROVETAUT2" "(PROVETAUT2 @ ?y) , ?x , ((BRULE1 =>> CRULE1 =>> DRULE1 =>> NRULE1 =>> XRULE1 =>> IRULE1 =>> CNRULE1) => ASSERT2 => (PROVETAUT @ ?y) => ASSERT => (BRULE1 <<= CRULE1 <<= DRULE1 <<= NRULE1 <<= XRULE1 <<= IRULE1 <<= CNRULE1) <= ?x) , 0";
forcetheorem "CNRULE1" "CNRULE1 , (|- ?p <- ?q) , (?p <- ?q) , ASSERT , BOOLDEF , CASEINTRO , CONVIF , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , TYPES , 0";
forcetheorem "PROVETAUT" "(PROVETAUT @ ?y) , (bool : ?x) , ((NEWTAUT => IFF <= (bool : ?x) = bool : ?y) || (bool : ?y) , bool : ?x) , CASEINTRO , 0";
forcetheorem "IFF" "IFF , (?x == ?y) , ((bool : ?x) = bool : ?y) , IFF , 0";
forcetheorem "IFFBOOL" "IFFBOOL , (?x == ?y) , (bool : ?x == ?y) , EQBOOL , IFF , 0";
forcetheorem "XRULE1" "XRULE1 , (|- ?p =/= ?q) , (?p =/= ?q) , ASSERT , EQBOOL , FNDIST , IFF , NONTRIV , NOT1 , REFLEX , TYPES , XOR , 0";
forcetheorem "SETUP_SEQUENT" "SETUP_SEQUENT , (|- ?P) , (true -> ?P | false) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "UNIVR" "UNIVR , (?gamma -> (forall @ [?P @ ?1]) | ?delta) , ((?gamma -> (forall @ [?P @ ?1]) | ?delta) . forall @ [?gamma -> (?P @ ?1) | ?delta]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , 0";
forcetheorem "EXISTR" "(EXISTR @ ?t) , (?gamma -> (forsome @ [?P @ ?1]) | ?delta) , ((?gamma -> (forsome @ [?P @ ?1]) | ?delta) . ?gamma -> (EVAL => ?P @ ?t) | (forsome @ [?P @ ?1]) | ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "IFR" "IFR , (?gamma -> (?P -> ?Q) | ?delta) , ((?gamma -> (?P -> ?Q) | ?delta) . (?P & ?gamma) -> ?Q | ?delta) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "EXR" "(EXR @ ?P) , (?gamma -> ?delta) , ((?gamma -> ?delta) . ?gamma -> (GETR @ ?P) => ?delta) , IGNOREFIRST , 0";
forcetheorem "GETR" "(GETR @ ?z) , (?x | ?y) , ((GET @ ?z , DSYM , DASSOC) => ?x | ?y) , 0";
forcetheorem "AXIOM" "AXIOM , ((?P & ?gamma) -> ?P | ?delta) , (((?P & ?gamma) -> ?P | ?delta) . true) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IGNOREFIRST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "FS_SEQUENT" "FS_SEQUENT , (?x . ?y) , (((FS1 @ FS_SEQUENT) =>> (FS2 @ FS_SEQUENT) =>> (FS5 @ FS_SEQUENT) =>> (FS3 @ FS_SEQUENT) =>> (FS4 @ FS_SEQUENT) =>> FS6 @ FS_SEQUENT) => ?x . ?y) , 0";
forcetheorem "FS1" "(FS1 @ ?finish) , (?x . ?y . ?z) , (?x . FS0 => ?finish => ?y . ?z) , 0";
forcetheorem "FS2" "(FS2 @ ?finish) , (?x . forall @ [?z @ ?1]) , (?x . FS0b => forall @ [FS0 => ?finish => ?z @ ?1]) , 0";
forcetheorem "FS5" "(FS5 @ ?finish) , (?x . (forall @ [?y @ ?1]) & forall @ [?z @ ?1]) , (?x . (CID ** AT) => (FS0b => forall @ [(?finish ** FS0) => ?y @ ?1]) & FS0b => forall @ [(?finish ** FS0) => ?z @ ?1]) , 0";
forcetheorem "FS3" "(FS3 @ ?finish) , (?x . (forall @ [?y @ ?1]) & ?z) , (?x . (CID ** AT) => (FS0b => forall @ [(?finish ** FS0) => ?y @ ?1]) & (?finish ** FS0) => ?z) , 0";
forcetheorem "FS4" "(FS4 @ ?finish) , (?x . ?y & forall @ [?z @ ?1]) , (?x . (CID ** AT) => ((?finish ** FS0) => ?y) & FS0b => forall @ [(?finish ** FS0) => ?z @ ?1]) , 0";
forcetheorem "FS6" "(FS6 @ ?finish) , (?x . ?y & ?z) , (?x . (CID ** AT) => ((?finish ** FS0) => ?y) & (?finish ** FS0) => ?z) , 0";
forcetheorem "FS0b" "FS0b , (forall @ [true]) , true , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , forall , 0";
forcetheorem "FS0" "FS0 , (?x . true) , true , IGNOREFIRST , 0";
forcetheorem "IGNOREFIRST" "IGNOREFIRST , (?x . ?y) , ?y , IGNOREFIRST , 0";
forcetheorem "TrueSet" "TrueSet , (Set @ [true]) , [true] , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , Set , TYPES , 0";
forcetheorem "INBOOL" "INBOOL , (?x << ?y) , (bool : ?x << ?y) , ASSERT , IN , TYPES , 0";
forcetheorem "InType" "InType , (?s << ?t) , (?s << Set @ ?t) , ASSERT , IN , Set , TYPES , 0";
forcetheorem "UnivNotEmpty" "UnivNotEmpty , ([true] === [false]) , false , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , ODDCHOICE , REFLEX , SetEquiv , TYPES , forall , 0";
forcetheorem "EmptyNotUniv" "EmptyNotUniv , ([false] === [true]) , false , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , ODDCHOICE , REFLEX , SetEquiv , TYPES , forall , 0";
forcetheorem "FORSOMEDROP" "FORSOMEDROP , (forsome @ [?x]) , (|- ?x) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "NotEq" "NotEq , (~ ?s === ?t) , (forsome @ [(~ ?1 << ?s) == ?1 << ?t]) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetEquiv , TYPES , forall , forsome , 0";
forcetheorem "3pt15a" "3pt15a , (?p == false) , (~ ?p) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "FORALLBOOL" "FORALLBOOL , (forall @ ?P) , (bool : forall @ ?P) , EQBOOL , forall , 0";
forcetheorem "forsome2" "forsome2 , (forsome @ [?P @ ?1]) , (~ forall @ [~ ?P @ ?1]) , EQBOOL , FNDIST , NONTRIV , NOT1 , REFLEX , forsome , 0";
forcetheorem "NotEqEmpty" "NotEqEmpty , (~ ?s === [false]) , (forsome @ [?1 << ?s]) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetEquiv , TYPES , forsome , 0";
forcetheorem "EquivBool" "EquivBool , (?a === ?b) , (bool : ?a === ?b) , ASSERT , EQBOOL , IFF , IN , SetEquiv , TYPES , forall , 0";
forcetheorem "DubComplement" "DubComplement , (^ ^ ?S) , (Set @ ?S) , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , Set , TYPES , 0";
forcetheorem "FORALLBOOL2" "FORALLBOOL2 , (forall @ [bool : ?P @ ?1]) , (forall @ [?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , REFLEX , forall , 0";
forcetheorem "ComplEqUniv" "ComplEqUniv , ((^ ?s) === [true]) , (forall @ [~ ?1 << ?s]) , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetEquiv , TYPES , forall , 0";
forcetheorem "NEQ" "NEQ , (?p == ?q) , ((~ ?p) == ~ ?q) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "ComplEq" "ComplEq , ((^ ?a) === ^ ?b) , (?a === ?b) , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetEquiv , TYPES , 0";
forcetheorem "3pt11" "3pt11 , ((~ ?p) == ?q) , (?p == ~ ?q) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "ComplUniv" "ComplUniv , (^ [true]) , [false] , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "ComplUniv_Empty" "ComplUniv_Empty , ((^ ?a) === [true]) , (?a === [false]) , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetEquiv , TYPES , 0";
forcetheorem "EqCompl" "EqCompl , (?a === ^ ?b) , ((^ ?a) === ?b) , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetEquiv , TYPES , 0";
forcetheorem "ComplEmpty" "ComplEmpty , (^ [false]) , [true] , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "ComplEmpty_Univ" "ComplEmpty_Univ , ((^ ?a) === [false]) , (?a === [true]) , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetEquiv , TYPES , 0";
forcetheorem "UnionType" "UnionType , (?P ++ ?Q) , (Set @ (Set @ ?P) ++ Set @ ?Q) , UnionType , 0";
forcetheorem "UnionScin" "UnionScin , (?P ++ ?Q) , ((Set @ ?P) ++ Set @ ?Q) , ASSERT , Set , TYPES , UnionType , 0";
forcetheorem "UnionAssoc" "UnionAssoc , ((?A ++ ?B) ++ ?C) , (?A ++ ?B ++ ?C) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , Union , 0";
forcetheorem "UnionIdem" "UnionIdem , (?A ++ ?A) , (Set @ ?A) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , Set , TYPES , Union , 0";
forcetheorem "UnivUnion" "UnivUnion , ([true] ++ ?s) , [true] , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , Union , 0";
forcetheorem "UnionUniv" "UnionUniv , (?s ++ [true]) , [true] , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , Union , 0";
forcetheorem "EmptyUnion" "EmptyUnion , ([false] ++ ?s) , (Set @ ?s) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , Set , TYPES , Union , 0";
forcetheorem "UnionEmpty" "UnionEmpty , (?s ++ [false]) , (Set @ ?s) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , Set , TYPES , Union , 0";
forcetheorem "UnionCompl" "UnionCompl , (?S ++ ^ ?S) , [true] , AND , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , Union , 0";
forcetheorem "InUnion" "InUnion , (?X << ?A ++ ?B) , ((?X << ?A) | ?X << ?B) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , OR , REFLEX , TYPES , Union , 0";
forcetheorem "InterType" "InterType , (?P && ?Q) , (Set @ (Set @ ?P) && Set @ ?Q) , InterType , 0";
forcetheorem "InterScin" "InterScin , (?P && ?Q) , ((Set @ ?P) && Set @ ?Q) , ASSERT , InterType , Set , TYPES , 0";
forcetheorem "InterAssoc" "InterAssoc , ((?A && ?B) && ?C) , (?A && ?B && ?C) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "InterEmpty" "InterEmpty , (?s && [false]) , [false] , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "InterUniv" "InterUniv , (?s && [true]) , (Set @ ?s) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , Set , TYPES , 0";
forcetheorem "InterUnion" "InterUnion , (?A && ?B ++ ?C) , ((?A && ?B) ++ ?A && ?C) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , Union , 0";
forcetheorem "UnionInter" "UnionInter , (?A ++ ?B && ?C) , ((?A ++ ?B) && ?A ++ ?C) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , Union , 0";
forcetheorem "InterCompl" "InterCompl , (?S && ^ ?S) , [false] , AND , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "DEMORGANa" "DEMORGANa , (^ ?S ++ ?T) , ((^ ?S) && ^ ?T) , AND , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , Union , 0";
forcetheorem "DEMORGANb" "DEMORGANb , (^ ?S && ?T) , ((^ ?S) ++ ^ ?T) , AND , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , Union , 0";
forcetheorem "UnionEqUniv" "UnionEqUniv , ((?S ++ ?T) === [true]) , (forall @ [(~ ?1 << ?S) -> ?1 << ?T]) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetEquiv , TYPES , Union , forall , 0";
forcetheorem "InterEqEmpty" "InterEqEmpty , ((?S && ?T) === [false]) , (forall @ [(?1 << ?S) -> ~ ?1 << ?T]) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetEquiv , TYPES , forall , 0";
forcetheorem "UnionUniv_InterEmpty" "UnionUniv_InterEmpty , (((?S ++ ?T) === [true]) & (?S && ?T) === [false]) , (?S === ^ ?T) , AND , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IFF , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetEquiv , TYPES , Union , forall , 0";
forcetheorem "InInter" "InInter , (?X << ?A && ?B) , ((?X << ?A) & ?X << ?B) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , REFLEX , TYPES , 0";
forcetheorem "DiffType" "DiffType , (?P -- ?Q) , (Set @ (Set @ ?P) -- Set @ ?Q) , DiffType , 0";
forcetheorem "DiffScin" "DiffScin , (?P -- ?Q) , ((Set @ ?P) -- Set @ ?Q) , ASSERT , DiffType , Set , TYPES , 0";
forcetheorem "DubDiff" "DubDiff , ((?A -- ?B) -- ?B) , (?A -- ?B) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetDifference , TYPES , 0";
forcetheorem "Set" "Set , (Set @ ?x) , [|- ?x @ ?1] , Set , 0";
forcetheorem "DiffEmpty" "DiffEmpty , (?s -- [false]) , (Set @ ?s) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , Set , SetDifference , TYPES , 0";
forcetheorem "EmptyDiff" "EmptyDiff , ([false] -- ?s) , [false] , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetDifference , TYPES , 0";
forcetheorem "DiffUniv" "DiffUniv , (?s -- [true]) , [false] , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetDifference , TYPES , 0";
forcetheorem "UnivDiff" "UnivDiff , ([true] -- ?S) , (^ ?S) , AND , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetDifference , TYPES , 0";
forcetheorem "DiffIdem" "DiffIdem , (?s -- ?s) , [false] , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetDifference , TYPES , 0";
forcetheorem "DiffSymm" "DiffSymm , ((?s -- ?x) -- ?y) , ((?s -- ?y) -- ?x) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetDifference , TYPES , 0";
forcetheorem "DiffInter" "DiffInter , ((?s -- ?x) && ?t) , ((?s && ?t) -- ?x) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetDifference , TYPES , 0";
forcetheorem "InCompl" "InCompl , (?x << ^ ?P) , (~ ?x << ?P) , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , REFLEX , TYPES , 0";
forcetheorem "Diff_InterCompl" "Diff_InterCompl , (?S -- ?T) , (?S && ^ ?T) , AND , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , NOT1 , REFLEX , SetDifference , TYPES , 0";
forcetheorem "InterDiff_Empty" "InterDiff_Empty , (?S && ?T -- ?S) , [false] , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetDifference , TYPES , 0";
forcetheorem "3pt44b" "3pt44b , (?p | (~ ?p) & ?q) , (?p | ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "UnionDiff_absorption" "UnionDiff_absorption , (?S ++ ?T -- ?S) , (?S ++ ?T) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetDifference , TYPES , Union , 0";
forcetheorem "CDISC" "CDISC , (?p & ?q & ?r) , ((?p & ?q) & ?p & ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "DiffUnion" "DiffUnion , (?S -- ?T ++ ?R) , ((?S -- ?T) && ?S -- ?R) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetDifference , TYPES , Union , 0";
forcetheorem "DiffInter_Union" "DiffInter_Union , (?S -- ?T && ?R) , ((?S -- ?T) ++ ?S -- ?R) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetDifference , TYPES , Union , 0";
forcetheorem "InDiff" "InDiff , (?x << ?A -- ?B) , ((?x << ?A) & ~ ?x << ?B) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , REFLEX , SetDifference , TYPES , 0";
forcetheorem "SubsetType" "SubsetType , (?P |= ?Q) , (Set @ (Set @ ?P) |= Set @ ?Q) , SubsetType , 0";
forcetheorem "SubsetScin" "SubsetScin , (?P |= ?Q) , ((Set @ ?P) |= Set @ ?Q) , ASSERT , Set , SubsetType , TYPES , 0";
forcetheorem "3pt82a" "3pt82a , (((?p -> ?q) & ?q -> ?r) -> ?p -> ?r) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "FORALL_3pt82a" "FORALL_3pt82a , (((forall @ [(?P @ ?1) -> ?Q @ ?1]) & forall @ [(?Q @ ?1) -> ?R @ ?1]) -> forall @ [(?P @ ?1) -> ?R @ ?1]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , 0";
forcetheorem "SubsetTrans" "SubsetTrans , (((?A |= ?B) & ?B |= ?C) -> ?A |= ?C) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , Subset , TYPES , forall , 0";
forcetheorem "FORALLDIST" "FORALLDIST , (forall @ [(?P @ ?1) & ?Q @ ?1]) , ((forall @ [?P @ ?1]) & forall @ [?Q @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , forall , 0";
forcetheorem "InEmpty" "InEmpty , (?x << [false]) , false , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "InUniv" "InUniv , (?x << [true]) , true , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "IDEF" "IDEF , (?p -> ?q) , ((?p | ?q) == ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "Subset_UnionAbsorption" "Subset_UnionAbsorption , (?s |= ?t) , ((?s ++ ?t) === ?t) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetEquiv , Subset , TYPES , Union , 0";
forcetheorem "UnionSymm" "UnionSymm , (?P ++ ?Q) , (?Q ++ ?P) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , Union , 0";
forcetheorem "SubsetUnion" "SubsetUnion , (?s |= ?s ++ ?t) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , Subset , TYPES , Union , forall , 0";
forcetheorem "SubsetUnionSymm" "SubsetUnionSymm , (?s |= ?t ++ ?s) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , Subset , TYPES , Union , forall , 0";
forcetheorem "InterSubset" "InterSubset , ((?s && ?t) |= ?s) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , Subset , TYPES , forall , 0";
forcetheorem "InterSymmSubset" "InterSymmSubset , ((?t && ?s) |= ?s) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , Subset , TYPES , forall , 0";
forcetheorem "IDEF3" "IDEF3 , (?p -> ?q) , ((?p & ?q) == ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "Subset_InterAbsorption" "Subset_InterAbsorption , (?s |= ?t) , ((?s && ?t) === ?s) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetEquiv , Subset , TYPES , 0";
forcetheorem "DiffSubset" "DiffSubset , ((?s -- ?x) |= ?s) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetDifference , Subset , TYPES , forall , 0";
forcetheorem "PsubsetType" "PsubsetType , (?P ||= ?Q) , (Set @ (Set @ ?P) ||= Set @ ?Q) , PsubsetType , 0";
forcetheorem "PsubsetScin" "PsubsetScin , (?P ||= ?Q) , ((Set @ ?P) ||= Set @ ?Q) , ASSERT , PsubsetType , Set , TYPES , 0";
forcetheorem "SubsetIdem" "SubsetIdem , (?A |= ?A) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , Subset , TYPES , forall , 0";
forcetheorem "PsubsetIdem" "PsubsetIdem , (?s ||= ?s) , false , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , Psubset , REFLEX , SetEquiv , Subset , TYPES , forall , 0";
forcetheorem "SubsetEmpty" "SubsetEmpty , (?s |= [false]) , (?s === [false]) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetEquiv , Subset , TYPES , 0";
forcetheorem "PsubsetEmpty" "PsubsetEmpty , (?s ||= [false]) , false , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , Psubset , REFLEX , SetEquiv , Subset , TYPES , 0";
forcetheorem "EmptySubset" "EmptySubset , ([false] |= ?s) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , Subset , TYPES , forall , 0";
forcetheorem "EquivSymm" "EquivSymm , (?a === ?b) , (?b === ?a) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , IFF , IN , ODDCHOICE , REFLEX , SetEquiv , TYPES , 0";
forcetheorem "EmptyPsubset" "EmptyPsubset , ([false] ||= ?s) , (~ ?s === [false]) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , Psubset , REFLEX , SetEquiv , Subset , TYPES , forall , 0";
forcetheorem "UnivSubset" "UnivSubset , ([true] |= ?s) , (?s === [true]) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetEquiv , Subset , TYPES , 0";
forcetheorem "UnivPsubset" "UnivPsubset , ([true] ||= ?s) , false , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , Psubset , REFLEX , SetEquiv , Subset , TYPES , 0";
forcetheorem "SubsetUniv" "SubsetUniv , (?s |= [true]) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , Subset , TYPES , forall , 0";
forcetheorem "EqUniv" "EqUniv , (?s === [true]) , (forall @ [?1 << ?s]) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , ODDCHOICE , REFLEX , SetEquiv , TYPES , forall , 0";
forcetheorem "FORSOME_NOTFORALL" "FORSOME_NOTFORALL , (~ forall @ ?P) , (forsome @ [~ ?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , forall , forsome , 0";
forcetheorem "PsubsetUniv" "PsubsetUniv , (?s ||= [true]) , (forsome @ [~ ?1 << ?s]) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , Psubset , REFLEX , SetEquiv , Subset , TYPES , forall , forsome , 0";
forcetheorem "3pt76b" "3pt76b , ((?p & ?q) -> ?p) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "PsubsetSubset" "PsubsetSubset , ((?S ||= ?T) -> ?S |= ?T) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , Psubset , REFLEX , TYPES , 0";
forcetheorem "Psubset" "Psubset , (?P ||= ?Q) , ((?P |= ?Q) & ~ ?P === ?Q) , Psubset , 0";
forcetheorem "SubsetAntisym" "SubsetAntisym , (((?A |= ?B) & ?B |= ?A) -> ?A === ?B) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetEquiv , Subset , TYPES , forall , 0";
forcetheorem "PsubsetNotSubset" "PsubsetNotSubset , ((?S ||= ?T) -> ~ ?T |= ?S) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , Psubset , REFLEX , SetEquiv , Subset , TYPES , forall , 0";
forcetheorem "SubsetNotPsubset" "SubsetNotPsubset , ((?S |= ?T) -> ~ ?T ||= ?S) , true , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , Psubset , REFLEX , SetEquiv , Subset , TYPES , forall , 0";
forcetheorem "SETRETRACT" "SETRETRACT , (Set @ Set @ ?x) , (Set @ ?x) , ASSERT , Set , TYPES , 0";
forcetheorem "DisjType" "DisjType , (?P ||| ?Q) , (Set @ (Set @ ?P) ||| Set @ ?Q) , DisjType , 0";
forcetheorem "DisjScin" "DisjScin , (?P ||| ?Q) , ((Set @ ?P) ||| Set @ ?Q) , ASSERT , DisjType , Set , TYPES , 0";
forcetheorem "InterSymm" "InterSymm , (?P && ?Q) , (?Q && ?P) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "UnivInter" "UnivInter , ([true] && ?s) , (Set @ ?s) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , Set , TYPES , 0";
forcetheorem "UnivDisj" "UnivDisj , ([true] ||| ?s) , (?s === [false]) , AND , ASSERT , BOOLDEF , CASEINTRO , Disjoint , EQBOOL , EQUATION , FNDIST , IFF , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , SetEquiv , TYPES , 0";
forcetheorem "DisjUniv" "DisjUniv , (?s ||| [true]) , (?s === [false]) , AND , ASSERT , BOOLDEF , CASEINTRO , Disjoint , EQBOOL , EQUATION , FNDIST , IFF , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , SetEquiv , TYPES , 0";
forcetheorem "EmptyInter" "EmptyInter , ([false] && ?s) , [false] , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "EmptyDisj" "EmptyDisj , ([false] ||| ?s) , true , AND , ASSERT , BOOLDEF , CASEINTRO , Disjoint , EQBOOL , EQUATION , FNDIST , IFF , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , SetEquiv , TYPES , forall , 0";
forcetheorem "DisjEmpty" "DisjEmpty , (?s ||| [false]) , true , AND , ASSERT , BOOLDEF , CASEINTRO , Disjoint , EQBOOL , EQUATION , FNDIST , IFF , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , SetEquiv , TYPES , forall , 0";
forcetheorem "InterIdem" "InterIdem , (?A && ?A) , (Set @ ?A) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , Set , TYPES , 0";
forcetheorem "EmptySet" "EmptySet , (Set @ [false]) , [false] , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , Set , TYPES , 0";
forcetheorem "EquivType" "EquivType , (?s === ?t) , ((Set @ ?s) === Set @ ?t) , ASSERT , EQBOOL , IFF , IN , Set , SetEquiv , TYPES , 0";
forcetheorem "DisjIdem" "DisjIdem , (?s ||| ?s) , (?s === [false]) , AND , ASSERT , BOOLDEF , CASEINTRO , Disjoint , EQBOOL , EQUATION , FNDIST , IFF , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , SetEquiv , TYPES , 0";
forcetheorem "EqEmpty" "EqEmpty , (?s === [false]) , (forall @ [~ ?1 << ?s]) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetEquiv , TYPES , forall , 0";
forcetheorem "FORALL_NOTFORSOME" "FORALL_NOTFORSOME , (~ forsome @ ?P) , (forall @ [~ ?P @ ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , forall , forsome , 0";
forcetheorem "Disj_NotForsome" "Disj_NotForsome , (?s ||| ?t) , (~ forsome @ [(?1 << ?s) & ?1 << ?t]) , AND , ASSERT , BOOLDEF , CASEINTRO , Disjoint , EQBOOL , EQUATION , FNDIST , IFF , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetEquiv , TYPES , forall , forsome , 0";
forcetheorem "UnionEqEmpty" "UnionEqEmpty , ((?s ++ ?t) === [false]) , ((?s === [false]) & ?t === [false]) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , IN , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetEquiv , TYPES , Union , forall , 0";
forcetheorem "DisjSymm" "DisjSymm , (?s ||| ?t) , (?t ||| ?s) , AND , ASSERT , BOOLDEF , CASEINTRO , Disjoint , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "UnionDisj" "UnionDisj , ((?s ++ ?t) ||| ?u) , ((?s ||| ?u) & ?t ||| ?u) , AND , ASSERT , BOOLDEF , CASEINTRO , Disjoint , EQBOOL , EQUATION , FNDIST , IFF , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , SetEquiv , TYPES , Union , forall , 0";
forcetheorem "ApplyIn" "ApplyIn , ?a , ((IN ** RIGHT @ EVAL) => ?a) , 0";
forcetheorem "ReverseIn" "(ReverseIn @ ?x) , (|- ?a) , (IN <= (RIGHT @ BIND @ ?x) => |- ?a) , 0";
forcetheorem "Disjoint" "Disjoint , (?P ||| ?Q) , ((?P && ?Q) === [false]) , Disjoint , 0";
forcetheorem "DiffSymmDisj" "DiffSymmDisj , ((?s -- ?x) ||| ?t) , ((?t -- ?x) ||| ?s) , AND , ASSERT , BOOLDEF , CASEINTRO , Disjoint , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , NOT1 , ODDCHOICE , REFLEX , SetDifference , TYPES , 0";
forcetheorem "SetEquiv" "SetEquiv , (?P === ?Q) , (forall @ [(?1 << ?P) == ?1 << ?Q]) , SetEquiv , 0";
forcetheorem "BRULE2" "BRULE2 , ((|- ?p) == ?q) , (?p == ?q) , ASSERT , EQBOOL , IFF , TYPES , 0";
forcetheorem "BRULE3" "BRULE3 , (?p == |- ?q) , (?p == ?q) , ASSERT , EQBOOL , IFF , TYPES , 0";
forcetheorem "SetEquiv2" "SetEquiv2 , (?P === ?Q) , (forall @ [(?P @ ?1) == ?Q @ ?1]) , ASSERT , EQBOOL , IFF , IN , SetEquiv , TYPES , 0";
forcetheorem "Union" "Union , (?P ++ ?Q) , [(?1 << ?P) | ?1 << ?Q] , Union , 0";
forcetheorem "Union2" "Union2 , (?P ++ ?Q) , [(?P @ ?1) | ?Q @ ?1] , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , OR , REFLEX , TYPES , Union , 0";
forcetheorem "Intersection" "Intersection , (?P && ?Q) , [(?1 << ?P) & ?1 << ?Q] , Intersection , 0";
forcetheorem "Intersection2" "Intersection2 , (?P && ?Q) , [(?P @ ?1) & ?Q @ ?1] , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , Intersection , NONTRIV , REFLEX , TYPES , 0";
forcetheorem "SetDifference" "SetDifference , (?P -- ?Q) , [(?1 << ?P) & ~ ?1 << ?Q] , SetDifference , 0";
forcetheorem "SetDifference2" "SetDifference2 , (?P -- ?Q) , [(?P @ ?1) & ~ ?Q @ ?1] , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , REFLEX , SetDifference , TYPES , 0";
forcetheorem "Subset" "Subset , (?P |= ?Q) , (forall @ [(?1 << ?P) -> ?1 << ?Q]) , Subset , 0";
forcetheorem "Subset2" "Subset2 , (?P |= ?Q) , (forall @ [(?P @ ?1) -> ?Q @ ?1]) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IN , NONTRIV , NOT1 , OR , REFLEX , Subset , TYPES , 0";
forcetheorem "Complement" "Complement , (^ ?P) , [~ ?1 << ?P] , Complement , 0";
forcetheorem "IN" "IN , (?x << ?y) , (|- ?y @ ?x) , IN , 0";
forcetheorem "Complement2" "Complement2 , (^ ?P) , [~ ?P @ ?1] , ASSERT , BOOLDEF , CASEINTRO , Complement , EQBOOL , EQUATION , FNDIST , IN , NONTRIV , NOT1 , REFLEX , TYPES , 0";
forcetheorem "TADDLEFT" "(TADDLEFT @ ?thm) , ?x , (?thm <= (?thm *> (RIGHT @ LEFT @ $ TYPES) ** $ ?thm) => ?x) , 0";
forcetheorem "ARROWRETRACT" "ARROWRETRACT , [?t2 : ?f @ ?t1 : ?1] , [?t2 : [?t2 : ?f @ ?t1 : ?2] @ ?t1 : ?1] , TYPES , 0";
forcetheorem "ARROWTYPE" "ARROWTYPE , ((?t1 ->> ?t2) : ?f) , [?t2 : ?f @ ?t1 : ?1] , ARROWTYPE , TYPES , 0";
forcetheorem "PI1" "PI1 , (P1 @ ?x , ?y) , ?x , P1 , 0";
forcetheorem "PI2" "PI2 , (P2 @ ?x , ?y) , ?y , P2 , 0";
forcetheorem "PRODRETRACT" "PRODRETRACT , ((?t1 : P1 @ ?x) , ?t2 : P2 @ ?x) , ((?t1 : P1 @ (?t1 : P1 @ ?x) , ?t2 : P2 @ ?x) , ?t2 : P2 @ (?t1 : P1 @ ?x) , ?t2 : P2 @ ?x) , P1 , P2 , TYPES , 0";
forcetheorem "PRODTYPE" "PRODTYPE , ((?t1 <*> ?t2) : ?x) , ((?t1 : P1 @ ?x) , ?t2 : P2 @ ?x) , P1 , P2 , PRODTYPE , TYPES , 0";
forcetheorem "UNIONRETRACT" "UNIONRETRACT , ((?x = ?t1 : ?x) || (?t1 : ?x) , ?t2 : ?x) , ((((?x = ?t1 : ?x) || (?t1 : ?x) , ?t2 : ?x) = ?t1 : (?x = ?t1 : ?x) || (?t1 : ?x) , ?t2 : ?x) || (?t1 : (?x = ?t1 : ?x) || (?t1 : ?x) , ?t2 : ?x) , ?t2 : (?x = ?t1 : ?x) || (?t1 : ?x) , ?t2 : ?x) , CASEINTRO , REFLEX , TYPES , 0";
forcetheorem "UNIONTYPE" "UNIONTYPE , ((?t1 <+> ?t2) : ?x) , ((?x = ?t1 : ?x) || (?t1 : ?x) , ?t2 : ?x) , CASEINTRO , REFLEX , TYPES , UNIONTYPE , 0";
forcetheorem "POINTTYPE" "POINTTYPE , ([?x] : ?y) , ?x , POINTTYPE , 0";
forcetheorem "BOOL_RETRACT" "BOOL_RETRACT , (?x || true , false) , ((?x || true , false) || true , false) , CASEINTRO , 0";
forcetheorem "Bool" "Bool , (Bool : ?x) , (?x || true , false) , Bool , CASEINTRO , 0";
forcetheorem "TRUERETRACT" "TRUERETRACT , true , true , 0";
forcetheorem "True" "True , (True : ?x) , true , True , 0";
forcetheorem "COMP_NAT_2" "COMP_NAT_2 , ?x , (COMP_NAT <= COMP_NAT => ?x) , 0";
forcetheorem "COMPEQTYPE" "COMPEQTYPE , (?x =! ?y) , (Bool : (Nat : ?x) =! Nat : ?y) , COMPEQTYPE , 0";
forcetheorem "COMPLESSTYPE" "COMPLESSTYPE , (?x <! ?y) , (Bool : (Nat : ?x) <! Nat : ?y) , COMPLESSTYPE , 0";
forcetheorem "COMP_MINUS" "COMP_MINUS , ((Nat : ?x) - Nat : ?y) , ((0 =! ?y -! ?x) || (?x -! ?y) , - ?y -! ?x) , COMP_MINUS , 0";
forcetheorem "COMP_DIV" "COMP_DIV , ((Nat : ?x) / Nat : ?y) , ((?x /! ?y) + (?x %! ?y) / Nat : ?y) , COMP_DIV , 0";
forcetheorem "TD" "TD , (?x * ?y / ?x) , ((0 = Real : ?x) || 0 , Real : ?y) , TD , 0";
forcetheorem "LESS_COMP" "LESS_COMP , ((Nat : ?x) < Nat : ?y) , (?x <! ?y) , LESS_COMP , 0";
forcetheorem "}LESS_COMP" "LESS_COMP , ((Nat : ?x) < Nat : ?y) , (?x <! ?y) , LESS_COMP , 0";
forcetheorem "COMPPLUSTYPE" "COMPPLUSTYPE , (?x +! ?y) , (Nat : (Nat : ?x) +! Nat : ?y) , COMPPLUSTYPE , 0";
forcetheorem "}COMP_PLUS" "COMP_PLUS , ((Nat : ?x) + Nat : ?y) , (?x +! ?y) , COMP_PLUS , 0";
forcetheorem "}PLUSTYPE" "PLUSTYPE , (?x + ?y) , ((Real : ?x) + Real : ?y) , PLUSTYPE , TYPES , 0";
forcetheorem "MINUSSCIN" "MINUSSCIN , (?x - ?y) , ((Real : ?x) - Real : ?y) , MINUSTYPE , TYPES , 0";
forcetheorem "}MINUSTYPE" "MINUSTYPE , (?x - ?y) , ((Real : ?x) - Real : ?y) , MINUSTYPE , TYPES , 0";
forcetheorem "}SubtypeLemma" "SubtypeLemma , (Nat : ?x) , (Real : (Real : Nat : 0) + Real : Nat : ?x) , PLUSTYPE , COMP_PLUS , COMP_NAT , PLUSCOMM , 0";
forcetheorem "}scratch" "scratch , (Nat : ?x) , (Real : Nat : ?x) , PLUSTYPE , COMP_PLUS , COMP_NAT , PLUSCOMM , TYPES , 0";
forcetheorem "COMPTIMESTYPE" "COMPTIMESTYPE , (?x *! ?y) , (Nat : (Nat : ?x) *! Nat : ?y) , COMPTIMESTYPE , 0";
forcetheorem "COMP_TIMES" "COMP_TIMES , ((Nat : ?x) * Nat : ?y) , (?x *! ?y) , COMP_TIMES , 0";
forcetheorem "TIMESCOMP" "TIMESCOMP , ((Nat : ?x) * Nat : ?y) , (?x *! ?y) , COMP_TIMES , 0";
forcetheorem "}COMP_TIMES" "COMP_TIMES , ((Nat : ?x) * Nat : ?y) , (?x *! ?y) , COMP_TIMES , 0";
forcetheorem "TIMESSCIN" "TIMESSCIN , (?x * ?y) , ((Real : ?x) * Real : ?y) , TIMESTYPE , TYPES , 0";
forcetheorem "COMPDIVTYPE" "COMPDIVTYPE , (?x /! ?y) , (Nat : (Nat : ?x) /! Nat : ?y) , COMPDIVTYPE , 0";
forcetheorem "INT_DIV" "INT_DIV , (?x ./. ?y) , (?x /! ?y) , INT_DIV , 0";
forcetheorem "INT_DIVTYPE" "INT_DIVTYPE , (?x ./. ?y) , (Nat : (Nat : ?x) ./. Nat : ?y) , COMPDIVTYPE , INT_DIV , 0";
forcetheorem "INT_DIVSCIN" "INT_DIVSCIN , (?x ./. ?y) , ((Nat : ?x) ./. Nat : ?y) , COMPDIVTYPE , INT_DIV , TYPES , 0";
forcetheorem "MOD_DEF" "MOD_DEF , (?x % ?y) , (?x %! ?y) , MOD_DEF , 0";
forcetheorem "}INT_DIVTYPE" "INT_DIVTYPE , (?x ./. ?y) , ((Nat : ?x) ./. Nat : ?y) , COMPDIVTYPE , INT_DIV , TYPES , 0";
forcetheorem "}MOD_DEF" "MOD_DEF , (?x % ?y) , (?x %! ?y) , MOD_DEF , 0";
forcetheorem "COMPMODTYPE" "COMPMODTYPE , (?x %! ?y) , (Nat : (Nat : ?x) %! Nat : ?y) , COMPMODTYPE , 0";
forcetheorem "MODCOMP" "MODCOMP , (?x % ?y) , (?x %! ?y) , MOD_DEF , 0";
forcetheorem "MODTYPE" "MODTYPE , (?x % ?y) , (Nat : (Nat : ?x) % Nat : ?y) , COMPMODTYPE , MOD_DEF , 0";
forcetheorem "MODSCIN" "MODSCIN , (?x % ?y) , ((Nat : ?x) % Nat : ?y) , COMPMODTYPE , MOD_DEF , TYPES , 0";
forcetheorem "}MODTYPE" "MODTYPE , (?x % ?y) , ((Nat : ?x) % Nat : ?y) , COMPMODTYPE , MOD_DEF , TYPES , 0";
forcetheorem "LESSTYPE" "LESSTYPE , (?x < ?y) , ((Real : ?x) < Real : ?y) , LESS , MINUSTYPE , TYPES , 0";
forcetheorem "}EQ_COMP" "EQ_COMP , (?x =! ?y) , ((Nat : ?x) = Nat : ?y) , EQ_COMP , 0";
forcetheorem "DIVSCIN" "DIVSCIN , (?x / ?y) , ((Real : ?x) / Real : ?y) , DIVTYPE , TYPES , 0";
forcetheorem "}DIVTYPE" "DIVTYPE , (?x / ?y) , ((Real : ?x) / Real : ?y) , DIVTYPE , TYPES , 0";
forcetheorem "TIMESINTDIV" "TIMESINTDIV , ((?x % ?y) + (?x ./. ?y) * Nat : ?y) , (Nat : ?x) , TIMESINTDIV , 0";
forcetheorem "NATCALC" "NATCALC , ?x , (MAKE_NAT_2 => MAKE_NAT_1 => ?x) , 0";
forcetheorem "EPLUSID" "EPLUSID , (?x + ?y) , ((PLUSID =>> COMMPLUSID) => ?x + ?y) , 0";
forcetheorem "TIMESASSOC" "TIMESASSOC , ((?x * ?y) * ?z) , (?x * ?y * ?z) , TIMESASSOC , 0";
forcetheorem "DIVTYPE" "DIVTYPE , (?x / ?y) , (Real : (Real : ?x) / Real : ?y) , DIVTYPE , 0";
forcetheorem "TIMESDIV" "TIMESDIV , ((?x / ?y) * ?y) , ((0 = Real : ?y) || 0 , Real : ?x) , TD , TIMESCOMM , 0";
forcetheorem "even" "even , (even @ ?x) , (forsome @ [(Nat : ?x) = (Nat : ?1) + Nat : ?1]) , even , 0";
forcetheorem "odd" "odd , (odd @ ?x) , (forsome @ [(Nat : ?x) = 1 + (Nat : ?1) + Nat : ?1]) , odd , 0";
forcetheorem "GCD1" "GCD1 , (gcd @ ?a , 0) , (Nat : ?a) , GCD1 , 0";
forcetheorem "}ZeroLemma" "ZeroLemma , (Nat : 0) , 0 , COMP_NAT , COMP_PLUS , PLUSCOMM , 0";
forcetheorem "EVALEQ" "EVALEQ , (?x =! ?y) , ((Nat : ?x) = Nat : ?y) , EQ_COMP , 0";
forcetheorem "EQEVAL2" "EQEVAL2 , ((Nat : ?a) = 0) , (?a =! 0) , COMP_NAT , COMP_PLUS , EQ_COMP , PLUSCOMM , 0";
forcetheorem "GCDTYPE" "GCDTYPE , (gcd @ ?a , ?b) , (gcd @ (Nat : ?a) , Nat : ?b) , GCDTYPE , 0";
forcetheorem "GCD2" "GCD2 , (gcd @ ?a , ?b) , (gcd @ ?b , ?a % ?b) , GCD2 , 0";
forcetheorem "GCD" "GCD , (gcd @ ?a , ?b) , ((EQEVAL2 => (Nat : ?b) = 0) || (BUILTIN => BUILTIN <= TYPES => GCD1 => gcd @ (Nat : ?a) , 0) , GCD => gcd @ ?b , MODCOMP => ?a % ?b) , CASEINTRO , GCD2 , GCDTYPE , 0";
forcetheorem "}MAKE_NAT" "MAKE_NAT , ?x , (MAKE_NAT_2 => MAKE_NAT_1 => ?x) , 0";
forcetheorem "FINDGCD" "FINDGCD , (gcd @ ?a , ?b) , ((GCD1 =>> GCD2 ** (RIGHT @ RIGHT @ MODCOMP) ** FINDGCD) => gcd @ ?a , ?b) , 0";
forcetheorem "COMPMINUSTYPE" "COMPMINUSTYPE , (?x -! ?y) , (Nat : (Nat : ?x) -! Nat : ?y) , COMPMINUSTYPE , 0";
forcetheorem "NAT_SUB" "NAT_SUB , (?x .-. ?y) , (((Nat : ?x) < Nat : ?y) || 0 , Nat : (Nat : ?x) - Nat : ?y) , CASEINTRO , COMPMINUSTYPE , COMP_NAT , FNDIST , NATMINUSCOMP , NAT__SUB , REFLEX , TYPES , 0";
forcetheorem "NATMINUSSCIN" "NATMINUSSCIN , (?x .-. ?y) , ((Nat : ?x) .-. Nat : ?y) , CASEINTRO , COMPMINUSTYPE , COMP_NAT , FNDIST , NATMINUSCOMP , NAT__SUB , REFLEX , TYPES , 0";
forcetheorem "PREDSCIN" "PREDSCIN , (Pred @ ?x) , (Pred @ Nat : ?x) , CASEINTRO , COMPMINUSTYPE , COMP_NAT , FNDIST , NATMINUSCOMP , NAT__SUB , Pred , REFLEX , TYPES , 0";
forcetheorem "Pred" "Pred , (Pred @ ?x) , (?x .-. 1) , Pred , 0";
forcetheorem "PREDTYPE" "PREDTYPE , (Pred @ ?x) , (Nat : Pred @ Nat : ?x) , CASEINTRO , COMPMINUSTYPE , COMP_NAT , FNDIST , NATMINUSCOMP , NAT__SUB , Pred , REFLEX , TYPES , 0";
forcetheorem "DIST" "DIST , (?x * ?y + ?z) , ((?x * ?y) + ?x * ?z) , DIST , 0";
forcetheorem "PLUSINVDIST" "PLUSINVDIST , (- ?x + ?y) , ((- ?x) + - ?y) , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "PM" "PM , (?x + ?y - ?x) , (Real : ?y) , PM , 0";
forcetheorem "MAKE_NAT" "MAKE_NAT , ?x , (MAKE_NAT_2 => MAKE_NAT_1 => ?x) , 0";
forcetheorem "COMP_NAT" "COMP_NAT , (Nat : ?x) , (?x +! 0) , COMP_NAT , 0";
forcetheorem "OR" "OR , (?x | ?y) , (~ (~ ?x) & ~ ?y) , OR , 0";
forcetheorem "TADDRIGHT" "(TADDRIGHT @ ?thm) , ?x , (?thm <= (?thm *> (RIGHT @ RIGHT @ $ TYPES) ** $ ?thm) => ?x) , 0";
forcetheorem "REALABS" "REALABS , (Real : Absolute : ?x) , (Absolute : ?x) , ABSOLUTE , FNDIST , MINUSTYPE , TYPES , 0";
forcetheorem "TIMESTYPE" "TIMESTYPE , (?x * ?y) , (Real : (Real : ?x) * Real : ?y) , TIMESTYPE , 0";
forcetheorem "TIMES_POS" "TIMES_POS , ((Absolute : ?x) * Absolute : ?y) , (Absolute : (Absolute : ?x) * Absolute : ?y) , TIMES_POS , 0";
forcetheorem "CASSOC" "CASSOC , ((?p & ?q) & ?r) , (?p & ?q & ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "SUBTRACT_DIFF" "SUBTRACT_DIFF , (?x - ?y - ?z) , (?x + (- ?y) + ?z) , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "DISTANCEFLIP" "DISTANCEFLIP , (Absolute : ?x - ?y) , (Absolute : ?y - ?x) , ABSOLUTE , ABSOLUTE2 , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "ZEROSELFINV" "ZEROSELFINV , ((Real : ?x) = - ?x) , (0 = Real : ?x) , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQUATION , EQ_COMP , MINUSTYPE , NONTRIV , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "NOT" "NOT , (~ ?y) , (?y || false , true) , NOT1 , 0";
forcetheorem "ALT_POS_DEF" "ALT_POS_DEF , (Positive @ ?x) , (0 < ?x) , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , LESS , MINUSTYPE , NONTRIV , NOT1 , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , Positive , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "ZERONOTPOS" "ZERONOTPOS , (Positive @ 0) , false , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , MINUSTYPE , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , Positive , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "POSTIMES" "POSTIMES , ((Positive @ ?x) & Positive @ ?y) , ((Positive @ ?x * ?y) & (Positive @ ?x) & Positive @ ?y) , ABSOLUTE , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , Positive , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESTYPE , TIMES_POS , TYPES , 0";
forcetheorem "SIGNPULL" "SIGNPULL , (?x * - ?y) , (- ?x * ?y) , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TIMESCOMM , TIMESTYPE , TYPES , 0";
forcetheorem "POSTYPE" "POSTYPE , (Positive @ ?x) , (bool : Positive @ Real : ?x) , ABSOLUTE , AND , EQBOOL , FNDIST , NONTRIV , Positive , TYPES , 0";
forcetheorem "SQUARE_POS" "SQUARE_POS , ((0 = Real : ?x) | Positive @ ?x * ?x) , true , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , MINUSTYPE , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , Positive , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TIMES_POS , TYPES , 0";
forcetheorem "POSASSERT" "POSASSERT , (Positive @ ?x) , (|- Positive @ ?x) , ABSOLUTE , AND , ASSERT , EQBOOL , FNDIST , NONTRIV , Positive , TYPES , 0";
forcetheorem "INDUCTION" "INDUCTION , (forall @ [?P @ Nat : ?1]) , ((?P @ 0) & forall @ [(?P @ Nat : ?1) -> ?P @ 1 + Nat : ?1]) , INDUCTION , 0";
forcetheorem "ZEROORSUCC" "ZEROORSUCC , (forall @ [(0 = Nat : ?1) | forsome @ [(Nat : ?1) = 1 + Nat : ?2]]) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "X1" "X1 , (?x + ?y) , ((ALLASSOCS @ PLUSASSOC) => (X => ?x) + X => ?y) , 0";
forcetheorem "X2" "X2 , (?x * ?y) , (X1 => (DIST =>> COMMDIST) => (ALLASSOCS @ TIMESASSOC) => (X => ?x) * X => ?y) , 0";
forcetheorem "X" "X , ?x , ((X1 =>> X2) => ?x) , 0";
forcetheorem "EQUATION_TO_DIFFERENCE" "EQUATION_TO_DIFFERENCE , ((Real : ?m) = Real : ?n) , ((?m - ?n) = 0) , CASEINTRO , COMP_NAT , COMP_PLUS , EQUATION , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "POSPLUS" "POSPLUS , ((Positive @ ?x) & Positive @ ?y) , ((Positive @ ?x + ?y) & (Positive @ ?x) & Positive @ ?y) , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , MINUSTYPE , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , Positive , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "ANDBOOL" "ANDBOOL , (?x & ?y) , (bool : ?x & ?y) , AND , EQBOOL , FNDIST , NONTRIV , 0";
forcetheorem "NOTBOTHPOS" "NOTBOTHPOS , ((Positive @ ?x) & Positive @ - ?x) , false , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , MINUSTYPE , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , Positive , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "TRICHOTOMY" "TRICHOTOMY , ((Positive @ ?x) | Positive @ - ?x) , (~ 0 = Real : ?x) , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , MINUSTYPE , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , Positive , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "POS_SIGN" "POS_SIGN , ((0 ~= Real : ?x) & Positive @ - ?x) , ((0 ~= Real : ?x) & ~ Positive @ ?x) , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , MINUSTYPE , NONTRIV , NOT1 , NOT_EQ , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , Positive , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "NOT_EQ" "NOT_EQ , (?x ~= ?y) , (~ ?x = ?y) , NOT_EQ , 0";
forcetheorem "NEWTAUT" "NEWTAUT , ?x , (ALT_PUSH => (TOPDOWN @ ALL_EXP) => MAKE_CASE => ?x) , 0";
forcetheorem "MAKE_CASE" "MAKE_CASE , ?p , (ODDCHOICE <= EQUATION => BOOLDEF => (?p = bool : ?p) => ?p) , 0";
forcetheorem "ASSERT_EXP" "ASSERT_EXP , ((|- ?p) || ?x , ?y) , (?p || ?x , ?y) , ASSERT , BOOLDEF , ODDCHOICE , 0";
forcetheorem "AND_EXP" "AND_EXP , ((?p & ?q) || ?a , ?b) , (?p || (?q || ?a , ?b) , ?b) , AND , CASEINTRO , ODDCHOICE , 0";
forcetheorem "IF_EXP" "IF_EXP , ((?p -> ?q) || ?a , ?b) , (?p || (?q || ?a , ?b) , ?a) , AND , CASEINTRO , IF , NOT1 , ODDCHOICE , OR , 0";
forcetheorem "IFF_EXP" "IFF_EXP , ((?p == ?q) || ?a , ?b) , (?p || (?q || ?a , ?b) , ?q || ?b , ?a) , BOOLDEF , CASEINTRO , EQUATION , IFF , ODDCHOICE , REFLEX , 0";
forcetheorem "XOR_EXP" "XOR_EXP , ((?p =/= ?q) || ?a , ?b) , (?p || (?q || ?b , ?a) , ?q || ?a , ?b) , BOOLDEF , CASEINTRO , EQUATION , IFF , NOT1 , ODDCHOICE , REFLEX , XOR , 0";
forcetheorem "CN_EXP" "CN_EXP , ((?p <- ?q) || ?a , ?b) , (?q || (?p || ?a , ?b) , ?a) , AND , CASEINTRO , CONVIF , IF , NOT1 , ODDCHOICE , OR , 0";
forcetheorem "ALL_EXP" "ALL_EXP , (?p || ?a , ?b) , (((ASSERT_EXP *> ALL_EXP) =>> (NOT_EXP *> ALL_EXP) =>> (AND_EXP *> ALL_EXP) =>> (OR_EXP *> ALL_EXP) =>> (IF_EXP *> ALL_EXP) =>> (IFF_EXP *> ALL_EXP) =>> (XOR_EXP *> ALL_EXP) =>> CN_EXP *> ALL_EXP) => ?p || ?a , ?b) , 0";
forcetheorem "UNPACK" "UNPACK , ((?x || ?y , ?z) || ?u , ?v) , (?x || (?y || ?u , ?v) , ?z || ?u , ?v) , CASEINTRO , 0";
forcetheorem "REAL_UNTYPE" "REAL_UNTYPE , ?x , ((EVERYWHERE @ REAL_UNTYPE_1) => ?x) , 0";
forcetheorem "REAL_UNTYPE_1" "REAL_UNTYPE_1 , ?x , (TYPES => (TREMBOTH @ PLUSTYPE) => (TREMBOTH @ MINUSTYPE) => (TREMTOP @ MINUSTYPE) => (TREMTOP @ PLUSTYPE) => ?x) , 0";
forcetheorem "GREATER_EQ_REAL" "GREATER_EQ_REAL , (?x >= ?y) , (((Real : ?x) = Real : ?y) | ?x > ?y) , GREATER_EQ_REAL , 0";
forcetheorem "ALT_PUSH" "ALT_PUSH , (?p || ?a , ?b) , (CASEINTRO <= ?p || (ALT_PUSH => (EVERYWHERE @ 1 |-| 1) => ?a) , ALT_PUSH => (EVERYWHERE @ 1 |-| 1) => ?b) , 0";
forcetheorem "MINUSFLIP" "MINUSFLIP , (- ?x - ?y) , (?y - ?x) , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "REAL_LESS_DEF" "REAL_LESS_DEF , (?x < ?y) , (Positive @ ?y - ?x) , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , LESS , MINUSTYPE , NONTRIV , NOT1 , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , Positive , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "POS_ZERO" "POS_ZERO , (Positive @ 0) , false , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , MINUSTYPE , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , Positive , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "SUCCNOTZERO_NAT" "SUCCNOTZERO_NAT , (0 = ?x .+. 1) , false , CASEINTRO , COMP_NAT , NATPLUS , PLUSCOMM , REFLEX , SUCCNOTZERO , 0";
forcetheorem "PLUSID_NAT" "PLUSID_NAT , (?x .+. 0) , (Nat : ?x) , CASEINTRO , COMP_NAT , COMP_PLUS , NATPLUS , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , TYPES , 0";
forcetheorem "ABSOLUTE" "ABSOLUTE , (Absolute : ?x) , (((Real : ?x) = Absolute : Real : ?x) || (Real : ?x) , - Real : ?x) , ABSOLUTE , 0";
forcetheorem "Positive" "Positive , (Positive @ ?x) , ((~ 0 = Real : ?x) & (Real : ?x) = Absolute : ?x) , Positive , 0";
forcetheorem "REALNUMERAL2" "REALNUMERAL2 , (Real : ?n) , (BUILTIN <= REALNAT <= (RIGHT @ TYPENUMERAL) => Real : ?n) , 0";
forcetheorem "TAB_AND_2" "TAB_AND_2 , ((?p & ?q) || ?a , ?b) , (?p || (?q || ?a , ?b) , ?b) , AND , CASEINTRO , EQUATION , ODDCHOICE , 0";
forcetheorem "ZERONOTONE" "ZERONOTONE , (0 = 1) , false , CASEINTRO , COMP_NAT , EQ_COMP , REFLEX , 0";
forcetheorem "REVPIVOT" "REVPIVOT , ((?a = ?b) || ?T , ?U) , ((LEFT_CASE @ EVAL) => HYP <= (?a = ?b) || ((BIND @ ?b) => ?T) , ?U) , 0";
forcetheorem "HYP" "HYP , ((?a = ?b) || (?f @ ?a) , ?c) , ((?a = ?b) || (?f @ ?b) , ?c) , HYP , 0";
forcetheorem "LEFT_CASE" "(LEFT_CASE @ ?thm) , (?x || ?y , ?z) , (?x || (?thm => ?y) , ?z) , 0";
forcetheorem "POS_ONE" "POS_ONE , (Positive @ 1) , true , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , MINUSTYPE , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , Positive , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TIMES_POS , TYPES , 0";
forcetheorem "NONTRIV" "NONTRIV , (true = false) , false , NONTRIV , 0";
forcetheorem "NOT1" "NOT1 , (~ ?y) , (?y || false , true) , NOT1 , 0";
forcetheorem "UNIV_EQ_TAC" "UNIV_EQ_TAC , ((forall @ [(?P @ ?1) = ?Q @ ?1]) || ?t , ?u) , ((LEFT @ $ UNIV_EQ) => ([?P @ ?1] = [?Q @ ?1]) || ((EVERYWHERE @ EVAL) => (EVERYWHERE @ 0 |-| 1) => (EVERYWHERE @ UNEVAL @ [?P @ ?1]) => ?t) , ?u) , CASEINTRO , EQBOOL , EQUATION , HYP , REFLEX , forall , 0";
forcetheorem "UNIV_EQ" "UNIV_EQ , (forall @ [(?P @ ?1) = ?Q @ ?1]) , ([?P @ ?1] = [?Q @ ?1]) , CASEINTRO , EQBOOL , EQUATION , HYP , REFLEX , forall , 0";
forcetheorem "MINUSZERO" "MINUSZERO , (- 0) , 0 , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "NOT_LEMMA" "NOT_LEMMA , (false = |- ?x) , (~ ?x) , ASSERT , BOOLDEF , CASEINTRO , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , 0";
forcetheorem "ABSREAL" "ABSREAL , (Absolute : Real : ?x) , (Absolute : ?x) , ABSOLUTE , TYPES , 0";
forcetheorem "MINUSZERO2" "MINUSZERO2 , (?x - 0) , (Real : ?x) , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "MINUSZERO_NAT" "MINUSZERO_NAT , (?x .-. 0) , (Nat : ?x) , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , HYP , IF , INDUCTION , LESS , MINUSTYPE , NAT__SUB , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TIMES_POS , TYPES , forall , 0";
forcetheorem "ALL_CANCEL_4" "ALL_CANCEL_4 , ((- ?x) + ?x + ?y) , (Real : ?y) , CASEINTRO , COMP_NAT , COMP_PLUS , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "ALL_CANCEL_1" "ALL_CANCEL_1 , ((- ?x) + ?x) , 0 , CASEINTRO , COMP_NAT , COMP_PLUS , PLUSCOMM , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "NATSNONNEG" "NATSNONNEG , ((Nat : ?x) < 0) , false , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , HYP , IF , INDUCTION , LESS , MINUSTYPE , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TIMES_POS , TYPES , forall , 0";
forcetheorem "COMMPLUSID" "COMMPLUSID , (?x + 0) , (Real : ?x) , PLUSCOMM , PLUSID , 0";
forcetheorem "PLUSMINUS_NAT" "PLUSMINUS_NAT , ((?x .+. 1) .-. 1) , (Nat : ?x) , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , HYP , IF , INDUCTION , LESS , MINUSTYPE , NATPLUS , NAT__SUB , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TIMES_POS , TYPES , forall , 0";
forcetheorem "PLUSSUCC_NAT" "PLUSSUCC_NAT , (?x .+. ?y .+. 1) , ((?x .+. ?y) .+. 1) , COMPPLUSTYPE , COMP_PLUS , NATPLUS , PLUSASSOC , TYPES , 0";
forcetheorem "COMP_PLUS" "COMP_PLUS , ((Nat : ?x) + Nat : ?y) , (?x +! ?y) , COMP_PLUS , 0";
forcetheorem "ZEROMINUS_NAT" "ZEROMINUS_NAT , (0 .-. 1) , 0 , ABSOLUTE , ABSOLUTE2 , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , HYP , LESS , MINUSTYPE , NAT__SUB , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TIMES_POS , TYPES , 0";
forcetheorem "PLUSSCIN_NAT" "PLUSSCIN_NAT , (?x .+. ?y) , ((Nat : ?x) .+. Nat : ?y) , COMPPLUSTYPE , COMP_PLUS , NATPLUS , TYPES , 0";
forcetheorem "INDUCTION_NAT" "INDUCTION_NAT , (forall @ [?P @ Nat : ?1]) , ((?P @ 0) & forall @ [(?P @ Nat : ?1) -> ?P @ ?1 .+. 1]) , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , NATPLUS , NONTRIV , NOT1 , OR , PLUSCOMM , PLUSTYPE , REFLEX , TYPES , 0";
forcetheorem "ABSOLUTE2" "ABSOLUTE2 , (Absolute : - ?x) , (Absolute : ?x) , ABSOLUTE2 , 0";
forcetheorem "EQ_COMP" "EQ_COMP , ((Nat : ?x) = Nat : ?y) , (?x =! ?y) , EQ_COMP , 0";
forcetheorem "REAL_LESS_CANCEL" "REAL_LESS_CANCEL , ((?z + ?x) < ?z + ?y) , (?x < ?y) , ABSOLUTE , ABSOLUTE2 , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , LESS , MINUSTYPE , NONTRIV , NOT1 , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "ALL_CANCEL_3" "ALL_CANCEL_3 , (?x + (- ?x) + ?y) , (Real : ?y) , CASEINTRO , COMP_NAT , COMP_PLUS , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "PLUS_POS" "PLUS_POS , ((Absolute : ?x) + Absolute : ?y) , (Absolute : (Absolute : ?x) + Absolute : ?y) , PLUS_POS , 0";
forcetheorem "REAL_TYPE" "REAL_TYPE , ?x , ((EVERYWHERE @ TYPES) => (EVERYWHERE @ REAL_TYPE_1) => ?x) , 0";
forcetheorem "REALNUMERAL" "REALNUMERAL , ?n , ((RIGHT @ $ BUILTIN) => REALNAT => TYPENUMERAL => ?n) , 0";
forcetheorem "TYPENUMERAL" "TYPENUMERAL , ?x , (MAKE_NAT_2 => MAKE_NAT_1 => ?x) , 0";
forcetheorem "MAKE_NAT_1" "MAKE_NAT_1 , ?x , ((REFLEX => ?x = ?x +! 0) || (Nat : ?x) , ?x) , CASEINTRO , COMP_NAT , 0";
forcetheorem "MAKE_NAT_2" "MAKE_NAT_2 , ((?x = ?x +! 0) || (Nat : ?x) , ?x) , ?x , CASEINTRO , COMP_NAT , 0";
forcetheorem "REAL_TYPE_1" "REAL_TYPE_1 , ?x , ((PLUSTYPE =>> (MINUSTYPE *> RIGHT @ LEFT @ TYPES ** $ REALZERO) =>> REALNUMERAL) => ?x) , 0";
forcetheorem "BUILTIN" "BUILTIN , (0 +! ?x) , (Nat : ?x) , COMP_NAT , COMP_PLUS , PLUSCOMM , 0";
forcetheorem "SUBTRACT_SUM" "SUBTRACT_SUM , (?x - ?y + ?z) , ((?x - ?y) - ?z) , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "NATPLUS" "NATPLUS , (?x .+. ?y) , ((Nat : ?x) + Nat : ?y) , NATPLUS , 0";
forcetheorem "TADDTOP" "(TADDTOP @ ?thm) , ?x , ((?thm *> ($ TYPES) ** RIGHT @ $ ?thm) => ?x) , 0";
forcetheorem "PLUSTYPE_NAT" "PLUSTYPE_NAT , (?x .+. ?y) , (Nat : (Nat : ?x) .+. Nat : ?y) , COMPPLUSTYPE , COMP_PLUS , NATPLUS , TYPES , 0";
forcetheorem "ABSOLUTE_ONE" "ABSOLUTE_ONE , (Absolute : 1) , 1 , ABSOLUTE , ABSOLUTE2 , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , HYP , MINUSTYPE , NONTRIV , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TIMES_POS , TYPES , 0";
forcetheorem "MINUSSUCC_NAT" "MINUSSUCC_NAT , (?x .-. ?y .+. 1) , ((?x .-. ?y) .-. 1) , ABSOLUTE , ABSOLUTE2 , BOOLDEF , CASEINTRO , COMPMINUSTYPE , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , HYP , LESS , MINUSTYPE , NATMINUSCOMP , NATPLUS , NAT__SUB , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TIMES_POS , TYPES , 0";
forcetheorem "TADDBOTH" "(TADDBOTH @ ?thm) , ?x , (?thm <= (?thm *> (RIGHT @ (RIGHT @ $ TYPES) ** LEFT @ $ TYPES) ** $ ?thm) => ?x) , 0";
forcetheorem "NATLESSSCIN" "NATLESSSCIN , (?x .<. ?y) , ((Nat : ?x) .<. Nat : ?y) , COMPMINUSTYPE , NATLESS , NATMINUSCOMP , NAT__SUB , TYPES , 0";
forcetheorem "GETPLUS" "(GETPLUS @ ?z) , (?x + ?y) , ((GET @ ?z , PLUSCOMM , PLUSASSOC) => ?x + ?y) , 0";
forcetheorem "ALL_CANCEL_2" "ALL_CANCEL_2 , (?x + - ?x) , 0 , CASEINTRO , COMP_NAT , COMP_PLUS , PLUSCOMM , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "MINUSTYPE" "MINUSTYPE , (?x - ?y) , (Real : (Real : ?x) - Real : ?y) , MINUSTYPE , 0";
forcetheorem "ALL_CANCEL" "ALL_CANCEL , ?x , ((TREMTOP @ MINUSTYPE) => (TREMTOP @ PLUSTYPE) => ALL_CANCEL_7 => (EVERYWHERE @ TREMRIGHT @ PLUSTYPE) => (EVERYWHERE @ TREMLEFT @ PLUSTYPE) => (EVERYWHERE @ TYPES) => (TOPDOWN @ MINUSMINUS) => (EVERYWHERE @ PLUSINVDISTS) => (EVERYWHERE @ BREAKMINUS ** FIXBREAKMINUS) => ?x) , 0";
forcetheorem "FIXBREAKMINUS" "FIXBREAKMINUS , (0 + - ?x) , (- ?x) , MINUSTYPE , PLUSID , TYPES , 0";
forcetheorem "PLUSINVDISTS" "PLUSINVDISTS , (- ?x + ?y) , ((PLUSINVDISTS => - ?x) + PLUSINVDISTS => - ?y) , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "MINUSMINUS" "MINUSMINUS , (- - ?x) , (Real : ?x) , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "TREMLEFT" "(TREMLEFT @ ?thm) , (?x ^+ ?y) , ((?thm *> (RIGHT @ LEFT @ TYPES) ** $ ?thm) => ?x ^+ ?y) , 0";
forcetheorem "ALL_CANCEL_7" "ALL_CANCEL_7 , ?x , (ALL_CANCEL_5 => ALL_CANCEL_6 => (TREMRIGHT @ PLUSTYPE) => (RIGHT @ ALL_CANCEL_7) => (ALLASSOCS @ PLUSASSOC) => ?x) , 0";
forcetheorem "ALLASSOCS" "(ALLASSOCS @ ?thm) , ?x , ((RIGHT @ ALLASSOCS @ ?thm) => (ASSOCS @ ?thm) => ?x) , 0";
forcetheorem "PLUSTYPE" "PLUSTYPE , (?x + ?y) , (Real : (Real : ?x) + Real : ?y) , PLUSTYPE , 0";
forcetheorem "TREMRIGHT" "(TREMRIGHT @ ?thm) , (?x ^+ ?y) , ((?thm *> (RIGHT @ RIGHT @ TYPES) ** $ ?thm) => ?x ^+ ?y) , 0";
forcetheorem "ALL_CANCEL_6" "ALL_CANCEL_6 , (?x + ?y) , ((ALL_CANCEL_2 =>> ALL_CANCEL_3) => ?x + (GETPLUS @ - ?x) => ?y) , 0";
forcetheorem "ALL_CANCEL_5" "ALL_CANCEL_5 , ((- ?x) + ?y) , ((ALL_CANCEL_1 =>> ALL_CANCEL_4) => (- ?x) + (GETPLUS @ ?x) => ?y) , 0";
forcetheorem "ABSOLUTE_ZERO" "ABSOLUTE_ZERO , (Absolute : 0) , 0 , ABSOLUTE , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "NATLESS" "NATLESS , (?x .<. ?y) , (~ (?y .-. ?x) = 0) , NATLESS , 0";
forcetheorem "UNEVAL_TAC" "(UNEVAL_TAC @ ?f) , ?x , ((BOTH_CASES @ EVAL) => FNDIST => (UNEVAL @ ?f) => ?x) , 0";
forcetheorem "BOTH_CASES" "(BOTH_CASES @ ?thm) , (?x || ?y , ?z) , (?x || (?thm => ?y) , ?thm => ?z) , 0";
forcetheorem "REAL_LESS_TRANS" "REAL_LESS_TRANS , ((?x < ?y) & ?y < ?z) , ((?x < ?z) & (?x < ?y) & ?y < ?z) , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , LESS , MINUSTYPE , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "TAB_AND" "TAB_AND , (?p & ?q) , (?p || (?q || true , false) , false) , AND , EQUATION , ODDCHOICE , 0";
forcetheorem "NOT_LESS_THAN_SELF" "NOT_LESS_THAN_SELF , (?x < ?x) , false , ABSOLUTE , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , LESS , MINUSTYPE , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "EVERYWHERE2" "(EVERYWHERE2 @ ?thm) , ?x , (((STRONG_EVERYWHERE_CASE @ EVERYWHERE2 , ?thm) =>> (EVERYWHERE_INFIX @ EVERYWHERE2 , ?thm) =>> (EVERYWHERE_PREFIX @ EVERYWHERE2 , ?thm) =>> (EVERYWHERE_ABS @ EVERYWHERE2 , ?thm) =>> ?thm) => ?x) , 0";
forcetheorem "STRONG_EVERYWHERE_CASE" "(STRONG_EVERYWHERE_CASE @ ?EVERYWHERE , ?thm) , (?a || ?x , ?y) , (?thm => ((?EVERYWHERE @ ?thm) => ?a) || ((?EVERYWHERE @ ?thm) => ?x) , (?EVERYWHERE @ ?thm) => ?y) , 0";
forcetheorem "EVERYWHERE_ABS" "(EVERYWHERE_ABS @ ?EVERYWHERE , ?thm) , [?f @ ?1] , (?thm => [(?EVERYWHERE @ ?thm) => ?f @ ?1]) , 0";
forcetheorem "DIFF_EQ" "DIFF_EQ , (0 = ?y - ?x) , ((Real : ?x) = Real : ?y) , CASEINTRO , COMP_NAT , COMP_PLUS , EQUATION , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "TAB_NOT_2" "TAB_NOT_2 , ((~ ?p) || ?a , ?b) , (?p || ?b , ?a) , CASEINTRO , NOT1 , ODDCHOICE , 0";
forcetheorem "REAL_NOT_LESS" "REAL_NOT_LESS , (~ ?x < ?y) , (?y =< ?x) , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , LESS , LESS_EQ_REAL , MINUSTYPE , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "TAB_OR" "TAB_OR , (?p | ?q) , (?p || true , ?q || true , false) , AND , CASEINTRO , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , 0";
forcetheorem "ASSERT_UNEXP" "ASSERT_UNEXP , (?p || true , false) , (|- ?p) , ASSERT , BOOLDEF , EQUATION , 0";
forcetheorem "LESS" "LESS , (?x < ?y) , (~ (?x - ?y) = Absolute : ?x - ?y) , LESS , 0";
forcetheorem "NATLESS2" "NATLESS2 , (?x .<. ?y) , ((Nat : ?x) < Nat : ?y) , ABSOLUTE , ABSOLUTE2 , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , LESS , MINUSTYPE , NATLESS , NAT__SUB , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "FORSOMEBOOL" "FORSOMEBOOL , (forsome @ ?P) , (bool : forsome @ ?P) , EQBOOL , FNDIST , NONTRIV , NOT1 , REFLEX , forsome , 0";
forcetheorem "forsome" "forsome , (forsome @ ?P) , (~ forall @ [~ ?P @ ?1]) , forsome , 0";
forcetheorem "INSTANTIATE" "INSTANTIATE , ((?P @ ?x) & forall @ [?P @ ?1]) , (forall @ [?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , NONTRIV , forall , 0";
forcetheorem "MP_THM" "MP_THM , (((?P @ ?x) & forall @ [(?P @ ?1) -> ?Q @ ?1]) -> ?Q @ ?x) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , 0";
forcetheorem "}MP_THM" "MP_THM , true , (((?P @ ?x) & forall @ [(?P @ ?1) -> ?Q @ ?1]) -> ?Q @ ?x) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , AND , ODDCHOICE , TYPES , forall , 0";
forcetheorem "}INSTANTIATE" "INSTANTIATE , (forall @ [?P @ ?1]) , ((?P @ ?x) & forall @ [?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , NONTRIV , forall , 0";
forcetheorem "FNOT_LESS_0" "FNOT_LESS_0 , (forall @ [~ (Nat : ?1) < 0]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "NOT_LESS_0F" "(NOT_LESS_0F @ ?x) , true , (~ (Nat : ?x) < 0) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "}NOT_LESS_0" "NOT_LESS_0 , true , (~ (Nat : ?x) < 0) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "PLUSCOMP" "PLUSCOMP , ((Nat : ?x) + Nat : ?y) , (?x +! ?y) , COMP_PLUS , 0";
forcetheorem "REALZERO" "REALZERO , 0 , (Real : 0) , CASEINTRO , COMP_NAT , COMP_PLUS , PLUSCOMM , PLUSTYPE , REFLEX , TYPES , 0";
forcetheorem "BREAKMINUS" "BREAKMINUS , (?x - ?y) , (?x + - ?y) , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "SUB_REFL" "SUB_REFL , (?x - ?x) , 0 , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "SUC_ID" "SUC_ID , ((1 + Nat : ?x) = Nat : ?x) , false , CASEINTRO , COMP_NAT , COMP_PLUS , EQUATION , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SUCCNOTZERO , TYPES , 0";
forcetheorem "SUC_IDF" "(SUC_IDF @ ?x) , false , ((1 + Nat : ?x) = Nat : ?x) , CASEINTRO , COMP_NAT , COMP_PLUS , EQUATION , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SUCCNOTZERO , TYPES , 0";
forcetheorem "}SUC_ID" "SUC_ID , false , ((1 + Nat : ?x) = Nat : ?x) , CASEINTRO , COMP_NAT , COMP_PLUS , EQUATION , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SUCCNOTZERO , TYPES , 0";
forcetheorem "MINUSPLUS" "MINUSPLUS , ((?x + ?y) - ?y) , (Real : ?x) , CASEINTRO , COMP_NAT , COMP_PLUS , MINUSTYPE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "ASSERT" "ASSERT , (|- ?x) , (bool : ?x) , ASSERT , 0";
forcetheorem "TRUEBOOL" "TRUEBOOL , true , (bool : true) , EQBOOL , REFLEX , 0";
forcetheorem "BDIS" "BDIS , (~ ?p == ?q) , ((~ ?p) == ?q) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "}LESS_MONO" "LESS_MONO , true , (((Nat : ?m) < Nat : ?n) -> (1 + Nat : ?m) < 1 + Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "ASSERTSCOUT" "ASSERTSCOUT , (|- ?x) , (bool : |- ?x) , ASSERT , TYPES , 0";
forcetheorem "MP_THMF" "(MP_THMF @ ?P , ?Q , ?x) , true , (((?P @ ?x) & forall @ [(?P @ ?1) -> ?Q @ ?1]) -> ?Q @ ?x) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , 0";
forcetheorem "NRULE2" "NRULE2 , (~ |- ?p) , (~ ?p) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , TYPES , 0";
forcetheorem "ALTORDEF" "ALTORDEF , (?x | ?y) , (?x || true , ?y || true , false) , AND , CASEINTRO , NONTRIV , NOT1 , OR , REFLEX , 0";
forcetheorem "LESS_SUCF" "(LESS_SUCF @ ?x , ?y) , true , (((Nat : ?x) < Nat : ?y) -> (Nat : ?x) < 1 + Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "}LESS_SUC" "LESS_SUC , true , (((Nat : ?x) < Nat : ?y) -> (Nat : ?x) < 1 + Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "FORALL_LESS_SUC_REFL" "FORALL_LESS_SUC_REFL , (forall @ [(Nat : ?1) < 1 + Nat : ?1]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_SUC_REFLF" "(LESS_SUC_REFLF @ ?x) , true , ((Nat : ?x) < 1 + Nat : ?x) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_SUC_REFL" "LESS_SUC_REFL , true , ((Nat : ?x) < 1 + Nat : ?x) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_LEMMA2" "LESS_LEMMA2 , ((((Nat : ?x) = Nat : ?y) | (Nat : ?x) < Nat : ?y) -> (Nat : ?x) < 1 + Nat : ?y) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_LEMMA2" "LESS_LEMMA2 , true , ((((Nat : ?x) = Nat : ?y) | (Nat : ?x) < Nat : ?y) -> (Nat : ?x) < 1 + Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "FORALL_IMP_FORSOME_EQ" "FORALL_IMP_FORSOME_EQ , (forall @ [(?P @ ?1) -> ?Q]) , ((forsome @ [?P @ ?1]) -> ?Q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "forall" "forall , (forall @ ?P) , ([?P @ ?1] = [true]) , forall , 0";
forcetheorem "CIDEM" "CIDEM , (?p & ?p) , (|- ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "TWOASSERTS" "TWOASSERTS , (|- |- ?p) , (|- ?p) , ASSERT , TYPES , 0";
forcetheorem "LESS_LEMMA1" "LESS_LEMMA1 , (((Nat : ?x) < 1 + Nat : ?y) -> ((Nat : ?x) = Nat : ?y) | (Nat : ?x) < Nat : ?y) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "}LESS_LEMMA1" "LESS_LEMMA1 , true , (((Nat : ?x) < 1 + Nat : ?y) -> ((Nat : ?x) = Nat : ?y) | (Nat : ?x) < Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "LESS_LEMMA2F" "(LESS_LEMMA2F @ ?x , ?y) , true , ((((Nat : ?x) = Nat : ?y) | (Nat : ?x) < Nat : ?y) -> (Nat : ?x) < 1 + Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_LEMMA1F" "(LESS_LEMMA1F @ ?x , ?y) , true , (((Nat : ?x) < 1 + Nat : ?y) -> ((Nat : ?x) = Nat : ?y) | (Nat : ?x) < Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "LESS_SUC_IMP" "LESS_SUC_IMP , (((Nat : ?m) < 1 + Nat : ?n) -> (~ (Nat : ?m) = Nat : ?n) -> (Nat : ?m) < Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_SUC_IMPF" "(LESS_SUC_IMPF @ ?m , ?n) , true , (((Nat : ?m) < 1 + Nat : ?n) -> (~ (Nat : ?m) = Nat : ?n) -> (Nat : ?m) < Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_SUC_IMP" "LESS_SUC_IMP , true , (((Nat : ?m) < 1 + Nat : ?n) -> (~ (Nat : ?m) = Nat : ?n) -> (Nat : ?m) < Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_0_0" "LESS_0_0 , (0 < 1 + 0) , true , CASEINTRO , COMP_NAT , COMP_PLUS , LESS_COMP , REFLEX , 0";
forcetheorem "DEMb" "DEMb , ((~ ?p) & ~ ?q) , (~ ?p | ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "GET" "(GET @ ?y , ?comm , ?assoc) , ?x , (((GET1 @ ?y , ?comm) =>> GET2 @ ?y , ?comm , ?assoc) => ((GET0 @ ?y) =>> RIGHT @ GET @ ?y , ?comm , ?assoc) => (ASSOCS @ ?assoc) => ?x) , 0";
forcetheorem "ASSOCS" "(ASSOCS @ ?thm) , ?x , ((?thm *> ASSOCS @ ?thm) => ?x) , 0";
forcetheorem "GET0" "(GET0 @ ?x) , (?x ^+ ?y) , (?x ^+ ?y) , 0";
forcetheorem "GET1" "(GET1 @ ?x , ?comm) , (?y ^+ ?x) , (?comm => ?y ^+ ?x) , 0";
forcetheorem "GET2" "(GET2 @ ?x , ?comm , ?assoc) , (?y ^+ ?x ^+ ?z) , (?assoc => (LEFT @ ?comm) => ?assoc <= ?y ^+ ?x ^+ ?z) , 0";
forcetheorem "DXM" "DXM , (?p | ~ ?p) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , 0";
forcetheorem "FORALL_LESS_0" "FORALL_LESS_0 , (forall @ [0 < 1 + Nat : ?1]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_0F" "(LESS_0F @ ?x) , true , (0 < 1 + Nat : ?x) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_0" "LESS_0 , true , (0 < 1 + Nat : ?x) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS1" "LESS1 , ((Nat : ?x) < Nat : ?y) , (forsome @ [(forall @ [(?1 @ 1 + Nat : ?2) -> ?1 @ Nat : ?2]) & (?1 @ Nat : ?x) & ~ ?1 @ Nat : ?y]) , LESS1 , 0";
forcetheorem "SUC_EQ_LESSF" "(SUC_EQ_LESSF @ ?x , ?y) , true , (((1 + Nat : ?x) = Nat : ?y) -> (Nat : ?x) < Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}SUC_EQ_LESS" "SUC_EQ_LESS , true , (((1 + Nat : ?x) = Nat : ?y) -> (Nat : ?x) < Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}EQ_NOT_LESS" "EQ_NOT_LESS , true , (((Nat : ?x) = Nat : ?y) -> ~ (Nat : ?x) < Nat : ?y) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "EQBOOL" "EQBOOL , (?x = ?y) , (bool : ?x = ?y) , EQBOOL , 0";
forcetheorem "EQ_NOT_LESS" "EQ_NOT_LESS , (((Nat : ?x) = Nat : ?y) -> ~ (Nat : ?x) < Nat : ?y) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "LESS_NOT_EQ" "LESS_NOT_EQ , (((Nat : ?x) < Nat : ?y) -> ~ (Nat : ?x) = Nat : ?y) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "LESS_NOT_EQF" "(LESS_NOT_EQF @ ?x , ?y) , true , (((Nat : ?x) < Nat : ?y) -> ~ (Nat : ?x) = Nat : ?y) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "}LESS_NOT_EQ" "LESS_NOT_EQ , true , (((Nat : ?x) < Nat : ?y) -> ~ (Nat : ?x) = Nat : ?y) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "LESS_SUC_SUC" "LESS_SUC_SUC , ((Nat : ?x) < 1 + 1 + Nat : ?x) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_SUC_SUCF" "(LESS_SUC_SUCF @ ?x) , true , ((Nat : ?x) < 1 + 1 + Nat : ?x) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_SUC_SUC" "LESS_SUC_SUC , true , ((Nat : ?x) < 1 + 1 + Nat : ?x) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LEQ_SUC" "LEQ_SUC , ((Nat : ?n) =< 1 + Nat : ?m) , (((Nat : ?n) =< Nat : ?m) | (Nat : ?n) = 1 + Nat : ?m) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_MONO_REV" "LESS_MONO_REV , true , (((1 + Nat : ?m) < 1 + Nat : ?n) -> (Nat : ?m) < Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_MONOF" "(LESS_MONOF @ ?m , ?n) , true , (((Nat : ?m) < Nat : ?n) -> (1 + Nat : ?m) < 1 + Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_MONO_REVF" "(LESS_MONO_REVF @ ?m , ?n) , true , (((1 + Nat : ?m) < 1 + Nat : ?n) -> (Nat : ?m) < Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_0_CASES_INV" "LESS_0_CASES_INV , ((0 < Nat : ?m) | 0 = Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_EQ_SUC_LESS" "LESS_EQ_SUC_LESS , (((1 + Nat : ?n) < Nat : ?m) | (1 + Nat : ?n) = Nat : ?m) , ((Nat : ?n) < Nat : ?m) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "FORALL_LESS_CASES" "FORALL_LESS_CASES , (forall @ [((Nat : ?1) < Nat : ?m) | ((Nat : ?1) = Nat : ?m) | (Nat : ?m) < Nat : ?1]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_CASES" "LESS_CASES , true , (((Nat : ?n) < Nat : ?m) | ((Nat : ?n) = Nat : ?m) | (Nat : ?m) < Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "DRULE1" "DRULE1 , (|- ?p | ?q) , (?p | ?q) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , OR , REFLEX , TYPES , 0";
forcetheorem "LESS_CASES_IMP" "LESS_CASES_IMP , ((~ ((Nat : ?m) < Nat : ?n) | (Nat : ?m) = Nat : ?n) -> (Nat : ?n) < Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_MONO" "LESS_MONO , (((Nat : ?m) < Nat : ?n) -> (1 + Nat : ?m) < 1 + Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "SUC_LESS" "SUC_LESS , (((1 + Nat : ?x) < Nat : ?y) -> (Nat : ?x) < Nat : ?y) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "SUC_EQ_LESS" "SUC_EQ_LESS , (((1 + Nat : ?x) = Nat : ?y) -> (Nat : ?x) < Nat : ?y) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "OR_LESS" "OR_LESS , (((1 + Nat : ?m) =< Nat : ?n) -> (Nat : ?m) < Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LEQ_SUC_REFL" "LEQ_SUC_REFL , ((Nat : ?m) =< 1 + Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_0_CASES" "LESS_0_CASES , ((0 = Nat : ?m) | 0 < Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "ALL_GEQ_0" "ALL_GEQ_0 , (0 =< Nat : ?x) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "SAMESUCC" "SAMESUCC , ((Nat : ?x) = Nat : ?y) , ((1 + Nat : ?x) = 1 + Nat : ?y) , SAMESUCC , 0";
forcetheorem "LESS_EQ_MONO" "LESS_EQ_MONO , ((1 + Nat : ?n) =< 1 + Nat : ?m) , ((Nat : ?n) =< Nat : ?m) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "IDEF2" "IDEF2 , (?p -> ?q) , ((~ ?p) | ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "LESS_SUC_EQ_COR" "LESS_SUC_EQ_COR , ((((Nat : ?m) < Nat : ?n) & ~ (1 + Nat : ?m) = Nat : ?n) -> (1 + Nat : ?m) < Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_NOT_SUC" "LESS_NOT_SUC , ((((Nat : ?m) < Nat : ?n) & ~ (Nat : ?n) = 1 + Nat : ?m) -> (1 + Nat : ?m) < Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_MONO_REV" "LESS_MONO_REV , (((1 + Nat : ?m) < 1 + Nat : ?n) -> (Nat : ?m) < Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "NOT_ADD_LESS" "NOT_ADD_LESS , (forall @ [~ ((Nat : ?x) + Nat : ?1) < Nat : ?1]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "NOT_ADD_LESSF" "(NOT_ADD_LESSF @ ?x) , true , (forall @ [~ ((Nat : ?x) + Nat : ?1) < Nat : ?1]) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}NOT_ADD_LESS" "NOT_ADD_LESS , true , (forall @ [~ ((Nat : ?x) + Nat : ?1) < Nat : ?1]) , PLUSTYPE , TYPES , EQBOOL , FNDIST , NONTRIV , NOT1 , REFLEX , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQUATION , IF , INDUCTION , LESS1 , LESS_COMP , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , SAMESUCC , forall , forsome , 0";
forcetheorem "3pt76a" "3pt76a , (?p -> ?p | ?q) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "LESS_IMP_LEQ" "LESS_IMP_LEQ , (((Nat : ?m) < Nat : ?n) -> (Nat : ?m) =< Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , TYPES , 0";
forcetheorem "CRULE3" "CRULE3 , (?p & |- ?q) , (?p & ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , REFLEX , TYPES , 0";
forcetheorem "FORALL_LESS_TRANS" "FORALL_LESS_TRANS , (forall @ [(((Nat : ?m) < Nat : ?n) & (Nat : ?n) < Nat : ?1) -> (Nat : ?m) < Nat : ?1]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_TRANS" "LESS_TRANS , true , ((((Nat : ?m) < Nat : ?n) & (Nat : ?n) < Nat : ?p) -> (Nat : ?m) < Nat : ?p) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "CRULE2" "CRULE2 , ((|- ?p) & ?q) , (?p & ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , REFLEX , TYPES , 0";
forcetheorem "CZER" "CZER , (?p & false) , false , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "LESS_TRANSF" "(LESS_TRANSF @ ?m , ?n , ?p) , true , ((((Nat : ?m) < Nat : ?n) & (Nat : ?n) < Nat : ?p) -> (Nat : ?m) < Nat : ?p) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "FORALL_LESS_ANTISYM" "FORALL_LESS_ANTISYM , (forall @ [~ ((Nat : ?m) < Nat : ?1) & (Nat : ?1) < Nat : ?m]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "NOTBOOL" "NOTBOOL , (~ ?y) , (bool : ~ ?y) , EQBOOL , FNDIST , NONTRIV , NOT1 , REFLEX , 0";
forcetheorem "LESS_ANTISYMF" "(LESS_ANTISYMF @ ?m , ?n) , true , (~ ((Nat : ?m) < Nat : ?n) & (Nat : ?n) < Nat : ?m) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_ANTISYM" "LESS_ANTISYM , true , (~ ((Nat : ?m) < Nat : ?n) & (Nat : ?n) < Nat : ?m) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_THM" "LESS_THM , ((Nat : ?x) < 1 + Nat : ?y) , (((Nat : ?x) = Nat : ?y) | (Nat : ?x) < Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_NOT_REFL" "LESS_NOT_REFL , (~ (Nat : ?x) < Nat : ?x) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "LESS_LESS_SUC" "LESS_LESS_SUC , (~ ((Nat : ?m) < Nat : ?n) & (Nat : ?n) < 1 + Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "BOUNDED_N" "BOUNDED_N , ((((Nat : ?m) < Nat : ?n) & (Nat : ?n) =< 1 + Nat : ?m) -> (Nat : ?n) = 1 + Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "3pt64" "3pt64 , ((?p -> ?q) -> ?p -> ?r) , (?p -> ?q -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "}FORALL_LESS_MONO_ADD" "FORALL_LESS_MONO_ADD , true , (forall @ [((Nat : ?m) < Nat : ?n) -> ((Nat : ?m) + Nat : ?1) < (Nat : ?n) + Nat : ?1]) , PLUSTYPE , TYPES , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , AND , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , INDUCTION , LESS1 , LESS_COMP , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , SAMESUCC , forall , forsome , 0";
forcetheorem "FORALL_LESS_MONO_ADDF" "(FORALL_LESS_MONO_ADDF @ ?m , ?n) , true , (forall @ [((Nat : ?m) < Nat : ?n) -> ((Nat : ?m) + Nat : ?1) < (Nat : ?n) + Nat : ?1]) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "FORALL_LESS_MONO_ADD" "FORALL_LESS_MONO_ADD , (forall @ [((Nat : ?m) < Nat : ?n) -> ((Nat : ?m) + Nat : ?1) < (Nat : ?n) + Nat : ?1]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_MONO_ADD" "LESS_MONO_ADD , (((Nat : ?m) < Nat : ?n) -> ((Nat : ?m) + Nat : ?p) < (Nat : ?n) + Nat : ?p) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_MONO_ADD" "LESS_MONO_ADD , true , (((Nat : ?m) < Nat : ?n) -> ((Nat : ?m) + Nat : ?p) < (Nat : ?n) + Nat : ?p) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}FORALL_LESS_MONO_ADD_INV" "FORALL_LESS_MONO_ADD_INV , true , (forall @ [(((Nat : ?m) + Nat : ?1) < (Nat : ?n) + Nat : ?1) -> (Nat : ?m) < Nat : ?n]) , PLUSTYPE , TYPES , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , AND , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , INDUCTION , LESS1 , LESS_COMP , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , SAMESUCC , forall , forsome , 0";
forcetheorem "FORALL_LESS_MONO_ADD_INVF" "(FORALL_LESS_MONO_ADD_INVF @ ?m , ?n) , true , (forall @ [(((Nat : ?m) + Nat : ?1) < (Nat : ?n) + Nat : ?1) -> (Nat : ?m) < Nat : ?n]) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "FORALL_LESS_MONO_ADD_INV" "FORALL_LESS_MONO_ADD_INV , (forall @ [(((Nat : ?m) + Nat : ?1) < (Nat : ?n) + Nat : ?1) -> (Nat : ?m) < Nat : ?n]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_MONO_ADD_INV" "LESS_MONO_ADD_INV , ((((Nat : ?m) + Nat : ?p) < (Nat : ?n) + Nat : ?p) -> (Nat : ?m) < Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_MONO_ADD_INV" "LESS_MONO_ADD_INV , true , ((((Nat : ?m) + Nat : ?p) < (Nat : ?n) + Nat : ?p) -> (Nat : ?m) < Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_MONO_ADDF" "(LESS_MONO_ADDF @ ?m , ?n , ?p) , true , (((Nat : ?m) < Nat : ?n) -> ((Nat : ?m) + Nat : ?p) < (Nat : ?n) + Nat : ?p) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_MONO_ADD_INVF" "(LESS_MONO_ADD_INVF @ ?m , ?n , ?p) , true , ((((Nat : ?m) + Nat : ?p) < (Nat : ?n) + Nat : ?p) -> (Nat : ?m) < Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "3pt80" "3pt80 , ((?p -> ?q) & ?q -> ?p) , (?p == ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , IFF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "BSYM" "BSYM , (?p == ?q) , (?q == ?p) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , IFF , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "BRULE1" "BRULE1 , (|- ?p == ?q) , (?p == ?q) , ASSERT , EQBOOL , IFF , TYPES , 0";
forcetheorem "BASSOC" "BASSOC , ((?p == ?q) == ?r) , (?p == ?q == ?r) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , IFF , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "BID" "BID , (?p == ?p) , true , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , IFF , ODDCHOICE , REFLEX , 0";
forcetheorem "BID2" "BID2 , (?p == true) , (|- ?p) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , IFF , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "LESS_MONO_ADD_EQ" "LESS_MONO_ADD_EQ , ((Nat : ?m) < Nat : ?n) , (((Nat : ?m) + Nat : ?p) < (Nat : ?n) + Nat : ?p) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "ADD_CANCEL" "ADD_CANCEL , ((?z + ?x) = ?z + ?y) , ((Real : ?x) = Real : ?y) , CASEINTRO , COMP_NAT , COMP_PLUS , EQUATION , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TYPES , 0";
forcetheorem "}LEQ_MONO_ADD_EQ" "LEQ_MONO_ADD_EQ , ((Nat : ?m) =< Nat : ?n) , (((Nat : ?m) + Nat : ?p) =< (Nat : ?n) + Nat : ?p) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "SUC_LESSF" "(SUC_LESSF @ ?x , ?y) , true , (((1 + Nat : ?x) < Nat : ?y) -> (Nat : ?x) < Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "}SUC_LESS" "SUC_LESS , true , (((1 + Nat : ?x) < Nat : ?y) -> (Nat : ?x) < Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "CDISD" "CDISD , (?p & ?q | ?r) , ((?p & ?q) | ?p & ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "AND" "AND , (?x & ?y) , (?x || (true = ?y) , false) , AND , 0";
forcetheorem "EQ_NOT_LESSF" "(EQ_NOT_LESSF @ ?x , ?y) , true , (((Nat : ?x) = Nat : ?y) -> ~ (Nat : ?x) < Nat : ?y) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "BCONV" "BCONV , (?e == ?f) , ((|- ?e) = |- ?f) , ASSERT , IFF , 0";
forcetheorem "3pt15b" "3pt15b , ((~ ?p) == ?p) , false , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IFF , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "AF" "AF , (|- false) , false , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "LESS_EQ_REAL" "LESS_EQ_REAL , (?x =< ?y) , (((Real : ?x) = Real : ?y) | ?x < ?y) , LESS_EQ_REAL , 0";
forcetheorem "LEQ_ANTISYM" "LEQ_ANTISYM , (~ ((Nat : ?m) < Nat : ?n) & (Nat : ?n) =< Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "NRULE1" "NRULE1 , (|- ~ ?p) , (~ ?p) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , REFLEX , TYPES , 0";
forcetheorem "LESS_CASESF" "(LESS_CASESF @ ?n , ?m) , true , (((Nat : ?n) < Nat : ?m) | ((Nat : ?n) = Nat : ?m) | (Nat : ?m) < Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "BOOLDEF" "BOOLDEF , (bool : ?x) , (true = ?x) , BOOLDEF , 0";
forcetheorem "CCON" "CCON , (?p & ~ ?p) , false , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "BOOLDEF0" "BOOLDEF0 , (bool : ?p) , (?p || true , false) , BOOLDEF , EQUATION , 0";
forcetheorem "NOT_SUC_LESS" "NOT_SUC_LESS , (~ (1 + Nat : ?m) < Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "PCASEINTRO" "(PCASEINTRO @ ?p) , ?x , (?p || ?x , ?x) , CASEINTRO , 0";
forcetheorem "3pt75" "3pt75 , (false -> ?p) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "IRULE1" "IRULE1 , (|- ?p -> ?q) , (?p -> ?q) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , TYPES , 0";
forcetheorem "SUCCNOTZERO" "SUCCNOTZERO , (0 = 1 + Nat : ?x) , false , SUCCNOTZERO , 0";
forcetheorem "NEGF" "NEGF , (~ false) , true , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "IRULE3" "IRULE3 , (?p -> |- ?q) , (?p -> ?q) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , TYPES , 0";
forcetheorem "FLESS_ADD_NZ" "FLESS_ADD_NZ , (forall @ [(~ (Nat : ?1) = 0) -> (Nat : ?m) < (Nat : ?m) + Nat : ?1]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , SUCCNOTZERO , TYPES , forall , forsome , 0";
forcetheorem "LESS_ADD_NZ" "LESS_ADD_NZ , ((~ (Nat : ?n) = 0) -> (Nat : ?m) < (Nat : ?m) + Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , SUCCNOTZERO , TYPES , forall , forsome , 0";
forcetheorem "LESS_ADD_NZF" "(LESS_ADD_NZF @ ?n , ?m) , true , ((~ (Nat : ?n) = 0) -> (Nat : ?m) < (Nat : ?m) + Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , SUCCNOTZERO , TYPES , forall , forsome , 0";
forcetheorem "}LESS_ADD_NZ" "LESS_ADD_NZ , true , ((~ (Nat : ?n) = 0) -> (Nat : ?m) < (Nat : ?m) + Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , SUCCNOTZERO , TYPES , forall , forsome , 0";
forcetheorem "FLEQ_ADD" "FLEQ_ADD , (forall @ [(Nat : ?m) =< (Nat : ?m) + Nat : ?1]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "ORBOOL" "ORBOOL , (?x | ?y) , (bool : ?x | ?y) , EQBOOL , FNDIST , NONTRIV , NOT1 , OR , REFLEX , 0";
forcetheorem "TOPDOWN" "(TOPDOWN @ ?thm) , ?x , (((TOPDOWN_CASE @ ?thm) =>> (TOPDOWN_INFIX @ ?thm) =>> (TOPDOWN_PREFIX @ ?thm) =>> ?thm) => ?x) , 0";
forcetheorem "TOPDOWN_CASE" "(TOPDOWN_CASE @ ?thm) , (?a || ?x , ?y) , ((BOTH_CASES @ TOPDOWN @ ?thm) => ?thm => ?a || ?x , ?y) , 0";
forcetheorem "TOPDOWN_INFIX" "(TOPDOWN_INFIX @ ?thm) , (?x ^+ ?y) , ((RL @ TOPDOWN @ ?thm) => ?thm => ?x ^+ ?y) , 0";
forcetheorem "TOPDOWN_PREFIX" "(TOPDOWN_PREFIX @ ?thm) , (^-- ?x) , ((RIGHT @ TOPDOWN @ ?thm) => ?thm => ^-- ?x) , 0";
forcetheorem "LESS_EQ_BOOL" "LESS_EQ_BOOL , (bool : ?x =< ?y) , (?x =< ?y) , EQBOOL , FNDIST , LESS_EQ_REAL , NONTRIV , NOT1 , OR , REFLEX , 0";
forcetheorem "LEQ_ADDF" "(LEQ_ADDF @ ?m , ?n) , true , ((Nat : ?m) =< (Nat : ?m) + Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LEQ_ADD" "LEQ_ADD , true , ((Nat : ?m) =< (Nat : ?m) + Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_OR" "LESS_OR , (((Nat : ?m) < Nat : ?n) -> (1 + Nat : ?m) =< Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_SUC_NOT" "LESS_SUC_NOT , (((Nat : ?m) < Nat : ?n) -> ~ (Nat : ?n) < 1 + Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "ANDUNPACK" "ANDUNPACK , ((?P & ?Q) || ?x , ?y) , (?P || (?Q || ?x , ?y) , ?y) , AND , CASEINTRO , 0";
forcetheorem "EQUATION" "EQUATION , (?a = ?b) , ((?a = ?b) || true , false) , EQUATION , 0";
forcetheorem "LEQ_MONO_ADD_EQF" "(LEQ_MONO_ADD_EQF @ ?p) , ((Nat : ?m) =< Nat : ?n) , (((Nat : ?m) + Nat : ?p) =< (Nat : ?n) + Nat : ?p) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LEQ_TRANS" "LEQ_TRANS , ((((Nat : ?m) =< Nat : ?n) & (Nat : ?n) =< Nat : ?p) -> (Nat : ?m) =< Nat : ?p) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "COMMDIST" "COMMDIST , ((?x + ?y) * ?z) , ((?x * ?z) + ?y * ?z) , DIST , TIMESCOMM , 0";
forcetheorem "TIMESID" "TIMESID , (1 * ?x) , (Real : ?x) , TIMESID , 0";
forcetheorem "TIMESCOMM" "TIMESCOMM , (?x * ?y) , (?y * ?x) , TIMESCOMM , 0";
forcetheorem "TIMESZERO" "TIMESZERO , (0 * ?x) , 0 , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TIMESCOMM , TIMESTYPE , TYPES , 0";
forcetheorem "LEQ_REFL" "LEQ_REFL , ((Nat : ?m) =< Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , TYPES , 0";
forcetheorem "3pt66" "3pt66 , (?p & ?p -> ?q) , (?p & ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "MULT_SUC" "MULT_SUC , ((Nat : ?x) * 1 + Nat : ?y) , ((Nat : ?x) + (Nat : ?x) * Nat : ?y) , COMP_NAT , COMP_PLUS , DIST , PLUSCOMM , PLUSTYPE , TIMESCOMM , TIMESID , TYPES , 0";
forcetheorem "LEQ_LEQ_MONO" "LEQ_LEQ_MONO , ((((Nat : ?m) =< Nat : ?p) & (Nat : ?n) =< Nat : ?q) -> ((Nat : ?m) + Nat : ?n) =< (Nat : ?p) + Nat : ?q) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "FLESS_MONO_MULT" "FLESS_MONO_MULT , (forall @ [((Nat : ?m) =< Nat : ?n) -> ((Nat : ?m) * Nat : ?1) =< (Nat : ?n) * Nat : ?1]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMPTIMESTYPE , COMP_NAT , COMP_PLUS , COMP_TIMES , DIST , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SAMESUCC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , forall , forsome , 0";
forcetheorem "IFBOOL" "IFBOOL , (?x -> ?y) , (bool : ?x -> ?y) , EQBOOL , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , 0";
forcetheorem "LESS_MONO_MULT" "LESS_MONO_MULT , (((Nat : ?m) =< Nat : ?n) -> ((Nat : ?m) * Nat : ?p) =< (Nat : ?n) * Nat : ?p) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMPTIMESTYPE , COMP_NAT , COMP_PLUS , COMP_TIMES , DIST , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SAMESUCC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , forall , forsome , 0";
forcetheorem "LESS_MONO_MULTF" "(LESS_MONO_MULTF @ ?m , ?n , ?p) , true , (((Nat : ?m) =< Nat : ?n) -> ((Nat : ?m) * Nat : ?p) =< (Nat : ?n) * Nat : ?p) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMPTIMESTYPE , COMP_NAT , COMP_PLUS , COMP_TIMES , DIST , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SAMESUCC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , forall , forsome , 0";
forcetheorem "}LESS_MONO_MULT" "LESS_MONO_MULT , true , (((Nat : ?m) =< Nat : ?n) -> ((Nat : ?m) * Nat : ?p) =< (Nat : ?n) * Nat : ?p) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMPTIMESTYPE , COMP_NAT , COMP_PLUS , COMP_TIMES , DIST , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SAMESUCC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , forall , forsome , 0";
forcetheorem "CRULE1" "CRULE1 , (|- ?p & ?q) , (?p & ?q) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , REFLEX , TYPES , 0";
forcetheorem "LESS_EQ_ANTISYM" "LESS_EQ_ANTISYM , ((((Nat : ?n) =< Nat : ?m) & (Nat : ?m) =< Nat : ?n) -> (Nat : ?n) = Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "INDUCT_TAC" "INDUCT_TAC , (forall @ [?P @ ?1]) , (INDUCT_TAC_2 => INDUCT_TAC_1 => forall @ [?P @ ?1]) , 0";
forcetheorem "INDUCT_TAC_1" "INDUCT_TAC_1 , (forall @ [?P @ ?1]) , (forall @ [(BIND @ Nat : ?1) => ?P @ ?1]) , 0";
forcetheorem "INDUCT_TAC_2" "INDUCT_TAC_2 , (forall @ [?P @ Nat : ?1]) , ((EVAL => ?P @ 0) & forall @ [(EVAL => ?P @ Nat : ?1) -> EVAL => ?P @ 1 + Nat : ?1]) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , NONTRIV , NOT1 , OR , PLUSTYPE , REFLEX , TYPES , 0";
forcetheorem "PLUSASSOC" "PLUSASSOC , ((?x + ?y) + ?z) , (?x + ?y + ?z) , PLUSASSOC , 0";
forcetheorem "LESS_MONO_EQ" "LESS_MONO_EQ , ((Nat : ?m) < Nat : ?n) , ((1 + Nat : ?m) < 1 + Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "FORALLDROP" "FORALLDROP , (forall @ [?x]) , (|- ?x) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , REFLEX , forall , 0";
forcetheorem "ElimForall" "(ElimForall @ ?thm , ?x) , true , (ASSERT2 <= CID => (LEFT @ EVAL) => (RIGHT @ ?thm) => (INSTANTIATEF @ ?x) => ?thm <= true) , 0";
forcetheorem "INSTANTIATEF" "(INSTANTIATEF @ ?x) , (forall @ [?P @ ?1]) , ((?P @ ?x) & forall @ [?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , NONTRIV , forall , 0";
forcetheorem "FLESS_ADD_SUC" "FLESS_ADD_SUC , (forall @ [(Nat : ?1) < (Nat : ?1) + 1 + Nat : ?n]) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "ASSERT2" "ASSERT2 , (bool : ?x) , (|- ?x) , ASSERT , 0";
forcetheorem "LESS_ADD_SUC" "LESS_ADD_SUC , ((Nat : ?m) < (Nat : ?m) + 1 + Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_ADD_SUCF" "(LESS_ADD_SUCF @ ?m , ?n) , true , ((Nat : ?m) < (Nat : ?m) + 1 + Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}LESS_ADD_SUC" "LESS_ADD_SUC , true , ((Nat : ?m) < (Nat : ?m) + 1 + Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "NOT_SUC_LEQ" "NOT_SUC_LEQ , (~ (1 + Nat : ?n) =< Nat : ?m) , ((Nat : ?m) =< Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESSBOOL2" "LESSBOOL2 , ((Nat : ?x) < Nat : ?y) , (|- (Nat : ?x) < Nat : ?y) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "ILID" "ILID , (true -> ?p) , (|- ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "LESS_SUC" "LESS_SUC , (((Nat : ?x) < Nat : ?y) -> (Nat : ?x) < 1 + Nat : ?y) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "LESS_SUC_REFL" "LESS_SUC_REFL , ((Nat : ?x) < 1 + Nat : ?x) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LEQ_IMP_LESS_SUC" "LEQ_IMP_LESS_SUC , (((Nat : ?n) =< Nat : ?m) -> (Nat : ?n) < 1 + Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_CASES" "LESS_CASES , (((Nat : ?n) < Nat : ?m) | ((Nat : ?n) = Nat : ?m) | (Nat : ?m) < Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "GREATER_OR_EQ" "GREATER_OR_EQ , ((Nat : ?x) >= Nat : ?y) , (((Nat : ?x) > Nat : ?y) | (Nat : ?x) = Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , GREATER_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , TYPES , 0";
forcetheorem "DIDEM" "DIDEM , (?p | ?p) , (|- ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "DASSOC" "DASSOC , ((?p | ?q) | ?r) , (?p | ?q | ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "LESS_LESS_CASES" "LESS_LESS_CASES , (((Nat : ?m) = Nat : ?n) | ((Nat : ?m) < Nat : ?n) | (Nat : ?n) < Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LEQ_CASES" "LEQ_CASES , (((Nat : ?m) =< Nat : ?n) | (Nat : ?n) =< Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "NOT_LESS_0" "NOT_LESS_0 , (~ (Nat : ?x) < 0) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "LESS_0_FALSE" "LESS_0_FALSE , ((Nat : ?n) < 0) , false , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "CONTP" "CONTP , (?p -> ?q) , ((~ ?q) -> ~ ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "LEQ_0" "LEQ_0 , ((Nat : ?n) =< 0) , ((Nat : ?n) = 0) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "TIMESTYPE2" "TIMESTYPE2 , ((Nat : ?x) * Nat : ?y) , (Nat : (Nat : ?x) * Nat : ?y) , COMPTIMESTYPE , COMP_TIMES , TYPES , 0";
forcetheorem "FACTORZERO" "FACTORZERO , (0 = ?y * ?z) , ((0 = Real : ?y) | 0 = Real : ?z) , AND , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQUATION , NONTRIV , NOT1 , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESTYPE , TYPES , 0";
forcetheorem "LESS_MULT2" "LESS_MULT2 , (((0 < Nat : ?m) & 0 < Nat : ?n) -> 0 < (Nat : ?m) * Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMPTIMESTYPE , COMP_NAT , COMP_PLUS , COMP_TIMES , DIST , DIVTYPE , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SAMESUCC , TD , TIMESASSOC , TIMESCOMM , TIMESTYPE , TYPES , forall , forsome , 0";
forcetheorem "LEQ_LESS_TRANS" "LEQ_LESS_TRANS , ((((Nat : ?m) =< Nat : ?n) & (Nat : ?n) < Nat : ?p) -> (Nat : ?m) < Nat : ?p) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "CSYM" "CSYM , (?p & ?q) , (?q & ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "3pt65" "3pt65 , (?p -> ?q -> ?r) , ((?p & ?q) -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "OR_EXP" "OR_EXP , ((?p | ?q) || ?a , ?b) , (?p || ?a , ?q || ?a , ?b) , AND , CASEINTRO , NOT1 , ODDCHOICE , OR , 0";
forcetheorem "ODDCHOICE" "ODDCHOICE , ?x , ?x , ODDCHOICE , 0";
forcetheorem "IRULE2" "IRULE2 , ((|- ?p) -> ?q) , (?p -> ?q) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , OR , REFLEX , TYPES , 0";
forcetheorem "LESS_TRANS" "LESS_TRANS , ((((Nat : ?m) < Nat : ?n) & (Nat : ?n) < Nat : ?p) -> (Nat : ?m) < Nat : ?p) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "IREF" "IREF , (?p -> ?p) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "LESS_LEQ_TRANS" "LESS_LEQ_TRANS , ((((Nat : ?m) < Nat : ?n) & (Nat : ?n) =< Nat : ?p) -> (Nat : ?m) < Nat : ?p) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "DDISC" "DDISC , (?p | ?q & ?r) , ((?p | ?q) & ?p | ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "DRULE3" "DRULE3 , (?p | |- ?q) , (?p | ?q) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , OR , REFLEX , TYPES , 0";
forcetheorem "LESS_ANTISYM" "LESS_ANTISYM , (~ ((Nat : ?m) < Nat : ?n) & (Nat : ?n) < Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "FDEF" "FDEF , false , (~ true) , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , 0";
forcetheorem "DID" "DID , (?p | false) , (|- ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "ASRTEQ" "ASRTEQ , (?e = ?f) , (|- ?e = ?f) , ASSERT , EQBOOL , 0";
forcetheorem "LEQ_MONO_ADD_EQ" "LEQ_MONO_ADD_EQ , (((Nat : ?m) + Nat : ?p) =< (Nat : ?n) + Nat : ?p) , ((Nat : ?m) =< Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "ADD_MONO_LEQ" "ADD_MONO_LEQ , (((Nat : ?m) + Nat : ?n) =< (Nat : ?m) + Nat : ?p) , ((Nat : ?n) =< Nat : ?p) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PM , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "NOT_LEQ" "NOT_LEQ , (~ (Nat : ?m) =< Nat : ?n) , ((Nat : ?n) < Nat : ?m) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "ZERONAT" "ZERONAT , 0 , (Nat : 0) , CASEINTRO , COMP_NAT , REFLEX , 0";
forcetheorem "ONENAT" "ONENAT , 1 , (Nat : 1) , CASEINTRO , COMP_NAT , REFLEX , 0";
forcetheorem "LESS_0" "LESS_0 , (0 < 1 + Nat : ?x) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "NOT_SUC_LEQ_0" "NOT_SUC_LEQ_0 , (~ (1 + Nat : ?n) =< 0) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "DUBNEG" "DUBNEG , (~ ~ ?p) , (bool : ?p) , BOOLDEF , CASEINTRO , EQUATION , NOT1 , 0";
forcetheorem "LESSBOOL" "LESSBOOL , ((Nat : ?x) < Nat : ?y) , (bool : (Nat : ?x) < Nat : ?y) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , LESS1 , NONTRIV , NOT1 , OR , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "RL" "(RL @ ?thm) , (?p ^+ ?q) , ((?thm => ?p) ^+ ?thm => ?q) , 0";
forcetheorem "DEMa" "DEMa , ((~ ?p) | ~ ?q) , (~ ?p & ?q) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "EQ_LEQ" "EQ_LEQ , (((Nat : ?m) =< Nat : ?n) & (Nat : ?n) =< Nat : ?m) , ((Nat : ?m) = Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "NOT_NUM_EQ" "NOT_NUM_EQ , (((1 + Nat : ?m) =< Nat : ?n) | (1 + Nat : ?n) =< Nat : ?m) , (~ (Nat : ?m) = Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "GREATER" "GREATER , (?x > ?y) , (?y < ?x) , GREATER , 0";
forcetheorem "NOT_GREATER" "NOT_GREATER , (~ (Nat : ?m) > Nat : ?n) , ((Nat : ?m) =< Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , GREATER , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "GREATER_EQ" "GREATER_EQ , ((Nat : ?n) >= Nat : ?m) , ((Nat : ?m) =< Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , GREATER , GREATER_EQ_REAL , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , TYPES , 0";
forcetheorem "NOT_LEQ_SUC" "NOT_LEQ_SUC , (~ (Nat : ?m) =< Nat : ?n) , ((1 + Nat : ?n) =< Nat : ?m) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "NOT_GREATER_EQ" "NOT_GREATER_EQ , (~ (Nat : ?m) >= Nat : ?n) , ((1 + Nat : ?m) =< Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , GREATER , GREATER_EQ_REAL , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "RIGHT2" "(RIGHT2 @ ?thm) , (^- ?x) , (^- ?thm => ?x) , 0";
forcetheorem "LESS_EQ" "LESS_EQ , ((1 + Nat : ?m) =< Nat : ?n) , ((Nat : ?m) < Nat : ?n) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "PLUSTYPE2" "PLUSTYPE2 , ((Nat : ?x) + Nat : ?y) , (Nat : (Nat : ?x) + Nat : ?y) , COMPPLUSTYPE , COMP_PLUS , TYPES , 0";
forcetheorem "LEQ_ADD" "LEQ_ADD , ((Nat : ?m) =< (Nat : ?m) + Nat : ?n) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "NOT_SUC_ADD_LEQ" "NOT_SUC_ADD_LEQ , (~ (1 + (Nat : ?m) + Nat : ?n) =< Nat : ?m) , true , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "MINUSCOMP" "MINUSCOMP , ((Nat : ?x) - Nat : ?y) , ((?x <! ?y) || (- ?y -! ?x) , ?x -! ?y) , ABSOLUTE , ABSOLUTE2 , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , LESS , LESS_COMP , MINUSTYPE , NATMINUSCOMP , NAT__SUB , NONTRIV , NOT1 , ODDCHOICE , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , REFLEX , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , 0";
forcetheorem "LESSCOMP" "LESSCOMP , ((Nat : ?x) < Nat : ?y) , (?x <! ?y) , LESS_COMP , 0";
forcetheorem "NATMINUSCOMP" "NATMINUSCOMP , ((Nat : ?x) .-. Nat : ?y) , (?x -! ?y) , NATMINUSCOMP , 0";
forcetheorem "FNDIST" "FNDIST , (?f @ ?x || ?y , ?z) , (?x || (?f @ ?y) , ?f @ ?z) , FNDIST , 0";
forcetheorem "TREMBOTH" "(TREMBOTH @ ?thm) , (?x ^+ ?y) , ((?thm *> (RIGHT @ (RIGHT @ TYPES) ** LEFT @ TYPES) ** $ ?thm) => ?x ^+ ?y) , 0";
forcetheorem "RIGHT_CASE" "(RIGHT_CASE @ ?thm) , (?x || ?y , ?z) , (?x || ?y , ?thm => ?z) , 0";
forcetheorem "TREMTOP" "(TREMTOP @ ?thm) , (?t : ?x) , (?thm <= TYPES => (RIGHT @ ?thm) => ?t : ?x) , 0";
forcetheorem "NATMINUSTYPE" "NATMINUSTYPE , (?x .-. ?y) , (Nat : (Nat : ?x) .-. Nat : ?y) , COMPMINUSTYPE , NATMINUSCOMP , NAT__SUB , TYPES , 0";
forcetheorem "NAT__SUB" "NAT__SUB , (?x .-. ?y) , (((Nat : ?x) < Nat : ?y) || 0 , (Nat : ?x) - Nat : ?y) , NAT__SUB , 0";
forcetheorem "EVERYWHERE" "(EVERYWHERE @ ?thm) , ?x , (((EVERYWHERE_CASE @ EVERYWHERE , ?thm) =>> (EVERYWHERE_INFIX @ EVERYWHERE , ?thm) =>> (EVERYWHERE_PREFIX @ EVERYWHERE , ?thm) =>> ?thm) => ?x) , 0";
forcetheorem "EVERYWHERE_CASE" "(EVERYWHERE_CASE @ ?EVERYWHERE , ?thm) , (?a || ?x , ?y) , (?thm => ?a || ((?EVERYWHERE @ ?thm) => ?x) , (?EVERYWHERE @ ?thm) => ?y) , 0";
forcetheorem "EVERYWHERE_INFIX" "(EVERYWHERE_INFIX @ ?EVERYWHERE , ?thm) , (?x ^+ ?y) , (?thm => ((?EVERYWHERE @ ?thm) => ?x) ^+ (?EVERYWHERE @ ?thm) => ?y) , 0";
forcetheorem "EVERYWHERE_PREFIX" "(EVERYWHERE_PREFIX @ ?EVERYWHERE , ?thm) , (^-- ?x) , (?thm => ^-- (?EVERYWHERE @ ?thm) => ?x) , 0";
forcetheorem "TAB_IF" "TAB_IF , (?p -> ?q) , (?p || (?q || true , false) , true) , AND , CASEINTRO , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , 0";
forcetheorem "TYPES" "TYPES , (?t : ?t : ?x) , (?t : ?x) , TYPES , 0";
forcetheorem "REALSUBNATTYPE" "REALSUBNATTYPE , (Nat : (Nat : ?m) - Nat : ?n) , (((Nat : ?m) < Nat : ?n) || (Nat : - (Nat : ?n) - Nat : ?m) , (Nat : ?m) - Nat : ?n) , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMPMINUSTYPE , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , IF , INDUCTION , LESS , LESS1 , LESS_COMP , MINUSTYPE , NATMINUSCOMP , NAT__SUB , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , REFLEX , SAMESUCC , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , forall , forsome , 0";
forcetheorem "NOT_EXP" "NOT_EXP , ((~ ?p) || ?a , ?b) , (?p || ?b , ?a) , CASEINTRO , NOT1 , ODDCHOICE , 0";
forcetheorem "LEFT2" "(LEFT2 @ ?thm) , (?x || ?y , ?z) , ((?thm => ?x) || ?y , ?z) , 0";
forcetheorem "TAB_OR_2" "TAB_OR_2 , ((?p | ?q) || ?a , ?b) , (?p || ?a , ?q || ?a , ?b) , AND , CASEINTRO , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , 0";
forcetheorem "PLUSSCIN" "PLUSSCIN , (?x + ?y) , ((Real : ?x) + Real : ?y) , PLUSTYPE , TYPES , 0";
forcetheorem "PLUSMINUS" "PLUSMINUS , ((?x - ?y) + ?y) , (Real : ?x) , PLUSCOMM , PM , 0";
forcetheorem "IRZER" "IRZER , (?p -> true) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "LESS_ADD1" "LESS_ADD1 , (((Nat : ?n) < Nat : ?m) -> forsome @ [(Nat : ?m) = (Nat : ?n) + ?1 + 1]) , true , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , PM , REFLEX , TYPES , forall , forsome , 0";
forcetheorem "DRULE2" "DRULE2 , ((|- ?p) | ?q) , (?p | ?q) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , OR , REFLEX , TYPES , 0";
forcetheorem "DUBNEG2" "DUBNEG2 , (~ ~ ?p) , (|- ?p) , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "IF" "IF , (?x -> ?y) , ((~ ?x) | ?y) , IF , 0";
forcetheorem "NOT_LESS" "NOT_LESS , (~ (Nat : ?m) < Nat : ?n) , ((Nat : ?n) =< Nat : ?m) , AND , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "LESS_OR_ADD" "LESS_OR_ADD , (((Nat : ?n) < Nat : ?m) | forsome @ [(Nat : ?n) = ?1 + Nat : ?m]) , (|- ((Nat : ?m) < Nat : ?n) -> forsome @ [(?1 + Nat : ?m) = Nat : ?n]) , AND , ASSERT , BOOLDEF , CASEINTRO , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , INDUCTION , LESS1 , LESS_COMP , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , SAMESUCC , TYPES , forall , forsome , 0";
forcetheorem "}backup" "backup , (((Nat : ?n) < Nat : ?m) | forsome @ [(Nat : ?n) = ?1 + Nat : ?m]) , (|- ((Nat : ?m) < Nat : ?n) -> forsome @ [(?1 + Nat : ?m) = Nat : ?n]) , PLUSTYPE , TYPES , EQBOOL , AND , ASSERT , BOOLDEF , CASEINTRO , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , NOT1 , OR , COMP_NAT , COMP_PLUS , PLUSCOMM , PLUSID , forall , forsome , IF , LESS_EQ_REAL , COMPPLUSTYPE , INDUCTION , LESS1 , LESS_COMP , SAMESUCC , 0";
forcetheorem "LEFT" "(LEFT @ ?thm) , ?x , (((LEFT1 @ ?thm) =>> LEFT2 @ ?thm) => ?x) , 0";
forcetheorem "LEFT1" "(LEFT1 @ ?thm) , (?p ^+ ?q) , ((?thm => ?p) ^+ ?q) , 0";
forcetheorem "LESS_OR_EQ" "LESS_OR_EQ , ((Nat : ?x) =< Nat : ?y) , (((Nat : ?x) < Nat : ?y) | (Nat : ?x) = Nat : ?y) , AND , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSTYPE , REFLEX , TYPES , 0";
forcetheorem "3pt78" "3pt78 , ((?p -> ?r) & ?q -> ?r) , ((?p | ?q) -> ?r) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "EQSYMM" "EQSYMM , (?x = ?y) , (?y = ?x) , CASEINTRO , EQUATION , REFLEX , 0";
forcetheorem "LESS_ADD" "LESS_ADD , (((Nat : ?n) < Nat : ?m) -> forsome @ [((Nat : ?1) + Nat : ?n) = Nat : ?m]) , true , ABSOLUTE , ABSOLUTE2 , AND , BOOLDEF , CASEINTRO , COMPMINUSTYPE , COMPPLUSTYPE , COMP_NAT , COMP_PLUS , DIST , DIVTYPE , EQBOOL , EQUATION , EQ_COMP , FNDIST , IF , INDUCTION , LESS , LESS1 , LESS_COMP , MINUSTYPE , NATMINUSCOMP , NAT__SUB , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSASSOC , PLUSCOMM , PLUSID , PLUSTYPE , PLUS_POS , PM , REFLEX , SAMESUCC , TD , TIMESASSOC , TIMESCOMM , TIMESID , TIMESTYPE , TYPES , forall , forsome , 0";
forcetheorem "IMPTOCOND" "IMPTOCOND , (?a -> ?b) , (|- ?a || ?b , true) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , IF , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "DINSTANTIATEF1" "(DINSTANTIATEF1 @ ?x) , (forsome @ ?P) , ((?P @ ?x) | forsome @ [?P @ ?1]) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , OR , REFLEX , forall , forsome , 0";
forcetheorem "PLUSCOMM" "PLUSCOMM , (?x + ?y) , (?y + ?x) , PLUSCOMM , 0";
forcetheorem "PLUSID" "PLUSID , (0 + ?x) , (Real : ?x) , PLUSID , 0";
forcetheorem "$" "($ ?thm) , ?x , (?thm <= ?x) , 0";
forcetheorem "REALNAT" "REALNAT , (Nat : ?x) , (Real : Nat : ?x) , COMP_NAT , COMP_PLUS , PLUSCOMM , PLUSTYPE , TYPES , 0";
forcetheorem "RIGHT" "(RIGHT @ ?thm) , ?x , (((RIGHT1 @ ?thm) =>> RIGHT2 @ ?thm) => ?x) , 0";
forcetheorem "RIGHT1" "(RIGHT1 @ ?thm) , (?p ^+ ?q) , (?p ^+ ?thm => ?q) , 0";
forcetheorem "REFLEX" "REFLEX , (?a = ?a) , true , REFLEX , 0";
forcetheorem "DSYM" "DSYM , (?p | ?q) , (?q | ?p) , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "DZER" "DZER , (?p | true) , true , AND , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , NOT1 , ODDCHOICE , OR , REFLEX , TYPES , 0";
forcetheorem "CASEINTRO" "CASEINTRO , ?x , (?y || ?x , ?x) , CASEINTRO , 0";
forcetheorem "**" "(?thm1 ** ?thm2) , ?x , (?thm2 => ?thm1 => ?x) , 0";
forcetheorem "CID" "CID , (?p & true) , (|- ?p) , AND , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "AT" "AT , (|- true) , true , ASSERT , BOOLDEF , CASEINTRO , EQBOOL , EQUATION , FNDIST , NONTRIV , ODDCHOICE , REFLEX , TYPES , 0";
forcetheorem "LESS_EQ_ADD" "LESS_EQ_ADD , (((Nat : ?m) =< Nat : ?n) -> forsome @ [(Nat : ?n) = (Nat : ?m) + ?1]) , (|- ((Nat : ?m) < Nat : ?n) -> forsome @ [(?1 + Nat : ?m) = Nat : ?n]) , AND , ASSERT , BOOLDEF , CASEINTRO , COMP_NAT , COMP_PLUS , EQBOOL , EQUATION , FNDIST , IF , LESS_EQ_REAL , NONTRIV , NOT1 , ODDCHOICE , OR , PLUSCOMM , PLUSID , PLUSTYPE , REFLEX , TYPES , forall , forsome , 0";
adddef "NATLESS" ".<.";
adddef "NATPLUS" ".+.";
adddef "NOT_EQ" "~=";
adddef "GREATER_EQ_REAL" ">=";
adddef "LESS_EQ_REAL" "=<";
adddef "GREATER" ">";
adddef "Positive" "Positive";
adddef "Pred" "Pred";
adddef "NAT__SUB" ".-.";
adddef "odd" "odd";
adddef "even" "even";
adddef "MOD_DEF" "%";
adddef "INT_DIV" "./.";
adddef "LESS" "<";
adddef "True" "True";
adddef "Bool" "Bool";
adddef "UNIONTYPE" "<+>";
adddef "PRODTYPE" "<*>";
adddef "ARROWTYPE" "->>";
adddef "Disjoint" "|||";
adddef "Psubset" "||=";
adddef "Complement" "^";
adddef "Subset" "|=";
adddef "SetDifference" "--";
adddef "Intersection" "&&";
adddef "Union" "++";
adddef "SetEquiv" "===";
adddef "Set" "Set";
adddef "IN" "<<";
adddef "forsomer" "forsomer";
adddef "forallr" "forallr";
adddef "COUNTER1" "***";
adddef "CONVIF" "<-";
adddef "XOR" "=/=";
adddef "ASSERT" "|-";
adddef "IFF" "==";
adddef "IF" "->";
adddef "OR" "|";
adddef "AND" "&";
adddef "forsome" "forsome";
adddef "NOT1" "~";
adddef "forall" "forall";
adddef "upfun" "upfun";
adddef "IGNOREFIRST" ".";
adddef "Id" "Id";
adddef "P2" "P2";
adddef "P1" "P1";
adddef "COMP" "@@";
addscript "natorder";
addscript "algebra2";
addscript "typestuff";
addscript "simplesets";
addscript "sequent";
addscript "new.quantifiers";
addscript "gries9";
addscript "tableau2";
addscript "logic_tools";
addscript "logicdefs2";
addscript "tableau";
addscript "logicdefs";
addscript "lambda";
addscript "structural";
adddefdep2 "LESS_EQ_ADD" "ASSERT , NOT1 , AND , OR , IF , LESS , forall , forsome , LESS_EQ_REAL , 0";
adddefdep2 "LESS_OR_ADD" "ASSERT , NOT1 , AND , OR , IF , LESS , forall , forsome , 0";
adddefdep2 "LESS_ADD1" "NOT1 , AND , OR , IF , LESS , forall , forsome , 0";
adddefdep2 "LESS_ADD" "NOT1 , AND , OR , IF , LESS , forall , forsome , 0";
adddefdep2 "REALSUBNATTYPE" "NOT1 , LESS , 0";
adddefdep2 "NOT_SUC_ADD_LEQ" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "NOT_GREATER_EQ" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , GREATER , GREATER_EQ_REAL , 0";
adddefdep2 "NOT_GREATER" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , GREATER , 0";
adddefdep2 "NOT_NUM_EQ" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "NOT_LEQ_SUC" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "NOT_SUC_LEQ_0" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "ADD_MONO_LEQ" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "EQ_LEQ" "AND , NOT1 , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_LEQ_TRANS" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LEQ_LESS_TRANS" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_MULT2" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_0_FALSE" "NOT1 , LESS , 0";
adddefdep2 "NOT_LEQ" "NOT1 , LESS , AND , OR , LESS_EQ_REAL , 0";
adddefdep2 "LEQ_CASES" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "GREATER_EQ" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , GREATER , GREATER_EQ_REAL , 0";
adddefdep2 "LESS_LESS_CASES" "NOT1 , AND , OR , LESS , 0";
adddefdep2 "LEQ_IMP_LESS_SUC" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "NOT_SUC_LEQ" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_ADD_SUCF" "NOT1 , LESS , 0";
adddefdep2 "LESS_ADD_SUC" "NOT1 , LESS , 0";
adddefdep2 "FLESS_ADD_SUC" "forall , NOT1 , LESS , 0";
adddefdep2 "LESS_EQ_ANTISYM" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_MONO_MULTF" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_MONO_MULT" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "FLESS_MONO_MULT" "forall , NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "MULT_SUC" "0";
adddefdep2 "LEQ_LEQ_MONO" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LEQ_TRANS" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_SUC_NOT" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LEQ_ADDF" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LEQ_ADD" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "FLEQ_ADD" "forall , NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_ADD_NZF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_ADD_NZ" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "FLESS_ADD_NZ" "forall , NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "NOT_SUC_LESS" "NOT1 , LESS , 0";
adddefdep2 "NOT_LESS" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_EQ_BOOL" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LEQ_ANTISYM" "NOT1 , AND , LESS , OR , LESS_EQ_REAL , 0";
adddefdep2 "SUC_LESSF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LEQ_MONO_ADD_EQF" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LEQ_MONO_ADD_EQ" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_MONO_ADD_EQ" "NOT1 , LESS , 0";
adddefdep2 "LESS_MONO_ADD_INVF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_MONO_ADD_INV" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "FORALL_LESS_MONO_ADD_INVF" "forall , NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "FORALL_LESS_MONO_ADD_INV" "forall , NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_MONO_ADDF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_MONO_ADD" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "FORALL_LESS_MONO_ADDF" "forall , NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "FORALL_LESS_MONO_ADD" "forall , NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "BOUNDED_N" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_LESS_SUC" "NOT1 , AND , LESS , 0";
adddefdep2 "LESS_ANTISYMF" "NOT1 , AND , LESS , 0";
adddefdep2 "LESS_ANTISYM" "NOT1 , AND , LESS , 0";
adddefdep2 "FORALL_LESS_ANTISYM" "forall , NOT1 , AND , LESS , 0";
adddefdep2 "LESS_TRANSF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_TRANS" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "FORALL_LESS_TRANS" "forall , NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_IMP_LEQ" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LEQ_REFL" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "NOT_ADD_LESSF" "forall , NOT1 , LESS , 0";
adddefdep2 "NOT_ADD_LESS" "forall , NOT1 , LESS , 0";
adddefdep2 "LESS_NOT_SUC" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_SUC_EQ_COR" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_EQ_MONO" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "ALL_GEQ_0" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LEQ_SUC_REFL" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_EQ" "NOT1 , LESS , AND , OR , LESS_EQ_REAL , 0";
adddefdep2 "OR_LESS" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_OR" "NOT1 , AND , OR , IF , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_CASES_IMP" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_CASESF" "NOT1 , AND , OR , LESS , 0";
adddefdep2 "LESS_CASES" "NOT1 , AND , OR , LESS , 0";
adddefdep2 "FORALL_LESS_CASES" "forall , NOT1 , AND , OR , LESS , 0";
adddefdep2 "LESS_0_CASES_INV" "NOT1 , AND , OR , LESS , 0";
adddefdep2 "LESS_0_CASES" "NOT1 , AND , OR , LESS , 0";
adddefdep2 "LESS_EQ_SUC_LESS" "NOT1 , LESS , AND , OR , 0";
adddefdep2 "LESS_MONO_EQ" "NOT1 , LESS , 0";
adddefdep2 "LESS_MONO_REVF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_MONO_REV" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LEQ_SUC" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "LESS_SUC_SUCF" "NOT1 , LESS , 0";
adddefdep2 "LESS_SUC_SUC" "NOT1 , LESS , 0";
adddefdep2 "LESS_NOT_EQF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_NOT_EQ" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "EQ_NOT_LESSF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "EQ_NOT_LESS" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "SUC_EQ_LESSF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "SUC_EQ_LESS" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_0F" "NOT1 , LESS , 0";
adddefdep2 "LESS_0" "NOT1 , LESS , 0";
adddefdep2 "FORALL_LESS_0" "forall , NOT1 , LESS , 0";
adddefdep2 "LESS_SUC_IMPF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_SUC_IMP" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_THM" "NOT1 , AND , OR , LESS , 0";
adddefdep2 "LESS_LEMMA1F" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_LEMMA1" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_LEMMA2F" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_LEMMA2" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_SUC_REFLF" "NOT1 , LESS , 0";
adddefdep2 "LESS_SUC_REFL" "NOT1 , LESS , 0";
adddefdep2 "FORALL_LESS_SUC_REFL" "forall , NOT1 , LESS , 0";
adddefdep2 "LESS_SUCF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_SUC" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_MONOF" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "LESS_MONO" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "SUC_IDF" "0";
adddefdep2 "SUC_ID" "0";
adddefdep2 "SUB_REFL" "0";
adddefdep2 "LESS_0_0" "NOT1 , LESS , 0";
adddefdep2 "LEQ_0" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "NOT_LESS_0F" "NOT1 , LESS , 0";
adddefdep2 "NOT_LESS_0" "NOT1 , LESS , 0";
adddefdep2 "FNOT_LESS_0" "forall , NOT1 , LESS , 0";
adddefdep2 "ElimForall" "0";
adddefdep2 "INSTANTIATEF" "AND , forall , 0";
adddefdep2 "SUC_LESS" "NOT1 , AND , OR , IF , LESS , 0";
adddefdep2 "MP_THMF" "NOT1 , AND , OR , IF , forall , 0";
adddefdep2 "MP_THM" "NOT1 , AND , OR , IF , forall , 0";
adddefdep2 "LESS_NOT_REFL" "NOT1 , LESS , 0";
adddefdep2 "LESSBOOL2" "ASSERT , NOT1 , LESS , 0";
adddefdep2 "LESSBOOL" "NOT1 , LESS , 0";
adddefdep2 "NATLESS2" "NOT1 , LESS , NAT__SUB , NATLESS , 0";
adddefdep2 "NOT_LESS_THAN_SELF" "NOT1 , LESS , 0";
adddefdep2 "NATLESSSCIN" "NOT1 , LESS , NAT__SUB , NATLESS , 0";
adddefdep2 "MINUSSUCC_NAT" "NOT1 , LESS , NAT__SUB , NATPLUS , 0";
adddefdep2 "INDUCTION_NAT" "AND , forall , NOT1 , OR , IF , NATPLUS , 0";
adddefdep2 "PLUSSCIN_NAT" "NATPLUS , 0";
adddefdep2 "ZEROMINUS_NAT" "NOT1 , LESS , NAT__SUB , 0";
adddefdep2 "PLUSTYPE_NAT" "NATPLUS , 0";
adddefdep2 "PLUSSUCC_NAT" "NATPLUS , 0";
adddefdep2 "PLUSMINUS_NAT" "NOT1 , LESS , NAT__SUB , NATPLUS , 0";
adddefdep2 "MINUSZERO_NAT" "NOT1 , LESS , NAT__SUB , 0";
adddefdep2 "NATSNONNEG" "NOT1 , LESS , 0";
adddefdep2 "MINUSZERO2" "0";
adddefdep2 "NOT_LEMMA" "NOT1 , ASSERT , 0";
adddefdep2 "ABSOLUTE_ONE" "0";
adddefdep2 "ABSOLUTE_ZERO" "0";
adddefdep2 "PLUSID_NAT" "NATPLUS , 0";
adddefdep2 "SUCCNOTZERO_NAT" "NATPLUS , 0";
adddefdep2 "NATLESS" "NOT1 , LESS , NAT__SUB , NATLESS , 0";
adddefdep2 "NATPLUS" "NATPLUS , 0";
adddefdep2 "MINUSCOMP" "0";
adddefdep2 "LESS_OR_EQ" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "GREATER_OR_EQ" "NOT1 , AND , OR , LESS , GREATER , GREATER_EQ_REAL , 0";
adddefdep2 "REAL_NOT_LESS" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "DIFF_EQ" "0";
adddefdep2 "POS_SIGN" "AND , NOT1 , NOT_EQ , Positive , 0";
adddefdep2 "REAL_LESS_CANCEL" "NOT1 , LESS , 0";
adddefdep2 "REAL_LESS_TRANS" "AND , NOT1 , LESS , 0";
adddefdep2 "EQUATION_TO_DIFFERENCE" "0";
adddefdep2 "X" "0";
adddefdep2 "X2" "0";
adddefdep2 "X1" "0";
adddefdep2 "REAL_UNTYPE" "0";
adddefdep2 "REAL_UNTYPE_1" "0";
adddefdep2 "REAL_TYPE" "0";
adddefdep2 "REAL_TYPE_1" "0";
adddefdep2 "ALL_CANCEL" "0";
adddefdep2 "ALL_CANCEL_7" "0";
adddefdep2 "ALL_CANCEL_6" "0";
adddefdep2 "ALL_CANCEL_5" "0";
adddefdep2 "ALL_CANCEL_4" "0";
adddefdep2 "ALL_CANCEL_3" "0";
adddefdep2 "ALL_CANCEL_2" "0";
adddefdep2 "ALL_CANCEL_1" "0";
adddefdep2 "FIXBREAKMINUS" "0";
adddefdep2 "GETPLUS" "0";
adddefdep2 "ZEROORSUCC" "forall , NOT1 , AND , OR , forsome , 0";
adddefdep2 "POS_ZERO" "AND , NOT1 , Positive , 0";
adddefdep2 "POS_ONE" "AND , NOT1 , Positive , 0";
adddefdep2 "SQUARE_POS" "NOT1 , AND , OR , Positive , 0";
adddefdep2 "NOTBOTHPOS" "AND , NOT1 , Positive , 0";
adddefdep2 "ZERONOTPOS" "AND , NOT1 , Positive , 0";
adddefdep2 "POSASSERT" "ASSERT , AND , NOT1 , Positive , 0";
adddefdep2 "ALT_POS_DEF" "NOT1 , LESS , AND , Positive , 0";
adddefdep2 "NOT_EQ" "NOT1 , NOT_EQ , 0";
adddefdep2 "GREATER_EQ_REAL" "NOT1 , AND , OR , LESS , GREATER , GREATER_EQ_REAL , 0";
adddefdep2 "LESS_EQ_REAL" "NOT1 , AND , OR , LESS , LESS_EQ_REAL , 0";
adddefdep2 "GREATER" "NOT1 , LESS , GREATER , 0";
adddefdep2 "REAL_LESS_DEF" "AND , NOT1 , Positive , LESS , 0";
adddefdep2 "DISTANCEFLIP" "0";
adddefdep2 "MINUSFLIP" "0";
adddefdep2 "TRICHOTOMY" "NOT1 , AND , OR , Positive , 0";
adddefdep2 "POSTIMES" "AND , NOT1 , Positive , 0";
adddefdep2 "POSPLUS" "AND , NOT1 , Positive , 0";
adddefdep2 "POSTYPE" "AND , NOT1 , Positive , 0";
adddefdep2 "REALABS" "0";
adddefdep2 "ABSREAL" "0";
adddefdep2 "Positive" "AND , NOT1 , Positive , 0";
adddefdep2 "ZEROSELFINV" "0";
adddefdep2 "SUBTRACT_DIFF" "0";
adddefdep2 "MINUSZERO" "0";
adddefdep2 "MINUSMINUS" "0";
adddefdep2 "PLUSINVDISTS" "0";
adddefdep2 "PLUSINVDIST" "0";
adddefdep2 "SUBTRACT_SUM" "0";
adddefdep2 "ADD_CANCEL" "0";
adddefdep2 "MINUSPLUS" "0";
adddefdep2 "BREAKMINUS" "0";
adddefdep2 "SIGNPULL" "0";
adddefdep2 "PREDTYPE" "NOT1 , LESS , NAT__SUB , Pred , 0";
adddefdep2 "PREDSCIN" "NOT1 , LESS , NAT__SUB , Pred , 0";
adddefdep2 "Pred" "NOT1 , LESS , NAT__SUB , Pred , 0";
adddefdep2 "NATMINUSSCIN" "NOT1 , LESS , NAT__SUB , 0";
adddefdep2 "NAT_SUB" "NOT1 , LESS , NAT__SUB , 0";
adddefdep2 "NATMINUSTYPE" "NOT1 , LESS , NAT__SUB , 0";
adddefdep2 "NATMINUSCOMP" "NOT1 , LESS , NAT__SUB , 0";
adddefdep2 "NAT__SUB" "NOT1 , LESS , NAT__SUB , 0";
adddefdep2 "LESS1" "NOT1 , forall , forsome , AND , OR , IF , LESS , 0";
adddefdep2 "FINDGCD" "0";
adddefdep2 "REALNUMERAL2" "0";
adddefdep2 "REALNUMERAL" "0";
adddefdep2 "TYPENUMERAL" "0";
adddefdep2 "GCD" "MOD_DEF , 0";
adddefdep2 "EQEVAL2" "0";
adddefdep2 "GCDTYPE" "0";
adddefdep2 "GCD2" "MOD_DEF , 0";
adddefdep2 "GCD1" "0";
adddefdep2 "odd" "NOT1 , forall , forsome , odd , 0";
adddefdep2 "even" "NOT1 , forall , forsome , even , 0";
adddefdep2 "INDUCT_TAC" "forall , 0";
adddefdep2 "INDUCT_TAC_2" "AND , forall , NOT1 , OR , IF , 0";
adddefdep2 "INDUCT_TAC_1" "forall , 0";
adddefdep2 "INDUCTION" "AND , forall , NOT1 , OR , IF , 0";
adddefdep2 "SAMESUCC" "0";
adddefdep2 "SUCCNOTZERO" "0";
adddefdep2 "FACTORZERO" "NOT1 , AND , OR , 0";
adddefdep2 "TIMESZERO" "0";
adddefdep2 "COMMDIST" "0";
adddefdep2 "EPLUSID" "0";
adddefdep2 "COMMPLUSID" "0";
adddefdep2 "REALZERO" "0";
adddefdep2 "TIMESINTDIV" "MOD_DEF , INT_DIV , 0";
adddefdep2 "NATCALC" "0";
adddefdep2 "DIVSCIN" "0";
adddefdep2 "ZERONOTONE" "0";
adddefdep2 "EVALEQ" "0";
adddefdep2 "LESSTYPE" "NOT1 , LESS , 0";
adddefdep2 "MODSCIN" "MOD_DEF , 0";
adddefdep2 "MODTYPE" "MOD_DEF , 0";
adddefdep2 "MODCOMP" "MOD_DEF , 0";
adddefdep2 "MOD_DEF" "MOD_DEF , 0";
adddefdep2 "INT_DIVSCIN" "INT_DIV , 0";
adddefdep2 "INT_DIVTYPE" "INT_DIV , 0";
adddefdep2 "INT_DIV" "INT_DIV , 0";
adddefdep2 "TIMESSCIN" "0";
adddefdep2 "TIMESCOMP" "0";
adddefdep2 "TIMESTYPE2" "0";
adddefdep2 "REALNAT" "0";
adddefdep2 "MINUSSCIN" "0";
adddefdep2 "PLUSSCIN" "0";
adddefdep2 "PLUSCOMP" "0";
adddefdep2 "PLUSTYPE2" "0";
adddefdep2 "ZERONAT" "0";
adddefdep2 "ONENAT" "0";
adddefdep2 "BUILTIN" "0";
adddefdep2 "EQ_COMP" "0";
adddefdep2 "LESSCOMP" "NOT1 , LESS , 0";
adddefdep2 "LESS_COMP" "NOT1 , LESS , 0";
adddefdep2 "LESS" "NOT1 , LESS , 0";
adddefdep2 "ABSOLUTE2" "0";
adddefdep2 "ABSOLUTE" "0";
adddefdep2 "TIMES_POS" "0";
adddefdep2 "PLUS_POS" "0";
adddefdep2 "DIST" "0";
adddefdep2 "TIMESDIV" "0";
adddefdep2 "TD" "0";
adddefdep2 "TIMESID" "0";
adddefdep2 "TIMESASSOC" "0";
adddefdep2 "TIMESCOMM" "0";
adddefdep2 "DIVTYPE" "0";
adddefdep2 "TIMESTYPE" "0";
adddefdep2 "PLUSMINUS" "0";
adddefdep2 "PM" "0";
adddefdep2 "PLUSID" "0";
adddefdep2 "PLUSASSOC" "0";
adddefdep2 "PLUSCOMM" "0";
adddefdep2 "MINUSTYPE" "0";
adddefdep2 "PLUSTYPE" "0";
adddefdep2 "COMP_DIV" "0";
adddefdep2 "COMP_TIMES" "0";
adddefdep2 "COMP_MINUS" "0";
adddefdep2 "COMP_PLUS" "0";
adddefdep2 "COMPLESSTYPE" "Bool , 0";
adddefdep2 "COMPEQTYPE" "Bool , 0";
adddefdep2 "COMPMODTYPE" "0";
adddefdep2 "COMPDIVTYPE" "0";
adddefdep2 "COMPTIMESTYPE" "0";
adddefdep2 "COMPMINUSTYPE" "0";
adddefdep2 "COMPPLUSTYPE" "0";
adddefdep2 "MAKE_NAT" "0";
adddefdep2 "MAKE_NAT_2" "0";
adddefdep2 "MAKE_NAT_1" "0";
adddefdep2 "COMP_NAT_2" "0";
adddefdep2 "COMP_NAT" "0";
adddefdep2 "True" "True , 0";
adddefdep2 "TRUERETRACT" "0";
adddefdep2 "Bool" "Bool , 0";
adddefdep2 "BOOL_RETRACT" "0";
adddefdep2 "POINTTYPE" "0";
adddefdep2 "UNIONTYPE" "UNIONTYPE , 0";
adddefdep2 "UNIONRETRACT" "0";
adddefdep2 "PRODTYPE" "P1 , P2 , PRODTYPE , 0";
adddefdep2 "PRODRETRACT" "P1 , P2 , 0";
adddefdep2 "ARROWTYPE" "ARROWTYPE , 0";
adddefdep2 "ARROWRETRACT" "0";
adddefdep2 "TADDTOP" "0";
adddefdep2 "TADDBOTH" "0";
adddefdep2 "TADDRIGHT" "0";
adddefdep2 "TADDLEFT" "0";
adddefdep2 "TREMTOP" "0";
adddefdep2 "TREMBOTH" "0";
adddefdep2 "TREMRIGHT" "0";
adddefdep2 "TREMLEFT" "0";
adddefdep2 "Complement2" "NOT1 , ASSERT , IN , Complement , 0";
adddefdep2 "Subset2" "forall , NOT1 , AND , OR , IF , ASSERT , IN , Subset , 0";
adddefdep2 "SetDifference2" "AND , NOT1 , ASSERT , IN , SetDifference , 0";
adddefdep2 "Intersection2" "AND , ASSERT , IN , Intersection , 0";
adddefdep2 "Union2" "NOT1 , AND , OR , ASSERT , IN , Union , 0";
adddefdep2 "SetEquiv2" "forall , IFF , ASSERT , IN , SetEquiv , 0";
adddefdep2 "DiffSymmDisj" "forall , IFF , ASSERT , IN , SetEquiv , AND , Intersection , Disjoint , NOT1 , SetDifference , 0";
adddefdep2 "UnionDisj" "AND , forall , IFF , ASSERT , IN , SetEquiv , Intersection , Disjoint , NOT1 , OR , Union , 0";
adddefdep2 "Disj_NotForsome" "NOT1 , forall , forsome , AND , ASSERT , IN , IFF , SetEquiv , Intersection , Disjoint , 0";
adddefdep2 "DisjIdem" "forall , IFF , ASSERT , IN , SetEquiv , AND , Intersection , Disjoint , 0";
adddefdep2 "DisjEmpty" "forall , IFF , ASSERT , IN , SetEquiv , AND , Intersection , Disjoint , 0";
adddefdep2 "EmptyDisj" "forall , IFF , ASSERT , IN , SetEquiv , AND , Intersection , Disjoint , 0";
adddefdep2 "DisjUniv" "forall , IFF , ASSERT , IN , SetEquiv , AND , Intersection , Disjoint , 0";
adddefdep2 "UnivDisj" "forall , IFF , ASSERT , IN , SetEquiv , AND , Intersection , Disjoint , 0";
adddefdep2 "DisjSymm" "forall , IFF , ASSERT , IN , SetEquiv , AND , Intersection , Disjoint , 0";
adddefdep2 "DisjScin" "forall , IFF , ASSERT , IN , SetEquiv , AND , Intersection , Disjoint , Set , 0";
adddefdep2 "DisjType" "ASSERT , Set , forall , IFF , IN , SetEquiv , AND , Intersection , Disjoint , 0";
adddefdep2 "SubsetNotPsubset" "NOT1 , AND , OR , IF , forall , ASSERT , IN , Subset , IFF , SetEquiv , Psubset , 0";
adddefdep2 "PsubsetNotSubset" "NOT1 , AND , OR , IF , forall , ASSERT , IN , Subset , IFF , SetEquiv , Psubset , 0";
adddefdep2 "PsubsetSubset" "NOT1 , AND , OR , IF , forall , ASSERT , IN , Subset , IFF , SetEquiv , Psubset , 0";
adddefdep2 "PsubsetUniv" "NOT1 , forall , forsome , ASSERT , IN , AND , OR , IF , Subset , IFF , SetEquiv , Psubset , 0";
adddefdep2 "UnivPsubset" "AND , forall , NOT1 , OR , IF , ASSERT , IN , Subset , IFF , SetEquiv , Psubset , 0";
adddefdep2 "EmptyPsubset" "NOT1 , forall , IFF , ASSERT , IN , SetEquiv , AND , OR , IF , Subset , Psubset , 0";
adddefdep2 "PsubsetEmpty" "AND , forall , NOT1 , OR , IF , ASSERT , IN , Subset , IFF , SetEquiv , Psubset , 0";
adddefdep2 "PsubsetIdem" "AND , forall , NOT1 , OR , IF , ASSERT , IN , Subset , IFF , SetEquiv , Psubset , 0";
adddefdep2 "PsubsetScin" "AND , forall , NOT1 , OR , IF , ASSERT , IN , Subset , IFF , SetEquiv , Psubset , Set , 0";
adddefdep2 "PsubsetType" "ASSERT , Set , AND , forall , NOT1 , OR , IF , IN , Subset , IFF , SetEquiv , Psubset , 0";
adddefdep2 "DiffSubset" "forall , NOT1 , AND , OR , IF , ASSERT , IN , Subset , SetDifference , 0";
adddefdep2 "Subset_InterAbsorption" "forall , IFF , ASSERT , IN , SetEquiv , AND , Intersection , NOT1 , OR , IF , Subset , 0";
adddefdep2 "InterSymmSubset" "forall , NOT1 , AND , OR , IF , ASSERT , IN , Subset , Intersection , 0";
adddefdep2 "InterSubset" "forall , NOT1 , AND , OR , IF , ASSERT , IN , Subset , Intersection , 0";
adddefdep2 "SubsetUnionSymm" "forall , NOT1 , AND , OR , IF , ASSERT , IN , Subset , Union , 0";
adddefdep2 "SubsetUnion" "forall , NOT1 , AND , OR , IF , ASSERT , IN , Subset , Union , 0";
adddefdep2 "Subset_UnionAbsorption" "forall , IFF , ASSERT , IN , SetEquiv , NOT1 , AND , OR , Union , IF , Subset , 0";
adddefdep2 "UnivSubset" "forall , IFF , ASSERT , IN , SetEquiv , NOT1 , AND , OR , IF , Subset , 0";
adddefdep2 "SubsetUniv" "forall , NOT1 , AND , OR , IF , ASSERT , IN , Subset , 0";
adddefdep2 "SubsetEmpty" "forall , IFF , ASSERT , IN , SetEquiv , NOT1 , AND , OR , IF , Subset , 0";
adddefdep2 "EmptySubset" "forall , NOT1 , AND , OR , IF , ASSERT , IN , Subset , 0";
adddefdep2 "SubsetAntisym" "NOT1 , AND , OR , IF , forall , ASSERT , IN , Subset , IFF , SetEquiv , 0";
adddefdep2 "SubsetIdem" "forall , NOT1 , AND , OR , IF , ASSERT , IN , Subset , 0";
adddefdep2 "SubsetTrans" "NOT1 , AND , OR , IF , forall , ASSERT , IN , Subset , 0";
adddefdep2 "FORALL_3pt82a" "NOT1 , AND , OR , IF , forall , 0";
adddefdep2 "SubsetScin" "forall , NOT1 , AND , OR , IF , ASSERT , IN , Subset , Set , 0";
adddefdep2 "SubsetType" "ASSERT , Set , forall , NOT1 , AND , OR , IF , IN , Subset , 0";
adddefdep2 "InDiff" "AND , ASSERT , IN , NOT1 , SetDifference , 0";
adddefdep2 "DiffInter_Union" "NOT1 , AND , OR , ASSERT , IN , Union , SetDifference , Intersection , 0";
adddefdep2 "DiffUnion" "AND , ASSERT , IN , Intersection , NOT1 , SetDifference , OR , Union , 0";
adddefdep2 "UnionDiff_absorption" "NOT1 , AND , OR , ASSERT , IN , Union , SetDifference , 0";
adddefdep2 "InterDiff_Empty" "AND , ASSERT , IN , Intersection , NOT1 , SetDifference , 0";
adddefdep2 "Diff_InterCompl" "AND , ASSERT , IN , Intersection , NOT1 , Complement , SetDifference , 0";
adddefdep2 "DiffInter" "AND , ASSERT , IN , NOT1 , SetDifference , Intersection , 0";
adddefdep2 "DiffSymm" "AND , ASSERT , IN , NOT1 , SetDifference , 0";
adddefdep2 "DiffIdem" "AND , ASSERT , IN , NOT1 , SetDifference , 0";
adddefdep2 "UnivDiff" "NOT1 , ASSERT , IN , Complement , AND , SetDifference , 0";
adddefdep2 "DiffUniv" "AND , ASSERT , IN , NOT1 , SetDifference , 0";
adddefdep2 "EmptyDiff" "AND , ASSERT , IN , NOT1 , SetDifference , 0";
adddefdep2 "DiffEmpty" "ASSERT , Set , AND , IN , NOT1 , SetDifference , 0";
adddefdep2 "DubDiff" "AND , ASSERT , IN , NOT1 , SetDifference , 0";
adddefdep2 "DiffScin" "AND , ASSERT , IN , NOT1 , SetDifference , Set , 0";
adddefdep2 "DiffType" "ASSERT , Set , AND , IN , NOT1 , SetDifference , 0";
adddefdep2 "InInter" "AND , ASSERT , IN , Intersection , 0";
adddefdep2 "UnionUniv_InterEmpty" "forall , IFF , ASSERT , IN , SetEquiv , NOT1 , Complement , AND , OR , Union , Intersection , 0";
adddefdep2 "DEMORGANb" "NOT1 , AND , OR , ASSERT , IN , Union , Complement , Intersection , 0";
adddefdep2 "DEMORGANa" "AND , ASSERT , IN , Intersection , NOT1 , Complement , OR , Union , 0";
adddefdep2 "InterCompl" "AND , ASSERT , IN , Intersection , NOT1 , Complement , 0";
adddefdep2 "UnionInter" "AND , ASSERT , IN , Intersection , NOT1 , OR , Union , 0";
adddefdep2 "InterUnion" "NOT1 , AND , OR , ASSERT , IN , Union , Intersection , 0";
adddefdep2 "InterEqEmpty" "forall , NOT1 , AND , OR , IF , ASSERT , IN , IFF , SetEquiv , Intersection , 0";
adddefdep2 "InterUniv" "ASSERT , Set , AND , IN , Intersection , 0";
adddefdep2 "UnivInter" "ASSERT , Set , AND , IN , Intersection , 0";
adddefdep2 "InterEmpty" "AND , ASSERT , IN , Intersection , 0";
adddefdep2 "EmptyInter" "AND , ASSERT , IN , Intersection , 0";
adddefdep2 "InterIdem" "ASSERT , Set , AND , IN , Intersection , 0";
adddefdep2 "InterAssoc" "AND , ASSERT , IN , Intersection , 0";
adddefdep2 "InterSymm" "AND , ASSERT , IN , Intersection , 0";
adddefdep2 "InterScin" "AND , ASSERT , IN , Intersection , Set , 0";
adddefdep2 "InterType" "ASSERT , Set , AND , IN , Intersection , 0";
adddefdep2 "InUnion" "NOT1 , AND , OR , ASSERT , IN , Union , 0";
adddefdep2 "UnionEqUniv" "forall , NOT1 , AND , OR , IF , ASSERT , IN , IFF , SetEquiv , Union , 0";
adddefdep2 "UnionEqEmpty" "AND , forall , IFF , ASSERT , IN , SetEquiv , NOT1 , OR , Union , 0";
adddefdep2 "UnionCompl" "NOT1 , AND , OR , ASSERT , IN , Union , Complement , 0";
adddefdep2 "UnionEmpty" "ASSERT , Set , NOT1 , AND , OR , IN , Union , 0";
adddefdep2 "EmptyUnion" "ASSERT , Set , NOT1 , AND , OR , IN , Union , 0";
adddefdep2 "UnionUniv" "NOT1 , AND , OR , ASSERT , IN , Union , 0";
adddefdep2 "UnivUnion" "NOT1 , AND , OR , ASSERT , IN , Union , 0";
adddefdep2 "UnionIdem" "ASSERT , Set , NOT1 , AND , OR , IN , Union , 0";
adddefdep2 "UnionAssoc" "NOT1 , AND , OR , ASSERT , IN , Union , 0";
adddefdep2 "UnionSymm" "NOT1 , AND , OR , ASSERT , IN , Union , 0";
adddefdep2 "UnionScin" "NOT1 , AND , OR , ASSERT , IN , Union , Set , 0";
adddefdep2 "UnionType" "ASSERT , Set , NOT1 , AND , OR , IN , Union , 0";
adddefdep2 "InCompl" "NOT1 , ASSERT , IN , Complement , 0";
adddefdep2 "ComplEmpty_Univ" "forall , IFF , ASSERT , IN , SetEquiv , NOT1 , Complement , 0";
adddefdep2 "ComplUniv_Empty" "forall , IFF , ASSERT , IN , SetEquiv , NOT1 , Complement , 0";
adddefdep2 "EqCompl" "forall , IFF , ASSERT , IN , SetEquiv , NOT1 , Complement , 0";
adddefdep2 "ComplEq" "forall , IFF , ASSERT , IN , SetEquiv , NOT1 , Complement , 0";
adddefdep2 "ComplEqUniv" "forall , NOT1 , ASSERT , IN , IFF , SetEquiv , Complement , 0";
adddefdep2 "ComplUniv" "NOT1 , ASSERT , IN , Complement , 0";
adddefdep2 "ComplEmpty" "NOT1 , ASSERT , IN , Complement , 0";
adddefdep2 "DubComplement" "ASSERT , Set , NOT1 , IN , Complement , 0";
adddefdep2 "EqEmpty" "forall , NOT1 , ASSERT , IN , IFF , SetEquiv , 0";
adddefdep2 "NotEqEmpty" "NOT1 , forall , forsome , ASSERT , IN , IFF , SetEquiv , 0";
adddefdep2 "EqUniv" "forall , ASSERT , IN , IFF , SetEquiv , 0";
adddefdep2 "NotEq" "NOT1 , forall , forsome , IFF , ASSERT , IN , SetEquiv , 0";
adddefdep2 "EmptyNotUniv" "forall , IFF , ASSERT , IN , SetEquiv , 0";
adddefdep2 "UnivNotEmpty" "forall , IFF , ASSERT , IN , SetEquiv , 0";
adddefdep2 "EquivSymm" "forall , IFF , ASSERT , IN , SetEquiv , 0";
adddefdep2 "EquivType" "forall , IFF , ASSERT , IN , SetEquiv , Set , 0";
adddefdep2 "EquivBool" "forall , IFF , ASSERT , IN , SetEquiv , 0";
adddefdep2 "InUniv" "ASSERT , IN , 0";
adddefdep2 "InEmpty" "ASSERT , IN , 0";
adddefdep2 "ReverseIn" "ASSERT , 0";
adddefdep2 "ApplyIn" "0";
adddefdep2 "InType" "ASSERT , IN , Set , 0";
adddefdep2 "INBOOL" "ASSERT , IN , 0";
adddefdep2 "EmptySet" "ASSERT , Set , 0";
adddefdep2 "TrueSet" "ASSERT , Set , 0";
adddefdep2 "SETRETRACT" "ASSERT , Set , 0";
adddefdep2 "Disjoint" "forall , IFF , ASSERT , IN , SetEquiv , AND , Intersection , Disjoint , 0";
adddefdep2 "Psubset" "AND , forall , NOT1 , OR , IF , ASSERT , IN , Subset , IFF , SetEquiv , Psubset , 0";
adddefdep2 "Complement" "NOT1 , ASSERT , IN , Complement , 0";
adddefdep2 "Subset" "forall , NOT1 , AND , OR , IF , ASSERT , IN , Subset , 0";
adddefdep2 "SetDifference" "AND , ASSERT , IN , NOT1 , SetDifference , 0";
adddefdep2 "Intersection" "AND , ASSERT , IN , Intersection , 0";
adddefdep2 "Union" "NOT1 , AND , OR , ASSERT , IN , Union , 0";
adddefdep2 "SetEquiv" "forall , IFF , ASSERT , IN , SetEquiv , 0";
adddefdep2 "Set" "ASSERT , Set , 0";
adddefdep2 "FS_SEQUENT" "IGNOREFIRST , 0";
adddefdep2 "FS6" "IGNOREFIRST , AND , 0";
adddefdep2 "FS5" "IGNOREFIRST , AND , forall , 0";
adddefdep2 "FS4" "IGNOREFIRST , AND , forall , 0";
adddefdep2 "FS3" "IGNOREFIRST , AND , forall , 0";
adddefdep2 "FS2" "IGNOREFIRST , forall , 0";
adddefdep2 "FS1" "IGNOREFIRST , 0";
adddefdep2 "FS0b" "forall , 0";
adddefdep2 "FS0" "IGNOREFIRST , 0";
adddefdep2 "SETUP_SEQUENT" "NOT1 , AND , OR , IF , ASSERT , 0";
adddefdep2 "INR" "IGNOREFIRST , NOT1 , AND , OR , IF , ASSERT , IN , 0";
adddefdep2 "INL" "IGNOREFIRST , NOT1 , AND , OR , IF , ASSERT , IN , 0";
adddefdep2 "INSCOUT" "ASSERT , IN , 0";
adddefdep2 "IN" "ASSERT , IN , 0";
adddefdep2 "EXISTR" "IGNOREFIRST , NOT1 , AND , OR , IF , forall , forsome , 0";
adddefdep2 "EXISTL" "IGNOREFIRST , NOT1 , AND , OR , IF , forall , forsome , 0";
adddefdep2 "FORSOMEANDDIST" "NOT1 , forall , forsome , AND , 0";
adddefdep2 "UNIVR" "IGNOREFIRST , NOT1 , AND , OR , IF , forall , 0";
adddefdep2 "UNIVL" "IGNOREFIRST , NOT1 , AND , OR , IF , forall , 0";
adddefdep2 "CUT" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "IFFR" "IGNOREFIRST , NOT1 , AND , OR , IF , IFF , 0";
adddefdep2 "IFFL" "IGNOREFIRST , NOT1 , AND , OR , IF , IFF , 0";
adddefdep2 "WEAKR" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "WEAKL" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "EXR" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "EXL" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "AXIOM" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "IFR" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "IFL" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "ORR" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "ORL" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "ANDR" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "ANDL" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "NEGR" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "NEGL" "IGNOREFIRST , NOT1 , AND , OR , IF , 0";
adddefdep2 "SELFLABEL" "IGNOREFIRST , 0";
adddefdep2 "GETR" "NOT1 , AND , OR , 0";
adddefdep2 "GETL" "AND , 0";
adddefdep2 "UNIV_EQ_TAC" "forall , 0";
adddefdep2 "UNIV_EQ" "forall , 0";
adddefdep2 "UNIV_TAC" "forall , 0";
adddefdep2 "9pt26" "NOT1 , AND , OR , IF , forall , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "9pt25" "NOT1 , AND , OR , IF , forall , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "9pt24" "NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "9pt23" "NOT1 , AND , OR , IF , forall , forsome , IFF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "9pt22" "AND , NOT1 , forall , forsome , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "9pt21" "AND , NOT1 , forall , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "9pt20" "NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "9pt18c" "NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "9pt18b" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "9pt18a" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "9pt11" "NOT1 , AND , OR , IF , forall , P1 , P2 , forallr , 0";
adddefdep2 "9pt10" "NOT1 , AND , OR , IF , forall , P1 , P2 , forallr , 0";
adddefdep2 "9pt8" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "9pt7" "NOT1 , AND , OR , IF , forall , IFF , P1 , P2 , forallr , 0";
adddefdep2 "9pt6" "NOT1 , AND , OR , forall , IF , P1 , P2 , forallr , 0";
adddefdep2 "9pt5" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "9pt4d" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , IFF , 0";
adddefdep2 "9pt4c" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , IFF , 0";
adddefdep2 "9pt4b" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "9pt4a" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "9pt3c" "forall , IFF , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "9pt3b" "forall , IFF , AND , NOT1 , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "9pt3a" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "8pt19E" "NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "8pt19U" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "8pt16E" "NOT1 , AND , OR , forall , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "8pt16U" "AND , forall , NOT1 , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "8pt15E" "NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "8pt15U" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "8pt13E" "NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "8pt13U" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "FORSOMERBOOL3" "NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "FORSOMERBOOL2" "NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "FORALLRBOOL3" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "FORALLRBOOL2" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "UNIV_RANGE_2" "NOT1 , forall , forsome , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "8pt14E" "ASSERT , NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "L" "0";
adddefdep2 "R" "0";
adddefdep2 "8pt14U" "ASSERT , forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "9pt30b" "forall , NOT1 , AND , OR , IF , forsome , 0";
adddefdep2 "9pt30a" "NOT1 , AND , OR , IF , forall , forsome , 0";
adddefdep2 "9pt16b" "forall , 0";
adddefdep2 "9pt16a" "0";
adddefdep2 "9pt16a1" "forall , 0";
adddefdep2 "PRE9pt12" "NOT1 , AND , OR , IF , forall , 0";
adddefdep2 "CONVERT_IMP_2" "NOT1 , AND , OR , IF , ASSERT , 0";
adddefdep2 "CONVERT_IMP_1" "NOT1 , AND , OR , IF , 0";
adddefdep2 "ONEPOINT" "ASSERT , forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "UNIV_RANGE_1" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "forsomer3" "NOT1 , forall , forsome , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "forsomer2" "NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "FORSOMERBOOL" "NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "forsomer" "NOT1 , forall , AND , OR , IF , P1 , P2 , forallr , forsomer , 0";
adddefdep2 "forallr2" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "FORALLRBOOL" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "forallr" "forall , NOT1 , AND , OR , IF , P1 , P2 , forallr , 0";
adddefdep2 "EQ_TRANS" "NOT1 , AND , OR , IF , 0";
adddefdep2 "COMMUTE_LEVEL_QUANT" "IFF , forall , 0";
adddefdep2 "ALT_QUANT_AGAIN" "NOT1 , AND , OR , IF , forall , forsome , 0";
adddefdep2 "TAB_CEX" "forall , 0";
adddefdep2 "TAB_WITNESS" "NOT1 , forall , forsome , 0";
adddefdep2 "ANY_INSTANCE" "NOT1 , AND , OR , IF , 0";
adddefdep2 "forallcase" "forall , 0";
adddefdep2 "forsomecase" "NOT1 , forall , forsome , 0";
adddefdep2 "CEX_TAC" "NOT1 , COUNTER1 , forall , 0";
adddefdep2 "CHOICE_TAC" "NOT1 , forall , forsome , 0";
adddefdep2 "CEX" "NOT1 , COUNTER1 , forall , 0";
adddefdep2 "SUBTYPE" "0";
adddefdep2 "COUNTER" "NOT1 , COUNTER1 , 0";
adddefdep2 "COUNTER1" "NOT1 , COUNTER1 , 0";
adddefdep2 "CHOICE" "NOT1 , forall , forsome , 0";
adddefdep2 "ALT_QUANT_IMP" "NOT1 , AND , OR , IF , forall , forsome , 0";
adddefdep2 "TAB_ALL_NEW_2" "forall , 0";
adddefdep2 "TAB_ALL_NEW_1" "forall , 0";
adddefdep2 "TAB_SOME_NEW_2" "NOT1 , forall , forsome , 0";
adddefdep2 "TAB_SOME_NEW_1" "NOT1 , forall , forsome , 0";
adddefdep2 "TAB_SOME_2" "NOT1 , forall , forsome , 0";
adddefdep2 "TAB_ALL_2" "forall , 0";
adddefdep2 "TAB_SOME" "NOT1 , forall , forsome , 0";
adddefdep2 "TAB_ALL" "forall , 0";
adddefdep2 "TAB_XOR_2" "NOT1 , IFF , XOR , 0";
adddefdep2 "TAB_XOR" "NOT1 , IFF , XOR , 0";
adddefdep2 "TAB_IFF_2" "IFF , 0";
adddefdep2 "TAB_IFF" "IFF , 0";
adddefdep2 "TAB_IF_2" "NOT1 , AND , OR , IF , 0";
adddefdep2 "TAB_IF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "TAB_OR_2" "NOT1 , AND , OR , 0";
adddefdep2 "TAB_OR" "NOT1 , AND , OR , 0";
adddefdep2 "TAB_AND_2" "AND , 0";
adddefdep2 "TAB_AND" "AND , 0";
adddefdep2 "TAB_NOT_2" "NOT1 , 0";
adddefdep2 "TAB_NOT" "NOT1 , 0";
adddefdep2 "FORALL_IMP_FORSOME_EQ" "NOT1 , AND , OR , IF , forall , forsome , 0";
adddefdep2 "FORSOME_NOTFORALL" "NOT1 , forall , forsome , 0";
adddefdep2 "FORALL_NOTFORSOME" "forall , NOT1 , forsome , 0";
adddefdep2 "FORSOMEDIST2" "AND , NOT1 , forall , forsome , 0";
adddefdep2 "FORALLORDIST" "NOT1 , AND , OR , forall , 0";
adddefdep2 "FORALLOR" "NOT1 , AND , OR , forall , 0";
adddefdep2 "FORALLNOT" "AND , forall , NOT1 , 0";
adddefdep2 "NOTFORALL" "NOT1 , AND , OR , forall , 0";
adddefdep2 "FORALLSWITCH2" "forall , 0";
adddefdep2 "FORSOMEDROP" "ASSERT , NOT1 , forall , forsome , 0";
adddefdep2 "FORALLDROP" "ASSERT , forall , 0";
adddefdep2 "FORALLSWITCH" "forall , 0";
adddefdep2 "FORALLDIST" "AND , forall , 0";
adddefdep2 "DINSTANTIATEF1" "NOT1 , AND , OR , forall , forsome , 0";
adddefdep2 "DINSTANTIATE" "NOT1 , forall , forsome , AND , OR , 0";
adddefdep2 "INSTANTIATE" "forall , AND , 0";
adddefdep2 "TESTSIMP" "0";
adddefdep2 "CONDSIMP" "NOT1 , AND , OR , ASSERT , 0";
adddefdep2 "XORALTDEF" "NOT1 , IFF , AND , OR , 0";
adddefdep2 "CASEPREP" "0";
adddefdep2 "CONDCASES2" "NOT1 , AND , OR , ASSERT , 0";
adddefdep2 "IMPTOCOND" "ASSERT , NOT1 , AND , OR , IF , 0";
adddefdep2 "CONDCASES" "ASSERT , NOT1 , AND , OR , 0";
adddefdep2 "CONDCASESL1F" "IFF , NOT1 , AND , OR , 0";
adddefdep2 "CONDCASESL1" "IFF , NOT1 , AND , OR , 0";
adddefdep2 "BEQSUBS" "NOT1 , AND , OR , IF , IFF , 0";
adddefdep2 "ASRTCOND" "ASSERT , 0";
adddefdep2 "EQSYMM2" "0";
adddefdep2 "CONVORAND" "IFF , NOT1 , AND , OR , 0";
adddefdep2 "CONVORIMP" "IFF , NOT1 , AND , OR , IF , 0";
adddefdep2 "CONVANDOR" "NOT1 , AND , OR , IF , 0";
adddefdep2 "CONVANDIMP" "IFF , AND , NOT1 , OR , IF , 0";
adddefdep2 "CONVIMPOR" "NOT1 , AND , OR , IF , 0";
adddefdep2 "CONVIMPAND" "AND , NOT1 , OR , IF , 0";
adddefdep2 "IDIS4" "NOT1 , AND , OR , IF , 0";
adddefdep2 "IDIS3" "AND , NOT1 , OR , IF , 0";
adddefdep2 "IDIS2" "NOT1 , AND , OR , IF , 0";
adddefdep2 "IDIS1" "AND , NOT1 , OR , IF , 0";
adddefdep2 "3pt89" "ASSERT , NOT1 , AND , OR , 0";
adddefdep2 "AP3pt88" "NOT1 , AND , OR , 0";
adddefdep2 "3pt88" "NOT1 , AND , OR , ASSERT , 0";
adddefdep2 "3pt87" "AND , 0";
adddefdep2 "AP3pt86b" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt86b" "NOT1 , AND , OR , IF , ASSERT , 0";
adddefdep2 "AP3pt86a" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt86a" "NOT1 , AND , OR , IF , ASSERT , 0";
adddefdep2 "3pt85b" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt85a" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt84c" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt84b" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt83F" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt83" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt82cF" "NOT1 , AND , OR , IF , IFF , 0";
adddefdep2 "3pt82c" "NOT1 , AND , OR , IF , IFF , 0";
adddefdep2 "3pt82bF" "NOT1 , AND , OR , IF , IFF , 0";
adddefdep2 "3pt82b" "NOT1 , AND , OR , IF , IFF , 0";
adddefdep2 "3pt82aF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt82a" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt81F" "NOT1 , AND , OR , IF , IFF , 0";
adddefdep2 "3pt81" "NOT1 , AND , OR , IF , IFF , 0";
adddefdep2 "3pt80" "IFF , AND , NOT1 , OR , IF , 0";
adddefdep2 "3pt79F" "AND , NOT1 , OR , IF , ASSERT , 0";
adddefdep2 "3pt79" "ASSERT , AND , NOT1 , OR , IF , 0";
adddefdep2 "3pt78" "NOT1 , AND , OR , IF , 0";
adddefdep2 "MOPF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "MOP" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt76eF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt76e" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt76dF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt76d" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt76cF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt76c" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt76bF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt76b" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt76aF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt76a" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt75F" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt75" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt74" "NOT1 , AND , OR , IF , 0";
adddefdep2 "ILID" "ASSERT , NOT1 , AND , OR , IF , 0";
adddefdep2 "IRZERF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "IRZER" "NOT1 , AND , OR , IF , 0";
adddefdep2 "IREFF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "IREF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt70" "IFF , NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt69" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt68F" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt68" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt67F" "AND , NOT1 , OR , IF , ASSERT , 0";
adddefdep2 "3pt67" "ASSERT , AND , NOT1 , OR , IF , 0";
adddefdep2 "3pt66" "AND , NOT1 , OR , IF , 0";
adddefdep2 "3pt64" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt65" "NOT1 , AND , OR , IF , 0";
adddefdep2 "3pt62" "IFF , AND , NOT1 , OR , IF , 0";
adddefdep2 "IDISB" "IFF , NOT1 , AND , OR , IF , 0";
adddefdep2 "CONTP" "NOT1 , AND , OR , IF , 0";
adddefdep2 "IDEF3" "IFF , AND , NOT1 , OR , IF , 0";
adddefdep2 "IDEF2" "NOT1 , AND , OR , IF , 0";
adddefdep2 "XALTDEF" "NOT1 , AND , OR , IFF , XOR , 0";
adddefdep2 "BALTDEF" "NOT1 , AND , OR , IFF , 0";
adddefdep2 "REPL" "AND , IFF , 0";
adddefdep2 "3pt50" "AND , IFF , 0";
adddefdep2 "3pt49" "AND , IFF , 0";
adddefdep2 "3pt48" "AND , IFF , NOT1 , 0";
adddefdep2 "CDISD" "NOT1 , AND , OR , 0";
adddefdep2 "DDISC" "AND , NOT1 , OR , 0";
adddefdep2 "3pt44b" "NOT1 , AND , OR , 0";
adddefdep2 "3pt44a" "AND , NOT1 , OR , 0";
adddefdep2 "L3pt43" "AND , IFF , NOT1 , OR , 0";
adddefdep2 "3pt43bF" "NOT1 , AND , OR , ASSERT , 0";
adddefdep2 "3pt43b" "ASSERT , NOT1 , AND , OR , 0";
adddefdep2 "3pt43aF" "AND , NOT1 , OR , ASSERT , 0";
adddefdep2 "3pt43a" "ASSERT , AND , NOT1 , OR , 0";
adddefdep2 "CCON" "AND , NOT1 , 0";
adddefdep2 "CDISC" "AND , 0";
adddefdep2 "CZERF" "AND , 0";
adddefdep2 "CZER" "AND , 0";
adddefdep2 "CID" "ASSERT , AND , 0";
adddefdep2 "CIDEM" "ASSERT , AND , 0";
adddefdep2 "CASSOC" "AND , 0";
adddefdep2 "CSYM" "AND , 0";
adddefdep2 "DUAL" "0";
adddefdep2 "REMFLIP" "0";
adddefdep2 "SREMFLIP" "0";
adddefdep2 "NOTCLEAN" "NOT1 , 0";
adddefdep2 "ASSERTCLEAN" "ASSERT , 0";
adddefdep2 "REMA" "NOT1 , ASSERT , 0";
adddefdep2 "AF" "ASSERT , 0";
adddefdep2 "AT" "ASSERT , 0";
adddefdep2 "FLIPALL" "0";
adddefdep2 "SFLIPALL" "0";
adddefdep2 "FLIPPASTC" "NOT1 , AND , OR , 0";
adddefdep2 "FLIPPASTD" "AND , NOT1 , OR , 0";
adddefdep2 "FLIPPASTX" "IFF , NOT1 , XOR , 0";
adddefdep2 "FLIPPASTB" "NOT1 , IFF , XOR , 0";
adddefdep2 "FLIPPASTN" "NOT1 , 0";
adddefdep2 "FLIPPASTA" "ASSERT , NOT1 , 0";
adddefdep2 "XORFLIP" "IFF , NOT1 , XOR , 0";
adddefdep2 "BFLIP" "NOT1 , IFF , XOR , 0";
adddefdep2 "DEMa" "NOT1 , AND , OR , 0";
adddefdep2 "DEMb" "NOT1 , AND , OR , 0";
adddefdep2 "GR3" "NOT1 , AND , OR , IFF , 0";
adddefdep2 "GR2" "AND , IFF , NOT1 , OR , 0";
adddefdep2 "3pt32F" "IFF , NOT1 , AND , OR , ASSERT , 0";
adddefdep2 "3pt32" "ASSERT , IFF , NOT1 , AND , OR , 0";
adddefdep2 "DID" "ASSERT , NOT1 , AND , OR , 0";
adddefdep2 "DDISD" "NOT1 , AND , OR , 0";
adddefdep2 "DZERF" "NOT1 , AND , OR , 0";
adddefdep2 "DZER" "NOT1 , AND , OR , 0";
adddefdep2 "MUTINT" "IFF , NOT1 , XOR , 0";
adddefdep2 "MUTASSOC" "NOT1 , IFF , XOR , 0";
adddefdep2 "XORASSOC" "NOT1 , IFF , XOR , 0";
adddefdep2 "XORSYM" "NOT1 , IFF , XOR , 0";
adddefdep2 "NEQ" "IFF , NOT1 , 0";
adddefdep2 "DUBNEG2" "ASSERT , NOT1 , 0";
adddefdep2 "NEGF" "NOT1 , 0";
adddefdep2 "3pt15bF" "IFF , NOT1 , 0";
adddefdep2 "3pt15b" "IFF , NOT1 , 0";
adddefdep2 "3pt15a" "NOT1 , IFF , 0";
adddefdep2 "3pt14" "IFF , NOT1 , XOR , 0";
adddefdep2 "3pt11" "IFF , NOT1 , 0";
adddefdep2 "APLZ" "AND , 0";
adddefdep2 "THMAP" "0";
adddefdep2 "MKASRT" "0";
adddefdep2 "ASRTRIGHT" "0";
adddefdep2 "ASRTLEFT" "0";
adddefdep2 "ASSRTBOTH" "0";
adddefdep2 "GCLEAN" "0";
adddefdep2 "STT" "ASSERT , 0";
adddefdep2 "STR" "ASSERT , 0";
adddefdep2 "STL" "ASSERT , 0";
adddefdep2 "EQT" "ASSERT , 0";
adddefdep2 "BCONV" "ASSERT , IFF , 0";
adddefdep2 "ASRTEQ" "ASSERT , 0";
adddefdep2 "LZ" "AND , 0";
adddefdep2 "CONS" "NOT1 , AND , OR , IF , CONVIF , 0";
adddefdep2 "IDEF" "IFF , NOT1 , AND , OR , IF , 0";
adddefdep2 "GR" "IFF , AND , NOT1 , OR , 0";
adddefdep2 "DXMF" "NOT1 , AND , OR , 0";
adddefdep2 "BIDF" "IFF , 0";
adddefdep2 "DXM" "NOT1 , AND , OR , 0";
adddefdep2 "DDIS" "IFF , NOT1 , AND , OR , 0";
adddefdep2 "DIDEM" "ASSERT , NOT1 , AND , OR , 0";
adddefdep2 "DSYM" "NOT1 , AND , OR , 0";
adddefdep2 "DASSOC" "NOT1 , AND , OR , 0";
adddefdep2 "XORDEF" "NOT1 , IFF , XOR , 0";
adddefdep2 "BDIS" "IFF , NOT1 , 0";
adddefdep2 "FDEF" "NOT1 , 0";
adddefdep2 "BID2" "ASSERT , IFF , 0";
adddefdep2 "BID" "IFF , 0";
adddefdep2 "BSYM" "IFF , 0";
adddefdep2 "BASSOC" "IFF , 0";
adddefdep2 "PROVETAUT2" "0";
adddefdep2 "PROVETAUT" "0";
adddefdep2 "CNRULE3" "NOT1 , AND , OR , IF , CONVIF , ASSERT , 0";
adddefdep2 "CNRULE2" "NOT1 , AND , OR , IF , CONVIF , ASSERT , 0";
adddefdep2 "CNRULE1" "NOT1 , AND , OR , IF , CONVIF , ASSERT , 0";
adddefdep2 "IRULE3" "NOT1 , AND , OR , IF , ASSERT , 0";
adddefdep2 "IRULE2" "NOT1 , AND , OR , IF , ASSERT , 0";
adddefdep2 "IRULE1" "NOT1 , AND , OR , IF , ASSERT , 0";
adddefdep2 "NRULE2" "NOT1 , ASSERT , 0";
adddefdep2 "NRULE1" "NOT1 , ASSERT , 0";
adddefdep2 "XRULE3" "NOT1 , IFF , XOR , ASSERT , 0";
adddefdep2 "XRULE2" "NOT1 , IFF , XOR , ASSERT , 0";
adddefdep2 "XRULE1" "NOT1 , IFF , XOR , ASSERT , 0";
adddefdep2 "CRULE3" "AND , ASSERT , 0";
adddefdep2 "CRULE2" "AND , ASSERT , 0";
adddefdep2 "CRULE1" "AND , ASSERT , 0";
adddefdep2 "DRULE3" "NOT1 , AND , OR , ASSERT , 0";
adddefdep2 "DRULE2" "NOT1 , AND , OR , ASSERT , 0";
adddefdep2 "DRULE1" "NOT1 , AND , OR , ASSERT , 0";
adddefdep2 "BRULE3" "IFF , ASSERT , 0";
adddefdep2 "BRULE2" "IFF , ASSERT , 0";
adddefdep2 "BRULE1" "IFF , ASSERT , 0";
adddefdep2 "NEWTAUT" "0";
adddefdep2 "ALL_EXP" "0";
adddefdep2 "ALT_PUSH" "0";
adddefdep2 "CN_EXP" "NOT1 , AND , OR , IF , CONVIF , 0";
adddefdep2 "XOR_EXP" "NOT1 , IFF , XOR , 0";
adddefdep2 "IFF_EXP" "IFF , 0";
adddefdep2 "NONTRIV2a" "0";
adddefdep2 "IF_EXP" "NOT1 , AND , OR , IF , 0";
adddefdep2 "OR_EXP" "NOT1 , AND , OR , 0";
adddefdep2 "AND_EXP" "AND , 0";
adddefdep2 "NOT_EXP" "NOT1 , 0";
adddefdep2 "ASSERT_EXP" "ASSERT , 0";
adddefdep2 "MAKE_CASE" "0";
adddefdep2 "FORSOMEBOOL2" "NOT1 , forall , forsome , 0";
adddefdep2 "FORALLBOOL2" "forall , 0";
adddefdep2 "BOOLDEF2" "0";
adddefdep2 "ASSERT_UNEXP" "ASSERT , 0";
adddefdep2 "ANDUNPACK" "AND , 0";
adddefdep2 "DUBNEG" "NOT1 , 0";
adddefdep2 "BOOLDEF0" "0";
adddefdep2 "UNPACK" "0";
adddefdep2 "EXAMPLE1" "forall , NOT1 , forsome , 0";
adddefdep2 "CNBOOL" "NOT1 , AND , OR , IF , CONVIF , 0";
adddefdep2 "CONSCIN" "NOT1 , AND , OR , IF , CONVIF , 0";
adddefdep2 "CONTYPE" "ASSERT , NOT1 , AND , OR , IF , CONVIF , 0";
adddefdep2 "CONVIF" "NOT1 , AND , OR , IF , CONVIF , 0";
adddefdep2 "IMPTYPE" "ASSERT , NOT1 , AND , OR , IF , 0";
adddefdep2 "CTYPE" "ASSERT , AND , 0";
adddefdep2 "DTYPE" "ASSERT , NOT1 , AND , OR , 0";
adddefdep2 "NTYPE" "ASSERT , NOT1 , 0";
adddefdep2 "XORBOOL" "NOT1 , IFF , XOR , 0";
adddefdep2 "XORSCIN" "NOT1 , IFF , XOR , 0";
adddefdep2 "XORTYPE" "ASSERT , NOT1 , IFF , XOR , 0";
adddefdep2 "XOR" "NOT1 , IFF , XOR , 0";
adddefdep2 "ALLASSERTS" "ASSERT , 0";
adddefdep2 "BTYPE" "ASSERT , IFF , 0";
adddefdep2 "ASSERT2" "ASSERT , 0";
adddefdep2 "TWOASSERTS" "ASSERT , 0";
adddefdep2 "ASSERTSCOUT" "ASSERT , 0";
adddefdep2 "ASSERT" "ASSERT , 0";
adddefdep2 "IFFSCIN" "IFF , 0";
adddefdep2 "IFSCIN" "NOT1 , AND , OR , IF , 0";
adddefdep2 "ORSCIN" "NOT1 , AND , OR , 0";
adddefdep2 "NOTBOOLDROP" "NOT1 , 0";
adddefdep2 "ANDSCIN" "AND , 0";
adddefdep2 "IFFBOOL" "IFF , 0";
adddefdep2 "IFF" "IFF , 0";
adddefdep2 "IFBOOL" "NOT1 , AND , OR , IF , 0";
adddefdep2 "IF" "NOT1 , AND , OR , IF , 0";
adddefdep2 "ALTORDEF" "NOT1 , AND , OR , 0";
adddefdep2 "NOT" "NOT1 , 0";
adddefdep2 "ORBOOL" "NOT1 , AND , OR , 0";
adddefdep2 "OR" "NOT1 , AND , OR , 0";
adddefdep2 "ANDBOOL" "AND , 0";
adddefdep2 "AND" "AND , 0";
adddefdep2 "BOOLDEF" "0";
adddefdep2 "FALSEBOOL" "0";
adddefdep2 "TRUEBOOL" "0";
adddefdep2 "forsome2" "NOT1 , forall , forsome , 0";
adddefdep2 "FORSOMEBOOL" "NOT1 , forall , forsome , 0";
adddefdep2 "forsome" "NOT1 , forall , forsome , 0";
adddefdep2 "NOTBOOL" "NOT1 , 0";
adddefdep2 "NOT1" "NOT1 , 0";
adddefdep2 "forall2" "forall , 0";
adddefdep2 "FORALLBOOL" "forall , 0";
adddefdep2 "forall" "forall , 0";
adddefdep2 "EQBOOL" "0";
adddefdep2 "EQSYMM" "0";
adddefdep2 "LAMBDAREMOVE" "0";
adddefdep2 "LAMBDAREMOVE3" "0";
adddefdep2 "LAMBDAREMOVE2" "0";
adddefdep2 "LAMBDAREMOVE1" "0";
adddefdep2 "LAMBDAINTRO" "0";
adddefdep2 "LAMBDAINTRO3" "0";
adddefdep2 "LAMBDAINTRO2" "0";
adddefdep2 "LAMBDAINTRO1" "0";
adddefdep2 "LABELINTRO" "IGNOREFIRST , 0";
adddefdep2 "goto" "0";
adddefdep2 "INPUT_AT" "0";
adddefdep2 "value" "0";
adddefdep2 "left_case" "0";
adddefdep2 "right_case" "0";
adddefdep2 "left" "0";
adddefdep2 "right" "0";
adddefdep2 "INPUTS2" "0";
adddefdep2 "up" "upfun , 0";
adddefdep2 "upfun" "upfun , 0";
adddefdep2 "BINDLABELS" "0";
adddefdep2 "APPLYATLABELS" "0";
adddefdep2 "APPLYATLABEL" "0";
adddefdep2 "APPLYATLABEL0" "IGNOREFIRST , 0";
adddefdep2 "LABELTERM" "0";
adddefdep2 "LABELTERMS" "0";
adddefdep2 "LABELTERMS_CASE" "0";
adddefdep2 "LABELTERMS_UNARY" "0";
adddefdep2 "LABELTERMS_ABSTRACT" "0";
adddefdep2 "LABELTERMS_SPLIT" "0";
adddefdep2 "LABELTERMS_FOUND" "0";
adddefdep2 "POP_CASE" "0";
adddefdep2 "POP_CASE_2" "0";
adddefdep2 "POP_CASE_1" "IGNOREFIRST , 0";
adddefdep2 "ANTI_UNEVAL_TAC" "0";
adddefdep2 "TYPEBIND" "0";
adddefdep2 "UNEVAL_TAC" "0";
adddefdep2 "GET" "0";
adddefdep2 "GET2" "0";
adddefdep2 "GET1" "0";
adddefdep2 "GET0" "0";
adddefdep2 "ALLASSOCS" "0";
adddefdep2 "ASSOCS" "0";
adddefdep2 "VIEWCASES" "0";
adddefdep2 "LOOP_TAC" "0";
adddefdep2 "ALL_STEPS" "IGNOREFIRST , 0";
adddefdep2 "STOPLOOP" "IGNOREFIRST , 0";
adddefdep2 "STARTLOOP" "IGNOREFIRST , 0";
adddefdep2 "LISTBIND" "0";
adddefdep2 "PAIRBIND" "0";
adddefdep2 "VALUE" "0";
adddefdep2 "VALUE0" "0";
adddefdep2 "PI2F" "P2 , 0";
adddefdep2 "PI1F" "P1 , 0";
adddefdep2 "REVPIVOT" "0";
adddefdep2 "PIVOT" "0";
adddefdep2 "TOPDOWN" "0";
adddefdep2 "TOPDOWN_PREFIX" "0";
adddefdep2 "TOPDOWN_INFIX" "0";
adddefdep2 "TOPDOWN_CASE" "0";
adddefdep2 "EVERYWHERE2" "0";
adddefdep2 "EVERYWHERE" "0";
adddefdep2 "EVERYWHERE_INFIX" "0";
adddefdep2 "EVERYWHERE_PREFIX" "0";
adddefdep2 "EVERYWHERE_ABS" "0";
adddefdep2 "STRONG_EVERYWHERE_CASE" "0";
adddefdep2 "EVERYWHERE_CASE" "0";
adddefdep2 "BOTH_CASES" "0";
adddefdep2 "RIGHT_CASE" "0";
adddefdep2 "LEFT_CASE" "0";
adddefdep2 "RL" "0";
adddefdep2 "RIGHT" "0";
adddefdep2 "RIGHT2" "0";
adddefdep2 "RIGHT1" "0";
adddefdep2 "LEFT" "0";
adddefdep2 "LEFT2" "0";
adddefdep2 "LEFT1" "0";
adddefdep2 "$" "0";
adddefdep2 "**" "0";
adddefdep2 "PCASEINTRO" "0";
adddefdep2 "ID" "Id , 0";
adddefdep2 "PI2" "P2 , 0";
adddefdep2 "PI1" "P1 , 0";
adddefdep2 "IGNOREFIRST" "IGNOREFIRST , 0";
adddefdep2 "HYP" "0";
adddefdep2 "ODDCHOICE" "0";
adddefdep2 "EQUATION" "0";
adddefdep2 "NONTRIV" "0";
adddefdep2 "REFLEX" "0";
adddefdep2 "CASEINTRO" "0";
adddefdep2 "FNDIST" "0";
adddefdep2 "Id" "Id , 0";
adddefdep2 "P2" "P2 , 0";
adddefdep2 "P1" "P1 , 0";
adddefdep2 "COMP" "COMP , 0";
adddefdep2 "TYPES" "0";
addthmtextdep2 "LESS_EQ_ADD" "LESS_EQ_ADD , LESS_EQ_REAL , LESS , NOT1 , OR , AND , forsome , forall , IF , ASSERT , 0";
addthmtextdep2 "ASSERT" "ASSERT , 0";
addthmtextdep2 "IF" "IF , NOT1 , OR , AND , 0";
addthmtextdep2 "forsome" "forsome , forall , NOT1 , 0";
addthmtextdep2 "forall" "forall , 0";
addthmtextdep2 "LESS_EQ_REAL" "LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "OR" "OR , NOT1 , AND , 0";
addthmtextdep2 "AND" "AND , 0";
addthmtextdep2 "LESS" "LESS , NOT1 , 0";
addthmtextdep2 "NOT1" "NOT1 , 0";
addthmtextdep2 "LESS_OR_ADD" "LESS_OR_ADD , LESS , NOT1 , forsome , forall , OR , AND , IF , ASSERT , 0";
addthmtextdep2 "LESS_ADD1" "LESS_ADD1 , LESS , NOT1 , forsome , forall , IF , OR , AND , 0";
addthmtextdep2 "LESS_ADD" "LESS_ADD , LESS , NOT1 , forsome , forall , IF , OR , AND , 0";
addthmtextdep2 "REALSUBNATTYPE" "REALSUBNATTYPE , LESS , NOT1 , 0";
addthmtextdep2 "NOT_SUC_ADD_LEQ" "NOT_SUC_ADD_LEQ , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "NOT_GREATER_EQ" "NOT_GREATER_EQ , GREATER_EQ_REAL , GREATER , LESS , NOT1 , OR , AND , LESS_EQ_REAL , 0";
addthmtextdep2 "GREATER_EQ_REAL" "GREATER_EQ_REAL , GREATER , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "GREATER" "GREATER , LESS , NOT1 , 0";
addthmtextdep2 "NOT_GREATER" "NOT_GREATER , GREATER , LESS , NOT1 , LESS_EQ_REAL , OR , AND , 0";
addthmtextdep2 "NOT_NUM_EQ" "NOT_NUM_EQ , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "NOT_LEQ_SUC" "NOT_LEQ_SUC , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "NOT_SUC_LEQ_0" "NOT_SUC_LEQ_0 , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "ADD_MONO_LEQ" "ADD_MONO_LEQ , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "EQ_LEQ" "EQ_LEQ , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_LEQ_TRANS" "LESS_LEQ_TRANS , LESS , NOT1 , LESS_EQ_REAL , OR , AND , IF , 0";
addthmtextdep2 "LEQ_LESS_TRANS" "LEQ_LESS_TRANS , LESS_EQ_REAL , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "LESS_MULT2" "LESS_MULT2 , LESS , NOT1 , AND , IF , OR , 0";
addthmtextdep2 "LESS_0_FALSE" "LESS_0_FALSE , LESS , NOT1 , 0";
addthmtextdep2 "NOT_LEQ" "NOT_LEQ , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LEQ_CASES" "LEQ_CASES , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "GREATER_EQ" "GREATER_EQ , GREATER_EQ_REAL , GREATER , LESS , NOT1 , OR , AND , LESS_EQ_REAL , 0";
addthmtextdep2 "LESS_LESS_CASES" "LESS_LESS_CASES , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LEQ_IMP_LESS_SUC" "LEQ_IMP_LESS_SUC , LESS_EQ_REAL , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "NOT_SUC_LEQ" "NOT_SUC_LEQ , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_ADD_SUCF" "LESS_ADD_SUCF , LESS , NOT1 , 0";
addthmtextdep2 "LESS_ADD_SUC" "LESS_ADD_SUC , LESS , NOT1 , 0";
addthmtextdep2 "FLESS_ADD_SUC" "FLESS_ADD_SUC , forall , LESS , NOT1 , 0";
addthmtextdep2 "LESS_EQ_ANTISYM" "LESS_EQ_ANTISYM , LESS_EQ_REAL , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "LESS_MONO_MULTF" "LESS_MONO_MULTF , LESS_EQ_REAL , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "LESS_MONO_MULT" "LESS_MONO_MULT , LESS_EQ_REAL , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "FLESS_MONO_MULT" "FLESS_MONO_MULT , forall , LESS_EQ_REAL , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "MULT_SUC" "MULT_SUC , 0";
addthmtextdep2 "LEQ_LEQ_MONO" "LEQ_LEQ_MONO , LESS_EQ_REAL , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "LEQ_TRANS" "LEQ_TRANS , LESS_EQ_REAL , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "LESS_SUC_NOT" "LESS_SUC_NOT , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LEQ_ADDF" "LEQ_ADDF , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LEQ_ADD" "LEQ_ADD , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "FLEQ_ADD" "FLEQ_ADD , forall , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_ADD_NZF" "LESS_ADD_NZF , NOT1 , LESS , IF , OR , AND , 0";
addthmtextdep2 "LESS_ADD_NZ" "LESS_ADD_NZ , NOT1 , LESS , IF , OR , AND , 0";
addthmtextdep2 "FLESS_ADD_NZ" "FLESS_ADD_NZ , forall , NOT1 , LESS , IF , OR , AND , 0";
addthmtextdep2 "NOT_SUC_LESS" "NOT_SUC_LESS , LESS , NOT1 , 0";
addthmtextdep2 "NOT_LESS" "NOT_LESS , LESS , NOT1 , LESS_EQ_REAL , OR , AND , 0";
addthmtextdep2 "LESS_EQ_BOOL" "LESS_EQ_BOOL , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LEQ_ANTISYM" "LEQ_ANTISYM , LESS , NOT1 , LESS_EQ_REAL , OR , AND , 0";
addthmtextdep2 "SUC_LESSF" "SUC_LESSF , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LEQ_MONO_ADD_EQF" "LEQ_MONO_ADD_EQF , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LEQ_MONO_ADD_EQ" "LEQ_MONO_ADD_EQ , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_MONO_ADD_EQ" "LESS_MONO_ADD_EQ , LESS , NOT1 , 0";
addthmtextdep2 "LESS_MONO_ADD_INVF" "LESS_MONO_ADD_INVF , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LESS_MONO_ADD_INV" "LESS_MONO_ADD_INV , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "FORALL_LESS_MONO_ADD_INVF" "FORALL_LESS_MONO_ADD_INVF , forall , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "FORALL_LESS_MONO_ADD_INV" "FORALL_LESS_MONO_ADD_INV , forall , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LESS_MONO_ADDF" "LESS_MONO_ADDF , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LESS_MONO_ADD" "LESS_MONO_ADD , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "FORALL_LESS_MONO_ADDF" "FORALL_LESS_MONO_ADDF , forall , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "FORALL_LESS_MONO_ADD" "FORALL_LESS_MONO_ADD , forall , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "BOUNDED_N" "BOUNDED_N , LESS , NOT1 , LESS_EQ_REAL , OR , AND , IF , 0";
addthmtextdep2 "LESS_LESS_SUC" "LESS_LESS_SUC , LESS , NOT1 , AND , 0";
addthmtextdep2 "LESS_ANTISYMF" "LESS_ANTISYMF , LESS , NOT1 , AND , 0";
addthmtextdep2 "LESS_ANTISYM" "LESS_ANTISYM , LESS , NOT1 , AND , 0";
addthmtextdep2 "FORALL_LESS_ANTISYM" "FORALL_LESS_ANTISYM , forall , LESS , NOT1 , AND , 0";
addthmtextdep2 "LESS_TRANSF" "LESS_TRANSF , LESS , NOT1 , AND , IF , OR , 0";
addthmtextdep2 "LESS_TRANS" "LESS_TRANS , LESS , NOT1 , AND , IF , OR , 0";
addthmtextdep2 "FORALL_LESS_TRANS" "FORALL_LESS_TRANS , forall , LESS , NOT1 , AND , IF , OR , 0";
addthmtextdep2 "LESS_IMP_LEQ" "LESS_IMP_LEQ , LESS , NOT1 , LESS_EQ_REAL , OR , AND , IF , 0";
addthmtextdep2 "LEQ_REFL" "LEQ_REFL , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "NOT_ADD_LESSF" "NOT_ADD_LESSF , forall , LESS , NOT1 , 0";
addthmtextdep2 "NOT_ADD_LESS" "NOT_ADD_LESS , forall , LESS , NOT1 , 0";
addthmtextdep2 "LESS_NOT_SUC" "LESS_NOT_SUC , LESS , NOT1 , AND , IF , OR , 0";
addthmtextdep2 "LESS_SUC_EQ_COR" "LESS_SUC_EQ_COR , LESS , NOT1 , AND , IF , OR , 0";
addthmtextdep2 "LESS_EQ_MONO" "LESS_EQ_MONO , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "ALL_GEQ_0" "ALL_GEQ_0 , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LEQ_SUC_REFL" "LEQ_SUC_REFL , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_EQ" "LESS_EQ , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "OR_LESS" "OR_LESS , LESS_EQ_REAL , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "LESS_OR" "LESS_OR , LESS , NOT1 , LESS_EQ_REAL , OR , AND , IF , 0";
addthmtextdep2 "LESS_CASES_IMP" "LESS_CASES_IMP , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "LESS_CASESF" "LESS_CASESF , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_CASES" "LESS_CASES , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "FORALL_LESS_CASES" "FORALL_LESS_CASES , forall , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_0_CASES_INV" "LESS_0_CASES_INV , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_0_CASES" "LESS_0_CASES , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_EQ_SUC_LESS" "LESS_EQ_SUC_LESS , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_MONO_EQ" "LESS_MONO_EQ , LESS , NOT1 , 0";
addthmtextdep2 "LESS_MONO_REVF" "LESS_MONO_REVF , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LESS_MONO_REV" "LESS_MONO_REV , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LEQ_SUC" "LEQ_SUC , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_SUC_SUCF" "LESS_SUC_SUCF , LESS , NOT1 , 0";
addthmtextdep2 "LESS_SUC_SUC" "LESS_SUC_SUC , LESS , NOT1 , 0";
addthmtextdep2 "LESS_NOT_EQF" "LESS_NOT_EQF , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LESS_NOT_EQ" "LESS_NOT_EQ , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "EQ_NOT_LESSF" "EQ_NOT_LESSF , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "EQ_NOT_LESS" "EQ_NOT_LESS , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "SUC_EQ_LESSF" "SUC_EQ_LESSF , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "SUC_EQ_LESS" "SUC_EQ_LESS , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LESS_0F" "LESS_0F , LESS , NOT1 , 0";
addthmtextdep2 "LESS_0" "LESS_0 , LESS , NOT1 , 0";
addthmtextdep2 "FORALL_LESS_0" "FORALL_LESS_0 , forall , LESS , NOT1 , 0";
addthmtextdep2 "LESS_SUC_IMPF" "LESS_SUC_IMPF , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LESS_SUC_IMP" "LESS_SUC_IMP , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LESS_THM" "LESS_THM , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_LEMMA1F" "LESS_LEMMA1F , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "LESS_LEMMA1" "LESS_LEMMA1 , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "LESS_LEMMA2F" "LESS_LEMMA2F , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "LESS_LEMMA2" "LESS_LEMMA2 , LESS , NOT1 , OR , AND , IF , 0";
addthmtextdep2 "LESS_SUC_REFLF" "LESS_SUC_REFLF , LESS , NOT1 , 0";
addthmtextdep2 "LESS_SUC_REFL" "LESS_SUC_REFL , LESS , NOT1 , 0";
addthmtextdep2 "FORALL_LESS_SUC_REFL" "FORALL_LESS_SUC_REFL , forall , LESS , NOT1 , 0";
addthmtextdep2 "LESS_SUCF" "LESS_SUCF , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LESS_SUC" "LESS_SUC , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LESS_MONOF" "LESS_MONOF , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "LESS_MONO" "LESS_MONO , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "SUC_IDF" "SUC_IDF , 0";
addthmtextdep2 "SUC_ID" "SUC_ID , 0";
addthmtextdep2 "SUB_REFL" "SUB_REFL , 0";
addthmtextdep2 "LESS_0_0" "LESS_0_0 , LESS , NOT1 , 0";
addthmtextdep2 "LEQ_0" "LEQ_0 , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "NOT_LESS_0F" "NOT_LESS_0F , LESS , NOT1 , 0";
addthmtextdep2 "NOT_LESS_0" "NOT_LESS_0 , LESS , NOT1 , 0";
addthmtextdep2 "FNOT_LESS_0" "FNOT_LESS_0 , forall , LESS , NOT1 , 0";
addthmtextdep2 "ElimForall" "ElimForall , ASSERT2 , ASSERT , CID , AND , LEFT , LEFT1 , LEFT2 , RIGHT , RIGHT1 , RIGHT2 , INSTANTIATEF , forall , 0";
addthmtextdep2 "INSTANTIATEF" "INSTANTIATEF , forall , AND , 0";
addthmtextdep2 "RIGHT" "RIGHT , RIGHT1 , RIGHT2 , 0";
addthmtextdep2 "RIGHT2" "RIGHT2 , 0";
addthmtextdep2 "RIGHT1" "RIGHT1 , 0";
addthmtextdep2 "LEFT" "LEFT , LEFT1 , LEFT2 , 0";
addthmtextdep2 "LEFT2" "LEFT2 , 0";
addthmtextdep2 "LEFT1" "LEFT1 , 0";
addthmtextdep2 "CID" "CID , AND , ASSERT , 0";
addthmtextdep2 "ASSERT2" "ASSERT2 , ASSERT , 0";
addthmtextdep2 "SUC_LESS" "SUC_LESS , LESS , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "MP_THMF" "MP_THMF , forall , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "MP_THM" "MP_THM , forall , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "LESS_NOT_REFL" "LESS_NOT_REFL , LESS , NOT1 , 0";
addthmtextdep2 "LESSBOOL2" "LESSBOOL2 , LESS , NOT1 , ASSERT , 0";
addthmtextdep2 "LESSBOOL" "LESSBOOL , LESS , NOT1 , 0";
addthmtextdep2 "NATLESS2" "NATLESS2 , NATLESS , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "NATLESS" "NATLESS , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "NAT__SUB" "NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "NOT_LESS_THAN_SELF" "NOT_LESS_THAN_SELF , LESS , NOT1 , 0";
addthmtextdep2 "NATLESSSCIN" "NATLESSSCIN , NATLESS , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "MINUSSUCC_NAT" "MINUSSUCC_NAT , NATPLUS , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "NATPLUS" "NATPLUS , 0";
addthmtextdep2 "INDUCTION_NAT" "INDUCTION_NAT , forall , NATPLUS , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "PLUSSCIN_NAT" "PLUSSCIN_NAT , NATPLUS , 0";
addthmtextdep2 "ZEROMINUS_NAT" "ZEROMINUS_NAT , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "PLUSTYPE_NAT" "PLUSTYPE_NAT , NATPLUS , 0";
addthmtextdep2 "PLUSSUCC_NAT" "PLUSSUCC_NAT , NATPLUS , 0";
addthmtextdep2 "PLUSMINUS_NAT" "PLUSMINUS_NAT , NATPLUS , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "MINUSZERO_NAT" "MINUSZERO_NAT , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "NATSNONNEG" "NATSNONNEG , LESS , NOT1 , 0";
addthmtextdep2 "MINUSZERO2" "MINUSZERO2 , 0";
addthmtextdep2 "NOT_LEMMA" "NOT_LEMMA , ASSERT , NOT1 , 0";
addthmtextdep2 "ABSOLUTE_ONE" "ABSOLUTE_ONE , 0";
addthmtextdep2 "ABSOLUTE_ZERO" "ABSOLUTE_ZERO , 0";
addthmtextdep2 "PLUSID_NAT" "PLUSID_NAT , NATPLUS , 0";
addthmtextdep2 "SUCCNOTZERO_NAT" "SUCCNOTZERO_NAT , NATPLUS , 0";
addthmtextdep2 "MINUSCOMP" "MINUSCOMP , 0";
addthmtextdep2 "LESS_OR_EQ" "LESS_OR_EQ , LESS_EQ_REAL , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "GREATER_OR_EQ" "GREATER_OR_EQ , GREATER_EQ_REAL , GREATER , LESS , NOT1 , OR , AND , 0";
addthmtextdep2 "REAL_NOT_LESS" "REAL_NOT_LESS , LESS , NOT1 , LESS_EQ_REAL , OR , AND , 0";
addthmtextdep2 "DIFF_EQ" "DIFF_EQ , 0";
addthmtextdep2 "POS_SIGN" "POS_SIGN , NOT_EQ , NOT1 , Positive , AND , 0";
addthmtextdep2 "Positive" "Positive , NOT1 , AND , 0";
addthmtextdep2 "NOT_EQ" "NOT_EQ , NOT1 , 0";
addthmtextdep2 "REAL_LESS_CANCEL" "REAL_LESS_CANCEL , LESS , NOT1 , 0";
addthmtextdep2 "REAL_LESS_TRANS" "REAL_LESS_TRANS , LESS , NOT1 , AND , 0";
addthmtextdep2 "EQUATION_TO_DIFFERENCE" "EQUATION_TO_DIFFERENCE , 0";
addthmtextdep2 "X1" "X1 , RIGHT , RIGHT1 , RIGHT2 , ALLASSOCS , ASSOCS , PLUSASSOC , X , X2 , DIST , COMMDIST , TIMESASSOC , 0";
addthmtextdep2 "X2" "X1 , RIGHT , RIGHT1 , RIGHT2 , ALLASSOCS , ASSOCS , PLUSASSOC , X , X2 , DIST , COMMDIST , TIMESASSOC , 0";
addthmtextdep2 "X" "X1 , RIGHT , RIGHT1 , RIGHT2 , ALLASSOCS , ASSOCS , PLUSASSOC , X , X2 , DIST , COMMDIST , TIMESASSOC , 0";
addthmtextdep2 "TIMESASSOC" "TIMESASSOC , 0";
addthmtextdep2 "COMMDIST" "COMMDIST , 0";
addthmtextdep2 "DIST" "DIST , 0";
addthmtextdep2 "PLUSASSOC" "PLUSASSOC , 0";
addthmtextdep2 "ALLASSOCS" "RIGHT , RIGHT1 , RIGHT2 , ALLASSOCS , ASSOCS , 0";
addthmtextdep2 "ASSOCS" "ASSOCS , 0";
addthmtextdep2 "REAL_UNTYPE" "REAL_UNTYPE , EVERYWHERE_CASE , EVERYWHERE , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , REAL_UNTYPE_1 , TYPES , TREMBOTH , RIGHT , RIGHT1 , RIGHT2 , LEFT , LEFT1 , LEFT2 , (?x ** ?y) , (?x $ ?y) , PLUSTYPE , MINUSTYPE , TREMTOP , 0";
addthmtextdep2 "REAL_UNTYPE_1" "REAL_UNTYPE_1 , TYPES , TREMBOTH , RIGHT , RIGHT1 , RIGHT2 , LEFT , LEFT1 , LEFT2 , (?x ** ?y) , (?x $ ?y) , PLUSTYPE , MINUSTYPE , TREMTOP , 0";
addthmtextdep2 "TREMTOP" "TREMTOP , TYPES , RIGHT , RIGHT1 , RIGHT2 , 0";
addthmtextdep2 "MINUSTYPE" "MINUSTYPE , 0";
addthmtextdep2 "PLUSTYPE" "PLUSTYPE , 0";
addthmtextdep2 "TREMBOTH" "TREMBOTH , RIGHT , RIGHT1 , RIGHT2 , TYPES , LEFT , LEFT1 , LEFT2 , (?x ** ?y) , (?x $ ?y) , 0";
addthmtextdep2 "$" "(?x $ ?y) , 0";
addthmtextdep2 "**" "(?x ** ?y) , 0";
addthmtextdep2 "TYPES" "TYPES , 0";
addthmtextdep2 "EVERYWHERE" "EVERYWHERE_CASE , EVERYWHERE , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , 0";
addthmtextdep2 "EVERYWHERE_PREFIX" "EVERYWHERE_PREFIX , 0";
addthmtextdep2 "EVERYWHERE_INFIX" "EVERYWHERE_INFIX , 0";
addthmtextdep2 "EVERYWHERE_CASE" "EVERYWHERE_CASE , 0";
addthmtextdep2 "REAL_TYPE" "REAL_TYPE , EVERYWHERE_CASE , EVERYWHERE , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , TYPES , REAL_TYPE_1 , PLUSTYPE , MINUSTYPE , RIGHT , RIGHT1 , RIGHT2 , LEFT , LEFT1 , LEFT2 , REALZERO , (?x $ ?y) , (?x ** ?y) , REALNUMERAL , BUILTIN , REALNAT , TYPENUMERAL , MAKE_NAT_2 , MAKE_NAT_1 , REFLEX , 0";
addthmtextdep2 "REAL_TYPE_1" "REAL_TYPE_1 , PLUSTYPE , MINUSTYPE , RIGHT , RIGHT1 , RIGHT2 , LEFT , LEFT1 , LEFT2 , TYPES , REALZERO , (?x $ ?y) , (?x ** ?y) , REALNUMERAL , BUILTIN , REALNAT , TYPENUMERAL , MAKE_NAT_2 , MAKE_NAT_1 , REFLEX , 0";
addthmtextdep2 "REALNUMERAL" "REALNUMERAL , RIGHT , RIGHT1 , RIGHT2 , BUILTIN , (?x $ ?y) , REALNAT , TYPENUMERAL , MAKE_NAT_2 , MAKE_NAT_1 , REFLEX , 0";
addthmtextdep2 "TYPENUMERAL" "TYPENUMERAL , MAKE_NAT_2 , MAKE_NAT_1 , REFLEX , 0";
addthmtextdep2 "MAKE_NAT_1" "MAKE_NAT_1 , REFLEX , 0";
addthmtextdep2 "REFLEX" "REFLEX , 0";
addthmtextdep2 "MAKE_NAT_2" "MAKE_NAT_2 , 0";
addthmtextdep2 "REALNAT" "REALNAT , 0";
addthmtextdep2 "BUILTIN" "BUILTIN , 0";
addthmtextdep2 "REALZERO" "REALZERO , 0";
addthmtextdep2 "ALL_CANCEL" "ALL_CANCEL , TREMTOP , TYPES , RIGHT , RIGHT1 , RIGHT2 , MINUSTYPE , PLUSTYPE , ALL_CANCEL_5 , ALL_CANCEL_1 , ALL_CANCEL_4 , GETPLUS , GET1 , GET2 , LEFT , LEFT1 , LEFT2 , GET0 , GET , ASSOCS , PLUSCOMM , PLUSASSOC , ALL_CANCEL_6 , ALL_CANCEL_2 , ALL_CANCEL_3 , TREMRIGHT , (?x $ ?y) , (?x ** ?y) , ALL_CANCEL_7 , ALLASSOCS , EVERYWHERE_CASE , EVERYWHERE , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , TREMLEFT , BOTH_CASES , TOPDOWN_CASE , TOPDOWN , TOPDOWN_INFIX , RL , TOPDOWN_PREFIX , MINUSMINUS , PLUSINVDISTS , BREAKMINUS , FIXBREAKMINUS , 0";
addthmtextdep2 "FIXBREAKMINUS" "FIXBREAKMINUS , 0";
addthmtextdep2 "BREAKMINUS" "BREAKMINUS , 0";
addthmtextdep2 "PLUSINVDISTS" "PLUSINVDISTS , 0";
addthmtextdep2 "MINUSMINUS" "MINUSMINUS , 0";
addthmtextdep2 "TOPDOWN" "BOTH_CASES , TOPDOWN_CASE , TOPDOWN , TOPDOWN_INFIX , RL , TOPDOWN_PREFIX , RIGHT , RIGHT1 , RIGHT2 , 0";
addthmtextdep2 "TOPDOWN_PREFIX" "RIGHT , RIGHT1 , RIGHT2 , BOTH_CASES , TOPDOWN_CASE , TOPDOWN , TOPDOWN_INFIX , RL , TOPDOWN_PREFIX , 0";
addthmtextdep2 "TOPDOWN_INFIX" "RL , BOTH_CASES , TOPDOWN_CASE , TOPDOWN , TOPDOWN_INFIX , TOPDOWN_PREFIX , RIGHT , RIGHT1 , RIGHT2 , 0";
addthmtextdep2 "RL" "RL , 0";
addthmtextdep2 "TOPDOWN_CASE" "BOTH_CASES , TOPDOWN_CASE , TOPDOWN , TOPDOWN_INFIX , RL , TOPDOWN_PREFIX , RIGHT , RIGHT1 , RIGHT2 , 0";
addthmtextdep2 "BOTH_CASES" "BOTH_CASES , 0";
addthmtextdep2 "TREMLEFT" "TREMLEFT , RIGHT , RIGHT1 , RIGHT2 , LEFT , LEFT1 , LEFT2 , TYPES , (?x $ ?y) , (?x ** ?y) , 0";
addthmtextdep2 "ALL_CANCEL_7" "ALL_CANCEL_5 , ALL_CANCEL_1 , ALL_CANCEL_4 , GETPLUS , GET1 , GET2 , LEFT , LEFT1 , LEFT2 , GET0 , RIGHT , RIGHT1 , RIGHT2 , GET , ASSOCS , PLUSCOMM , PLUSASSOC , ALL_CANCEL_6 , ALL_CANCEL_2 , ALL_CANCEL_3 , TREMRIGHT , TYPES , (?x $ ?y) , (?x ** ?y) , PLUSTYPE , ALL_CANCEL_7 , ALLASSOCS , 0";
addthmtextdep2 "TREMRIGHT" "TREMRIGHT , RIGHT , RIGHT1 , RIGHT2 , TYPES , (?x $ ?y) , (?x ** ?y) , 0";
addthmtextdep2 "ALL_CANCEL_6" "ALL_CANCEL_6 , ALL_CANCEL_2 , ALL_CANCEL_3 , GETPLUS , GET1 , GET2 , LEFT , LEFT1 , LEFT2 , GET0 , RIGHT , RIGHT1 , RIGHT2 , GET , ASSOCS , PLUSCOMM , PLUSASSOC , 0";
addthmtextdep2 "ALL_CANCEL_3" "ALL_CANCEL_3 , 0";
addthmtextdep2 "ALL_CANCEL_2" "ALL_CANCEL_2 , 0";
addthmtextdep2 "ALL_CANCEL_5" "ALL_CANCEL_5 , ALL_CANCEL_1 , ALL_CANCEL_4 , GETPLUS , GET1 , GET2 , LEFT , LEFT1 , LEFT2 , GET0 , RIGHT , RIGHT1 , RIGHT2 , GET , ASSOCS , PLUSCOMM , PLUSASSOC , 0";
addthmtextdep2 "GETPLUS" "GETPLUS , GET1 , GET2 , LEFT , LEFT1 , LEFT2 , GET0 , RIGHT , RIGHT1 , RIGHT2 , GET , ASSOCS , PLUSCOMM , PLUSASSOC , 0";
addthmtextdep2 "PLUSCOMM" "PLUSCOMM , 0";
addthmtextdep2 "GET" "GET1 , GET2 , LEFT , LEFT1 , LEFT2 , GET0 , RIGHT , RIGHT1 , RIGHT2 , GET , ASSOCS , 0";
addthmtextdep2 "GET0" "GET0 , 0";
addthmtextdep2 "GET2" "GET2 , LEFT , LEFT1 , LEFT2 , 0";
addthmtextdep2 "GET1" "GET1 , 0";
addthmtextdep2 "ALL_CANCEL_4" "ALL_CANCEL_4 , 0";
addthmtextdep2 "ALL_CANCEL_1" "ALL_CANCEL_1 , 0";
addthmtextdep2 "ZEROORSUCC" "ZEROORSUCC , forall , forsome , NOT1 , OR , AND , 0";
addthmtextdep2 "POS_ZERO" "POS_ZERO , Positive , NOT1 , AND , 0";
addthmtextdep2 "POS_ONE" "POS_ONE , Positive , NOT1 , AND , 0";
addthmtextdep2 "SQUARE_POS" "SQUARE_POS , Positive , NOT1 , AND , OR , 0";
addthmtextdep2 "NOTBOTHPOS" "NOTBOTHPOS , Positive , NOT1 , AND , 0";
addthmtextdep2 "ZERONOTPOS" "ZERONOTPOS , Positive , NOT1 , AND , 0";
addthmtextdep2 "POSASSERT" "POSASSERT , Positive , NOT1 , AND , ASSERT , 0";
addthmtextdep2 "ALT_POS_DEF" "ALT_POS_DEF , Positive , NOT1 , AND , LESS , 0";
addthmtextdep2 "REAL_LESS_DEF" "REAL_LESS_DEF , LESS , NOT1 , Positive , AND , 0";
addthmtextdep2 "DISTANCEFLIP" "DISTANCEFLIP , 0";
addthmtextdep2 "MINUSFLIP" "MINUSFLIP , 0";
addthmtextdep2 "TRICHOTOMY" "TRICHOTOMY , Positive , NOT1 , AND , OR , 0";
addthmtextdep2 "POSTIMES" "POSTIMES , Positive , NOT1 , AND , 0";
addthmtextdep2 "POSPLUS" "POSPLUS , Positive , NOT1 , AND , 0";
addthmtextdep2 "POSTYPE" "POSTYPE , Positive , NOT1 , AND , 0";
addthmtextdep2 "REALABS" "REALABS , 0";
addthmtextdep2 "ABSREAL" "ABSREAL , 0";
addthmtextdep2 "ZEROSELFINV" "ZEROSELFINV , 0";
addthmtextdep2 "SUBTRACT_DIFF" "SUBTRACT_DIFF , 0";
addthmtextdep2 "MINUSZERO" "MINUSZERO , 0";
addthmtextdep2 "PLUSINVDIST" "PLUSINVDIST , 0";
addthmtextdep2 "SUBTRACT_SUM" "SUBTRACT_SUM , 0";
addthmtextdep2 "ADD_CANCEL" "ADD_CANCEL , 0";
addthmtextdep2 "MINUSPLUS" "MINUSPLUS , 0";
addthmtextdep2 "SIGNPULL" "SIGNPULL , 0";
addthmtextdep2 "PREDTYPE" "PREDTYPE , Pred , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "Pred" "Pred , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "PREDSCIN" "PREDSCIN , Pred , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "NATMINUSSCIN" "NATMINUSSCIN , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "NAT_SUB" "NAT_SUB , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "NATMINUSTYPE" "NATMINUSTYPE , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "NATMINUSCOMP" "NATMINUSCOMP , NAT__SUB , LESS , NOT1 , 0";
addthmtextdep2 "LESS1" "LESS1 , LESS , NOT1 , forsome , forall , IF , OR , AND , 0";
addthmtextdep2 "FINDGCD" "GCD1 , GCD2 , MOD_DEF , RIGHT , RIGHT1 , RIGHT2 , MODCOMP , FINDGCD , (?x ** ?y) , 0";
addthmtextdep2 "MODCOMP" "MODCOMP , MOD_DEF , 0";
addthmtextdep2 "GCD2" "GCD2 , MOD_DEF , 0";
addthmtextdep2 "MOD_DEF" "MOD_DEF , 0";
addthmtextdep2 "GCD1" "GCD1 , 0";
addthmtextdep2 "REALNUMERAL2" "REALNUMERAL2 , BUILTIN , REALNAT , RIGHT , RIGHT1 , RIGHT2 , TYPENUMERAL , MAKE_NAT_2 , MAKE_NAT_1 , REFLEX , 0";
addthmtextdep2 "GCD" "EQEVAL2 , BUILTIN , TYPES , GCD1 , GCD , MODCOMP , MOD_DEF , 0";
addthmtextdep2 "EQEVAL2" "EQEVAL2 , 0";
addthmtextdep2 "GCDTYPE" "GCDTYPE , 0";
addthmtextdep2 "odd" "odd , forsome , forall , NOT1 , 0";
addthmtextdep2 "even" "even , forsome , forall , NOT1 , 0";
addthmtextdep2 "INDUCT_TAC" "INDUCT_TAC , forall , INDUCT_TAC_2 , IF , NOT1 , OR , AND , INDUCT_TAC_1 , 0";
addthmtextdep2 "INDUCT_TAC_1" "INDUCT_TAC_1 , forall , 0";
addthmtextdep2 "INDUCT_TAC_2" "INDUCT_TAC_2 , forall , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "INDUCTION" "INDUCTION , forall , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "SAMESUCC" "SAMESUCC , 0";
addthmtextdep2 "SUCCNOTZERO" "SUCCNOTZERO , 0";
addthmtextdep2 "FACTORZERO" "FACTORZERO , OR , NOT1 , AND , 0";
addthmtextdep2 "TIMESZERO" "TIMESZERO , 0";
addthmtextdep2 "EPLUSID" "EPLUSID , PLUSID , COMMPLUSID , 0";
addthmtextdep2 "COMMPLUSID" "COMMPLUSID , 0";
addthmtextdep2 "PLUSID" "PLUSID , 0";
addthmtextdep2 "TIMESINTDIV" "TIMESINTDIV , MOD_DEF , INT_DIV , 0";
addthmtextdep2 "INT_DIV" "INT_DIV , 0";
addthmtextdep2 "NATCALC" "NATCALC , MAKE_NAT_2 , MAKE_NAT_1 , REFLEX , 0";
addthmtextdep2 "DIVSCIN" "DIVSCIN , 0";
addthmtextdep2 "ZERONOTONE" "ZERONOTONE , 0";
addthmtextdep2 "EVALEQ" "EVALEQ , 0";
addthmtextdep2 "LESSTYPE" "LESSTYPE , LESS , NOT1 , 0";
addthmtextdep2 "MODSCIN" "MODSCIN , MOD_DEF , 0";
addthmtextdep2 "MODTYPE" "MODTYPE , MOD_DEF , 0";
addthmtextdep2 "INT_DIVSCIN" "INT_DIVSCIN , INT_DIV , 0";
addthmtextdep2 "INT_DIVTYPE" "INT_DIVTYPE , INT_DIV , 0";
addthmtextdep2 "TIMESSCIN" "TIMESSCIN , 0";
addthmtextdep2 "TIMESCOMP" "TIMESCOMP , 0";
addthmtextdep2 "TIMESTYPE2" "TIMESTYPE2 , 0";
addthmtextdep2 "MINUSSCIN" "MINUSSCIN , 0";
addthmtextdep2 "PLUSSCIN" "PLUSSCIN , 0";
addthmtextdep2 "PLUSCOMP" "PLUSCOMP , 0";
addthmtextdep2 "PLUSTYPE2" "PLUSTYPE2 , 0";
addthmtextdep2 "ZERONAT" "ZERONAT , 0";
addthmtextdep2 "ONENAT" "ONENAT , 0";
addthmtextdep2 "EQ_COMP" "EQ_COMP , 0";
addthmtextdep2 "LESSCOMP" "LESSCOMP , LESS , NOT1 , 0";
addthmtextdep2 "LESS_COMP" "LESS_COMP , LESS , NOT1 , 0";
addthmtextdep2 "ABSOLUTE2" "ABSOLUTE2 , 0";
addthmtextdep2 "ABSOLUTE" "ABSOLUTE , 0";
addthmtextdep2 "TIMES_POS" "TIMES_POS , 0";
addthmtextdep2 "PLUS_POS" "PLUS_POS , 0";
addthmtextdep2 "TIMESDIV" "TIMESDIV , 0";
addthmtextdep2 "TD" "TD , 0";
addthmtextdep2 "TIMESID" "TIMESID , 0";
addthmtextdep2 "TIMESCOMM" "TIMESCOMM , 0";
addthmtextdep2 "DIVTYPE" "DIVTYPE , 0";
addthmtextdep2 "TIMESTYPE" "TIMESTYPE , 0";
addthmtextdep2 "PLUSMINUS" "PLUSMINUS , 0";
addthmtextdep2 "PM" "PM , 0";
addthmtextdep2 "COMP_DIV" "COMP_DIV , 0";
addthmtextdep2 "COMP_TIMES" "COMP_TIMES , 0";
addthmtextdep2 "COMP_MINUS" "COMP_MINUS , 0";
addthmtextdep2 "COMP_PLUS" "COMP_PLUS , 0";
addthmtextdep2 "COMPLESSTYPE" "COMPLESSTYPE , Bool , 0";
addthmtextdep2 "Bool" "Bool , 0";
addthmtextdep2 "COMPEQTYPE" "COMPEQTYPE , Bool , 0";
addthmtextdep2 "COMPMODTYPE" "COMPMODTYPE , 0";
addthmtextdep2 "COMPDIVTYPE" "COMPDIVTYPE , 0";
addthmtextdep2 "COMPTIMESTYPE" "COMPTIMESTYPE , 0";
addthmtextdep2 "COMPMINUSTYPE" "COMPMINUSTYPE , 0";
addthmtextdep2 "COMPPLUSTYPE" "COMPPLUSTYPE , 0";
addthmtextdep2 "MAKE_NAT" "MAKE_NAT , MAKE_NAT_2 , MAKE_NAT_1 , REFLEX , 0";
addthmtextdep2 "COMP_NAT_2" "COMP_NAT_2 , COMP_NAT , 0";
addthmtextdep2 "COMP_NAT" "COMP_NAT , 0";
addthmtextdep2 "True" "True , 0";
addthmtextdep2 "TRUERETRACT" "TRUERETRACT , 0";
addthmtextdep2 "BOOL_RETRACT" "BOOL_RETRACT , 0";
addthmtextdep2 "POINTTYPE" "POINTTYPE , 0";
addthmtextdep2 "UNIONTYPE" "UNIONTYPE , 0";
addthmtextdep2 "UNIONRETRACT" "UNIONRETRACT , 0";
addthmtextdep2 "PRODTYPE" "PRODTYPE , P1 , P2 , 0";
addthmtextdep2 "P2" "P2 , 0";
addthmtextdep2 "P1" "P1 , 0";
addthmtextdep2 "PRODRETRACT" "PRODRETRACT , P1 , P2 , 0";
addthmtextdep2 "ARROWTYPE" "ARROWTYPE , 0";
addthmtextdep2 "ARROWRETRACT" "ARROWRETRACT , 0";
addthmtextdep2 "TADDTOP" "TADDTOP , TYPES , (?x $ ?y) , RIGHT , RIGHT1 , RIGHT2 , (?x ** ?y) , 0";
addthmtextdep2 "TADDBOTH" "TADDBOTH , RIGHT , RIGHT1 , RIGHT2 , TYPES , (?x $ ?y) , LEFT , LEFT1 , LEFT2 , (?x ** ?y) , 0";
addthmtextdep2 "TADDRIGHT" "TADDRIGHT , RIGHT , RIGHT1 , RIGHT2 , TYPES , (?x $ ?y) , (?x ** ?y) , 0";
addthmtextdep2 "TADDLEFT" "TADDLEFT , RIGHT , RIGHT1 , RIGHT2 , LEFT , LEFT1 , LEFT2 , TYPES , (?x $ ?y) , (?x ** ?y) , 0";
addthmtextdep2 "Complement2" "Complement2 , Complement , IN , ASSERT , NOT1 , 0";
addthmtextdep2 "Complement" "Complement , IN , ASSERT , NOT1 , 0";
addthmtextdep2 "IN" "IN , ASSERT , 0";
addthmtextdep2 "Subset2" "Subset2 , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "Subset" "Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "SetDifference2" "SetDifference2 , SetDifference , IN , ASSERT , NOT1 , AND , 0";
addthmtextdep2 "SetDifference" "SetDifference , IN , ASSERT , NOT1 , AND , 0";
addthmtextdep2 "Intersection2" "Intersection2 , Intersection , IN , ASSERT , AND , 0";
addthmtextdep2 "Intersection" "Intersection , IN , ASSERT , AND , 0";
addthmtextdep2 "Union2" "Union2 , Union , IN , ASSERT , OR , NOT1 , AND , 0";
addthmtextdep2 "Union" "Union , IN , ASSERT , OR , NOT1 , AND , 0";
addthmtextdep2 "SetEquiv2" "SetEquiv2 , SetEquiv , forall , IN , ASSERT , IFF , 0";
addthmtextdep2 "SetEquiv" "SetEquiv , forall , IN , ASSERT , IFF , 0";
addthmtextdep2 "IFF" "IFF , 0";
addthmtextdep2 "DiffSymmDisj" "DiffSymmDisj , SetDifference , IN , ASSERT , NOT1 , AND , Disjoint , Intersection , SetEquiv , forall , IFF , 0";
addthmtextdep2 "Disjoint" "Disjoint , Intersection , IN , ASSERT , AND , SetEquiv , forall , IFF , 0";
addthmtextdep2 "UnionDisj" "UnionDisj , Union , IN , ASSERT , OR , NOT1 , AND , Disjoint , Intersection , SetEquiv , forall , IFF , 0";
addthmtextdep2 "Disj_NotForsome" "Disj_NotForsome , Disjoint , Intersection , IN , ASSERT , AND , SetEquiv , forall , IFF , forsome , NOT1 , 0";
addthmtextdep2 "DisjIdem" "DisjIdem , Disjoint , Intersection , IN , ASSERT , AND , SetEquiv , forall , IFF , 0";
addthmtextdep2 "DisjEmpty" "DisjEmpty , Disjoint , Intersection , IN , ASSERT , AND , SetEquiv , forall , IFF , 0";
addthmtextdep2 "EmptyDisj" "EmptyDisj , Disjoint , Intersection , IN , ASSERT , AND , SetEquiv , forall , IFF , 0";
addthmtextdep2 "DisjUniv" "DisjUniv , Disjoint , Intersection , IN , ASSERT , AND , SetEquiv , forall , IFF , 0";
addthmtextdep2 "UnivDisj" "UnivDisj , Disjoint , Intersection , IN , ASSERT , AND , SetEquiv , forall , IFF , 0";
addthmtextdep2 "DisjSymm" "DisjSymm , Disjoint , Intersection , IN , ASSERT , AND , SetEquiv , forall , IFF , 0";
addthmtextdep2 "DisjScin" "DisjScin , Disjoint , Intersection , IN , ASSERT , AND , SetEquiv , forall , IFF , Set , 0";
addthmtextdep2 "Set" "Set , ASSERT , 0";
addthmtextdep2 "DisjType" "DisjType , Disjoint , Intersection , IN , ASSERT , AND , SetEquiv , forall , IFF , Set , 0";
addthmtextdep2 "SubsetNotPsubset" "SubsetNotPsubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , Psubset , SetEquiv , IFF , 0";
addthmtextdep2 "Psubset" "Psubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , 0";
addthmtextdep2 "PsubsetNotSubset" "PsubsetNotSubset , Psubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , 0";
addthmtextdep2 "PsubsetSubset" "PsubsetSubset , Psubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , 0";
addthmtextdep2 "PsubsetUniv" "PsubsetUniv , Psubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , forsome , 0";
addthmtextdep2 "UnivPsubset" "UnivPsubset , Psubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , 0";
addthmtextdep2 "EmptyPsubset" "EmptyPsubset , Psubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , 0";
addthmtextdep2 "PsubsetEmpty" "PsubsetEmpty , Psubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , 0";
addthmtextdep2 "PsubsetIdem" "PsubsetIdem , Psubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , 0";
addthmtextdep2 "PsubsetScin" "PsubsetScin , Psubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , Set , 0";
addthmtextdep2 "PsubsetType" "PsubsetType , Psubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , Set , 0";
addthmtextdep2 "DiffSubset" "DiffSubset , SetDifference , IN , ASSERT , NOT1 , AND , Subset , forall , IF , OR , 0";
addthmtextdep2 "Subset_InterAbsorption" "Subset_InterAbsorption , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , Intersection , SetEquiv , IFF , 0";
addthmtextdep2 "InterSymmSubset" "InterSymmSubset , Intersection , IN , ASSERT , AND , Subset , forall , IF , NOT1 , OR , 0";
addthmtextdep2 "InterSubset" "InterSubset , Intersection , IN , ASSERT , AND , Subset , forall , IF , NOT1 , OR , 0";
addthmtextdep2 "SubsetUnionSymm" "SubsetUnionSymm , Union , IN , ASSERT , OR , NOT1 , AND , Subset , forall , IF , 0";
addthmtextdep2 "SubsetUnion" "SubsetUnion , Union , IN , ASSERT , OR , NOT1 , AND , Subset , forall , IF , 0";
addthmtextdep2 "Subset_UnionAbsorption" "Subset_UnionAbsorption , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , Union , SetEquiv , IFF , 0";
addthmtextdep2 "UnivSubset" "UnivSubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , 0";
addthmtextdep2 "SubsetUniv" "SubsetUniv , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "SubsetEmpty" "SubsetEmpty , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , 0";
addthmtextdep2 "EmptySubset" "EmptySubset , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "SubsetAntisym" "SubsetAntisym , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , SetEquiv , IFF , 0";
addthmtextdep2 "SubsetIdem" "SubsetIdem , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "SubsetTrans" "SubsetTrans , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "FORALL_3pt82a" "FORALL_3pt82a , forall , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "SubsetScin" "SubsetScin , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , Set , 0";
addthmtextdep2 "SubsetType" "SubsetType , Subset , forall , IN , ASSERT , IF , NOT1 , OR , AND , Set , 0";
addthmtextdep2 "InDiff" "InDiff , SetDifference , IN , ASSERT , NOT1 , AND , 0";
addthmtextdep2 "DiffInter_Union" "DiffInter_Union , Intersection , IN , ASSERT , AND , SetDifference , NOT1 , Union , OR , 0";
addthmtextdep2 "DiffUnion" "DiffUnion , Union , IN , ASSERT , OR , NOT1 , AND , SetDifference , Intersection , 0";
addthmtextdep2 "UnionDiff_absorption" "UnionDiff_absorption , SetDifference , IN , ASSERT , NOT1 , AND , Union , OR , 0";
addthmtextdep2 "InterDiff_Empty" "InterDiff_Empty , SetDifference , IN , ASSERT , NOT1 , AND , Intersection , 0";
addthmtextdep2 "Diff_InterCompl" "Diff_InterCompl , SetDifference , IN , ASSERT , NOT1 , AND , Complement , Intersection , 0";
addthmtextdep2 "DiffInter" "DiffInter , SetDifference , IN , ASSERT , NOT1 , AND , Intersection , 0";
addthmtextdep2 "DiffSymm" "DiffSymm , SetDifference , IN , ASSERT , NOT1 , AND , 0";
addthmtextdep2 "DiffIdem" "DiffIdem , SetDifference , IN , ASSERT , NOT1 , AND , 0";
addthmtextdep2 "UnivDiff" "UnivDiff , SetDifference , IN , ASSERT , NOT1 , AND , Complement , 0";
addthmtextdep2 "DiffUniv" "DiffUniv , SetDifference , IN , ASSERT , NOT1 , AND , 0";
addthmtextdep2 "EmptyDiff" "EmptyDiff , SetDifference , IN , ASSERT , NOT1 , AND , 0";
addthmtextdep2 "DiffEmpty" "DiffEmpty , SetDifference , IN , ASSERT , NOT1 , AND , Set , 0";
addthmtextdep2 "DubDiff" "DubDiff , SetDifference , IN , ASSERT , NOT1 , AND , 0";
addthmtextdep2 "DiffScin" "DiffScin , SetDifference , IN , ASSERT , NOT1 , AND , Set , 0";
addthmtextdep2 "DiffType" "DiffType , SetDifference , IN , ASSERT , NOT1 , AND , Set , 0";
addthmtextdep2 "InInter" "InInter , Intersection , IN , ASSERT , AND , 0";
addthmtextdep2 "UnionUniv_InterEmpty" "UnionUniv_InterEmpty , Union , IN , ASSERT , OR , NOT1 , AND , SetEquiv , forall , IFF , Intersection , Complement , 0";
addthmtextdep2 "DEMORGANb" "DEMORGANb , Intersection , IN , ASSERT , AND , Complement , NOT1 , Union , OR , 0";
addthmtextdep2 "DEMORGANa" "DEMORGANa , Union , IN , ASSERT , OR , NOT1 , AND , Complement , Intersection , 0";
addthmtextdep2 "InterCompl" "InterCompl , Complement , IN , ASSERT , NOT1 , Intersection , AND , 0";
addthmtextdep2 "UnionInter" "UnionInter , Intersection , IN , ASSERT , AND , Union , OR , NOT1 , 0";
addthmtextdep2 "InterUnion" "InterUnion , Union , IN , ASSERT , OR , NOT1 , AND , Intersection , 0";
addthmtextdep2 "InterEqEmpty" "InterEqEmpty , Intersection , IN , ASSERT , AND , SetEquiv , forall , IFF , NOT1 , IF , OR , 0";
addthmtextdep2 "InterUniv" "InterUniv , Intersection , IN , ASSERT , AND , Set , 0";
addthmtextdep2 "UnivInter" "UnivInter , Intersection , IN , ASSERT , AND , Set , 0";
addthmtextdep2 "InterEmpty" "InterEmpty , Intersection , IN , ASSERT , AND , 0";
addthmtextdep2 "EmptyInter" "EmptyInter , Intersection , IN , ASSERT , AND , 0";
addthmtextdep2 "InterIdem" "InterIdem , Intersection , IN , ASSERT , AND , Set , 0";
addthmtextdep2 "InterAssoc" "InterAssoc , Intersection , IN , ASSERT , AND , 0";
addthmtextdep2 "InterSymm" "InterSymm , Intersection , IN , ASSERT , AND , 0";
addthmtextdep2 "InterScin" "InterScin , Intersection , IN , ASSERT , AND , Set , 0";
addthmtextdep2 "InterType" "InterType , Intersection , IN , ASSERT , AND , Set , 0";
addthmtextdep2 "InUnion" "InUnion , Union , IN , ASSERT , OR , NOT1 , AND , 0";
addthmtextdep2 "UnionEqUniv" "UnionEqUniv , Union , IN , ASSERT , OR , NOT1 , AND , SetEquiv , forall , IFF , IF , 0";
addthmtextdep2 "UnionEqEmpty" "UnionEqEmpty , Union , IN , ASSERT , OR , NOT1 , AND , SetEquiv , forall , IFF , 0";
addthmtextdep2 "UnionCompl" "UnionCompl , Complement , IN , ASSERT , NOT1 , Union , OR , AND , 0";
addthmtextdep2 "UnionEmpty" "UnionEmpty , Union , IN , ASSERT , OR , NOT1 , AND , Set , 0";
addthmtextdep2 "EmptyUnion" "EmptyUnion , Union , IN , ASSERT , OR , NOT1 , AND , Set , 0";
addthmtextdep2 "UnionUniv" "UnionUniv , Union , IN , ASSERT , OR , NOT1 , AND , 0";
addthmtextdep2 "UnivUnion" "UnivUnion , Union , IN , ASSERT , OR , NOT1 , AND , 0";
addthmtextdep2 "UnionIdem" "UnionIdem , Union , IN , ASSERT , OR , NOT1 , AND , Set , 0";
addthmtextdep2 "UnionAssoc" "UnionAssoc , Union , IN , ASSERT , OR , NOT1 , AND , 0";
addthmtextdep2 "UnionSymm" "UnionSymm , Union , IN , ASSERT , OR , NOT1 , AND , 0";
addthmtextdep2 "UnionScin" "UnionScin , Union , IN , ASSERT , OR , NOT1 , AND , Set , 0";
addthmtextdep2 "UnionType" "UnionType , Union , IN , ASSERT , OR , NOT1 , AND , Set , 0";
addthmtextdep2 "InCompl" "InCompl , Complement , IN , ASSERT , NOT1 , 0";
addthmtextdep2 "ComplEmpty_Univ" "ComplEmpty_Univ , Complement , IN , ASSERT , NOT1 , SetEquiv , forall , IFF , 0";
addthmtextdep2 "ComplUniv_Empty" "ComplUniv_Empty , Complement , IN , ASSERT , NOT1 , SetEquiv , forall , IFF , 0";
addthmtextdep2 "EqCompl" "EqCompl , Complement , IN , ASSERT , NOT1 , SetEquiv , forall , IFF , 0";
addthmtextdep2 "ComplEq" "ComplEq , Complement , IN , ASSERT , NOT1 , SetEquiv , forall , IFF , 0";
addthmtextdep2 "ComplEqUniv" "ComplEqUniv , Complement , IN , ASSERT , NOT1 , SetEquiv , forall , IFF , 0";
addthmtextdep2 "ComplUniv" "ComplUniv , Complement , IN , ASSERT , NOT1 , 0";
addthmtextdep2 "ComplEmpty" "ComplEmpty , Complement , IN , ASSERT , NOT1 , 0";
addthmtextdep2 "DubComplement" "DubComplement , Complement , IN , ASSERT , NOT1 , Set , 0";
addthmtextdep2 "EqEmpty" "EqEmpty , SetEquiv , forall , IN , ASSERT , IFF , NOT1 , 0";
addthmtextdep2 "NotEqEmpty" "NotEqEmpty , SetEquiv , forall , IN , ASSERT , IFF , NOT1 , forsome , 0";
addthmtextdep2 "EqUniv" "EqUniv , SetEquiv , forall , IN , ASSERT , IFF , 0";
addthmtextdep2 "NotEq" "NotEq , SetEquiv , forall , IN , ASSERT , IFF , NOT1 , forsome , 0";
addthmtextdep2 "EmptyNotUniv" "EmptyNotUniv , SetEquiv , forall , IN , ASSERT , IFF , 0";
addthmtextdep2 "UnivNotEmpty" "UnivNotEmpty , SetEquiv , forall , IN , ASSERT , IFF , 0";
addthmtextdep2 "EquivSymm" "EquivSymm , SetEquiv , forall , IN , ASSERT , IFF , 0";
addthmtextdep2 "EquivType" "EquivType , SetEquiv , forall , IN , ASSERT , IFF , Set , 0";
addthmtextdep2 "EquivBool" "EquivBool , SetEquiv , forall , IN , ASSERT , IFF , 0";
addthmtextdep2 "InUniv" "InUniv , IN , ASSERT , 0";
addthmtextdep2 "InEmpty" "InEmpty , IN , ASSERT , 0";
addthmtextdep2 "ReverseIn" "ReverseIn , ASSERT , IN , RIGHT , RIGHT1 , RIGHT2 , 0";
addthmtextdep2 "ApplyIn" "ApplyIn , IN , ASSERT , RIGHT , RIGHT1 , RIGHT2 , (?x ** ?y) , 0";
addthmtextdep2 "InType" "InType , IN , ASSERT , Set , 0";
addthmtextdep2 "INBOOL" "INBOOL , IN , ASSERT , 0";
addthmtextdep2 "EmptySet" "EmptySet , Set , ASSERT , 0";
addthmtextdep2 "TrueSet" "TrueSet , Set , ASSERT , 0";
addthmtextdep2 "SETRETRACT" "SETRETRACT , Set , ASSERT , 0";
addthmtextdep2 "FS_SEQUENT" "IGNOREFIRST , FS1 , FS0 , FS_SEQUENT , FS2 , forall , FS0b , FS5 , AND , CID , ASSERT , AT , (?x ** ?y) , FS3 , FS4 , FS6 , 0";
addthmtextdep2 "FS6" "FS6 , AND , IGNOREFIRST , CID , ASSERT , AT , (?x ** ?y) , FS0 , 0";
addthmtextdep2 "FS4" "FS4 , forall , AND , IGNOREFIRST , CID , ASSERT , AT , (?x ** ?y) , FS0 , FS0b , 0";
addthmtextdep2 "FS3" "FS3 , forall , AND , IGNOREFIRST , CID , ASSERT , AT , (?x ** ?y) , FS0b , FS0 , 0";
addthmtextdep2 "FS5" "FS5 , forall , AND , IGNOREFIRST , CID , ASSERT , AT , (?x ** ?y) , FS0b , FS0 , 0";
addthmtextdep2 "AT" "AT , ASSERT , 0";
addthmtextdep2 "FS2" "FS2 , forall , IGNOREFIRST , FS0b , FS0 , 0";
addthmtextdep2 "FS0b" "FS0b , forall , 0";
addthmtextdep2 "FS1" "FS1 , IGNOREFIRST , FS0 , 0";
addthmtextdep2 "FS0" "FS0 , IGNOREFIRST , 0";
addthmtextdep2 "IGNOREFIRST" "IGNOREFIRST , 0";
addthmtextdep2 "SETUP_SEQUENT" "SETUP_SEQUENT , ASSERT , OR , NOT1 , AND , IF , 0";
addthmtextdep2 "INR" "INR , IN , ASSERT , OR , NOT1 , AND , IF , IGNOREFIRST , 0";
addthmtextdep2 "INL" "INL , IN , ASSERT , AND , IF , NOT1 , OR , IGNOREFIRST , 0";
addthmtextdep2 "INSCOUT" "INSCOUT , IN , ASSERT , 0";
addthmtextdep2 "EXISTR" "EXISTR , forsome , forall , NOT1 , OR , AND , IF , IGNOREFIRST , 0";
addthmtextdep2 "EXISTL" "EXISTL , forsome , forall , NOT1 , AND , IF , OR , IGNOREFIRST , 0";
addthmtextdep2 "FORSOMEANDDIST" "FORSOMEANDDIST , forsome , forall , NOT1 , AND , 0";
addthmtextdep2 "UNIVR" "UNIVR , forall , OR , NOT1 , AND , IF , IGNOREFIRST , 0";
addthmtextdep2 "UNIVL" "UNIVL , forall , AND , IF , NOT1 , OR , IGNOREFIRST , 0";
addthmtextdep2 "CUT" "CUT , IF , NOT1 , OR , AND , IGNOREFIRST , 0";
addthmtextdep2 "IFFR" "IFFR , IFF , OR , NOT1 , AND , IF , IGNOREFIRST , 0";
addthmtextdep2 "IFFL" "IFFL , IFF , AND , IF , NOT1 , OR , IGNOREFIRST , 0";
addthmtextdep2 "WEAKR" "WEAKR , OR , NOT1 , AND , IF , IGNOREFIRST , 0";
addthmtextdep2 "WEAKL" "WEAKL , AND , IF , NOT1 , OR , IGNOREFIRST , 0";
addthmtextdep2 "EXR" "EXR , IF , NOT1 , OR , AND , GETR , GET1 , GET2 , LEFT , LEFT1 , LEFT2 , GET0 , RIGHT , RIGHT1 , RIGHT2 , GET , ASSOCS , DSYM , DASSOC , IGNOREFIRST , 0";
addthmtextdep2 "GETR" "GETR , OR , NOT1 , AND , GET1 , GET2 , LEFT , LEFT1 , LEFT2 , GET0 , RIGHT , RIGHT1 , RIGHT2 , GET , ASSOCS , DSYM , DASSOC , 0";
addthmtextdep2 "DASSOC" "DASSOC , OR , NOT1 , AND , 0";
addthmtextdep2 "DSYM" "DSYM , OR , NOT1 , AND , 0";
addthmtextdep2 "EXL" "EXL , IF , NOT1 , OR , AND , GETL , GET1 , GET2 , LEFT , LEFT1 , LEFT2 , GET0 , RIGHT , RIGHT1 , RIGHT2 , GET , ASSOCS , CSYM , CASSOC , IGNOREFIRST , 0";
addthmtextdep2 "GETL" "GETL , AND , GET1 , GET2 , LEFT , LEFT1 , LEFT2 , GET0 , RIGHT , RIGHT1 , RIGHT2 , GET , ASSOCS , CSYM , CASSOC , 0";
addthmtextdep2 "CASSOC" "CASSOC , AND , 0";
addthmtextdep2 "CSYM" "CSYM , AND , 0";
addthmtextdep2 "AXIOM" "AXIOM , AND , OR , NOT1 , IF , IGNOREFIRST , 0";
addthmtextdep2 "IFR" "IFR , IF , NOT1 , OR , AND , IGNOREFIRST , 0";
addthmtextdep2 "IFL" "IFL , IF , NOT1 , OR , AND , IGNOREFIRST , 0";
addthmtextdep2 "ORR" "ORR , OR , NOT1 , AND , IF , IGNOREFIRST , 0";
addthmtextdep2 "ORL" "ORL , OR , NOT1 , AND , IF , IGNOREFIRST , 0";
addthmtextdep2 "ANDR" "ANDR , AND , OR , NOT1 , IF , IGNOREFIRST , 0";
addthmtextdep2 "ANDL" "ANDL , AND , IF , NOT1 , OR , IGNOREFIRST , 0";
addthmtextdep2 "NEGR" "NEGR , NOT1 , OR , AND , IF , IGNOREFIRST , 0";
addthmtextdep2 "NEGL" "NEGL , NOT1 , AND , IF , OR , IGNOREFIRST , 0";
addthmtextdep2 "SELFLABEL" "SELFLABEL , IGNOREFIRST , 0";
addthmtextdep2 "UNIV_EQ_TAC" "UNIV_EQ_TAC , forall , LEFT , LEFT1 , LEFT2 , UNIV_EQ , (?x $ ?y) , EVERYWHERE_CASE , EVERYWHERE , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , 0";
addthmtextdep2 "UNIV_EQ" "UNIV_EQ , forall , 0";
addthmtextdep2 "UNIV_TAC" "UNIV_TAC , forall , LEFT , LEFT1 , LEFT2 , (?x $ ?y) , LEFT_CASE , STRONG_EVERYWHERE_CASE , EVERYWHERE2 , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , EVERYWHERE_ABS , PIVOT , HYP , 0";
addthmtextdep2 "PIVOT" "PIVOT , LEFT_CASE , HYP , 0";
addthmtextdep2 "HYP" "HYP , 0";
addthmtextdep2 "EVERYWHERE2" "STRONG_EVERYWHERE_CASE , EVERYWHERE2 , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , EVERYWHERE_ABS , 0";
addthmtextdep2 "EVERYWHERE_ABS" "EVERYWHERE_ABS , 0";
addthmtextdep2 "STRONG_EVERYWHERE_CASE" "STRONG_EVERYWHERE_CASE , 0";
addthmtextdep2 "LEFT_CASE" "LEFT_CASE , 0";
addthmtextdep2 "9pt26" "9pt26 , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "forsomer" "forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "forallr" "forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt25" "9pt25 , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt24" "9pt24 , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt23" "9pt23 , forsome , forall , NOT1 , forsomer , forallr , P1 , P2 , IF , OR , AND , IFF , 0";
addthmtextdep2 "9pt22" "9pt22 , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , forsome , 0";
addthmtextdep2 "9pt21" "9pt21 , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt20" "9pt20 , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt18c" "9pt18c , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt18b" "9pt18b , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt18a" "9pt18a , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt11" "9pt11 , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt10" "9pt10 , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt8" "9pt8 , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt7" "9pt7 , forall , NOT1 , forallr , P1 , P2 , IF , OR , AND , IFF , 0";
addthmtextdep2 "9pt6" "9pt6 , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt5" "9pt5 , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt4d" "9pt4d , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "9pt4c" "9pt4c , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "9pt4b" "9pt4b , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt4a" "9pt4a , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "9pt3c" "9pt3c , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "9pt3b" "9pt3b , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "9pt3a" "9pt3a , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "8pt19E" "8pt19E , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "8pt19U" "8pt19U , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "8pt16E" "8pt16E , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "8pt16U" "8pt16U , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "8pt15E" "8pt15E , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "8pt15U" "8pt15U , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "8pt13E" "8pt13E , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "8pt13U" "8pt13U , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "FORSOMERBOOL3" "FORSOMERBOOL3 , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "FORSOMERBOOL2" "FORSOMERBOOL2 , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "FORALLRBOOL3" "FORALLRBOOL3 , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "FORALLRBOOL2" "FORALLRBOOL2 , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "UNIV_RANGE_2" "UNIV_RANGE_2 , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , forsome , 0";
addthmtextdep2 "8pt14E" "8pt14E , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , ASSERT , 0";
addthmtextdep2 "L" "L , LEFT1 , LEFT2 , 0";
addthmtextdep2 "R" "R , RIGHT1 , RIGHT2 , 0";
addthmtextdep2 "8pt14U" "8pt14U , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , ASSERT , 0";
addthmtextdep2 "9pt30b" "9pt30b , forsome , forall , NOT1 , IF , OR , AND , FORALLDROP , ASSERT , AT , (?x ** ?y) , 0";
addthmtextdep2 "FORALLDROP" "FORALLDROP , forall , ASSERT , 0";
addthmtextdep2 "9pt30a" "9pt30a , IF , NOT1 , OR , AND , LEFT , LEFT1 , LEFT2 , forsome , forall , 0";
addthmtextdep2 "9pt16b" "9pt16b , forall , FORALLDROP , ASSERT , AT , (?x ** ?y) , 0";
addthmtextdep2 "9pt16a" "9pt16a , 9pt16a1 , LEFT , LEFT1 , LEFT2 , forall , 0";
addthmtextdep2 "9pt16a1" "9pt16a1 , LEFT , LEFT1 , LEFT2 , forall , 0";
addthmtextdep2 "PRE9pt12" "PRE9pt12 , forall , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "CONVERT_IMP_2" "CONVERT_IMP_2 , ASSERT , CRULE1 , AND , DID , OR , NOT1 , FDEF , IF , 0";
addthmtextdep2 "FDEF" "FDEF , NOT1 , 0";
addthmtextdep2 "DID" "DID , OR , NOT1 , AND , ASSERT , 0";
addthmtextdep2 "CRULE1" "CRULE1 , AND , ASSERT , 0";
addthmtextdep2 "CONVERT_IMP_1" "CONVERT_IMP_1 , IF , NOT1 , OR , AND , 3pt76b , LEFT , LEFT1 , LEFT2 , IRULE2 , ASSERT , (?x $ ?y) , 0";
addthmtextdep2 "IRULE2" "IRULE2 , ASSERT , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt76b" "3pt76b , AND , IF , NOT1 , OR , 0";
addthmtextdep2 "ONEPOINT" "ONEPOINT , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , ASSERT , 0";
addthmtextdep2 "UNIV_RANGE_1" "UNIV_RANGE_1 , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "forsomer3" "forsomer3 , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , forsome , 0";
addthmtextdep2 "forsomer2" "forsomer2 , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "FORSOMERBOOL" "FORSOMERBOOL , forsomer , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "forallr2" "forallr2 , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "FORALLRBOOL" "FORALLRBOOL , forallr , forall , P1 , P2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "EQ_TRANS" "EQ_TRANS , AND , IF , NOT1 , OR , 0";
addthmtextdep2 "COMMUTE_LEVEL_QUANT" "COMMUTE_LEVEL_QUANT , forall , IFF , 0";
addthmtextdep2 "ALT_QUANT_AGAIN" "ALT_QUANT_AGAIN , forsome , forall , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "TAB_CEX" "TAB_CEX , forall , ODDCHOICE , BOOLDEF , CEX_TAC , COUNTER1 , NOT1 , 0";
addthmtextdep2 "CEX_TAC" "CEX_TAC , forall , COUNTER1 , NOT1 , 0";
addthmtextdep2 "COUNTER1" "COUNTER1 , NOT1 , 0";
addthmtextdep2 "BOOLDEF" "BOOLDEF , 0";
addthmtextdep2 "ODDCHOICE" "ODDCHOICE , 0";
addthmtextdep2 "TAB_WITNESS" "TAB_WITNESS , forsome , forall , NOT1 , CHOICE_TAC , 0";
addthmtextdep2 "CHOICE_TAC" "CHOICE_TAC , forsome , forall , NOT1 , 0";
addthmtextdep2 "ANY_INSTANCE" "ANY_INSTANCE , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "forallcase" "forallcase , forall , 0";
addthmtextdep2 "forsomecase" "forsomecase , forsome , forall , NOT1 , 0";
addthmtextdep2 "CEX" "CEX , forall , COUNTER1 , NOT1 , 0";
addthmtextdep2 "SUBTYPE" "SUBTYPE , 0";
addthmtextdep2 "COUNTER" "COUNTER , COUNTER1 , NOT1 , 0";
addthmtextdep2 "CHOICE" "CHOICE , forsome , forall , NOT1 , 0";
addthmtextdep2 "ALT_QUANT_IMP" "ALT_QUANT_IMP , forsome , forall , NOT1 , IF , OR , AND , 0";
addthmtextdep2 "TAB_ALL_NEW_2" "TAB_ALL_NEW_2 , forall , 0";
addthmtextdep2 "TAB_ALL_NEW_1" "TAB_ALL_NEW_1 , forall , 0";
addthmtextdep2 "TAB_SOME_NEW_2" "TAB_SOME_NEW_2 , forsome , forall , NOT1 , 0";
addthmtextdep2 "TAB_SOME_NEW_1" "TAB_SOME_NEW_1 , forsome , forall , NOT1 , 0";
addthmtextdep2 "TAB_SOME_2" "TAB_SOME_2 , forsome , forall , NOT1 , 0";
addthmtextdep2 "TAB_ALL_2" "TAB_ALL_2 , forall , 0";
addthmtextdep2 "TAB_SOME" "TAB_SOME , forsome , forall , NOT1 , 0";
addthmtextdep2 "TAB_ALL" "TAB_ALL , forall , 0";
addthmtextdep2 "TAB_XOR_2" "TAB_XOR_2 , XOR , IFF , NOT1 , 0";
addthmtextdep2 "XOR" "XOR , IFF , NOT1 , 0";
addthmtextdep2 "TAB_XOR" "TAB_XOR , XOR , IFF , NOT1 , 0";
addthmtextdep2 "TAB_IFF_2" "TAB_IFF_2 , IFF , 0";
addthmtextdep2 "TAB_IFF" "TAB_IFF , IFF , 0";
addthmtextdep2 "TAB_IF_2" "TAB_IF_2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "TAB_IF" "TAB_IF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "TAB_OR_2" "TAB_OR_2 , OR , NOT1 , AND , 0";
addthmtextdep2 "TAB_OR" "TAB_OR , OR , NOT1 , AND , 0";
addthmtextdep2 "TAB_AND_2" "TAB_AND_2 , AND , 0";
addthmtextdep2 "TAB_AND" "TAB_AND , AND , 0";
addthmtextdep2 "TAB_NOT_2" "TAB_NOT_2 , NOT1 , 0";
addthmtextdep2 "TAB_NOT" "TAB_NOT , NOT1 , 0";
addthmtextdep2 "FORALL_IMP_FORSOME_EQ" "FORALL_IMP_FORSOME_EQ , forall , IF , NOT1 , OR , AND , forsome , 0";
addthmtextdep2 "FORSOME_NOTFORALL" "FORSOME_NOTFORALL , forall , NOT1 , forsome , 0";
addthmtextdep2 "FORALL_NOTFORSOME" "FORALL_NOTFORSOME , forsome , forall , NOT1 , 0";
addthmtextdep2 "FORSOMEDIST2" "FORSOMEDIST2 , forsome , forall , NOT1 , AND , 0";
addthmtextdep2 "FORALLORDIST" "FORALLORDIST , forall , OR , NOT1 , AND , 0";
addthmtextdep2 "FORALLOR" "FORALLOR , forall , OR , NOT1 , AND , 0";
addthmtextdep2 "FORALLNOT" "FORALLNOT , forall , NOT1 , AND , 0";
addthmtextdep2 "NOTFORALL" "NOTFORALL , forall , NOT1 , OR , AND , 0";
addthmtextdep2 "FORALLSWITCH2" "FORALLSWITCH2 , forall , 0";
addthmtextdep2 "FORSOMEDROP" "FORSOMEDROP , forsome , forall , NOT1 , ASSERT , 0";
addthmtextdep2 "FORALLSWITCH" "FORALLSWITCH , forall , 0";
addthmtextdep2 "FORALLDIST" "FORALLDIST , forall , AND , 0";
addthmtextdep2 "DINSTANTIATEF1" "DINSTANTIATEF1 , forsome , forall , NOT1 , OR , AND , 0";
addthmtextdep2 "DINSTANTIATE" "DINSTANTIATE , forsome , forall , NOT1 , OR , AND , 0";
addthmtextdep2 "INSTANTIATE" "INSTANTIATE , forall , AND , 0";
addthmtextdep2 "TESTSIMP" "TESTSIMP , EVERYWHERE_CASE , EVERYWHERE , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , XOR , IFF , NOT1 , (?x $ ?y) , IDEF2 , IF , OR , AND , CASEPREP , ASSERT , ALLASSERTS , CONDSIMP , DID , DZER , DSYM , (?x ** ?y) , XORALTDEF , BALTDEF , DRULE1 , DRULE2 , RL , CRULE1 , CRULE2 , CID , CZER , 0";
addthmtextdep2 "CONDSIMP" "CONDSIMP , ASSERT , DID , OR , NOT1 , AND , DZER , DSYM , (?x ** ?y) , XORALTDEF , IFF , BALTDEF , DRULE1 , DRULE2 , RL , CRULE1 , CRULE2 , CID , CZER , 0";
addthmtextdep2 "CZER" "CZER , AND , 0";
addthmtextdep2 "CRULE2" "CRULE2 , ASSERT , AND , 0";
addthmtextdep2 "DRULE2" "DRULE2 , ASSERT , OR , NOT1 , AND , 0";
addthmtextdep2 "DRULE1" "DRULE1 , OR , NOT1 , AND , ASSERT , 0";
addthmtextdep2 "BALTDEF" "BALTDEF , IFF , AND , NOT1 , OR , 0";
addthmtextdep2 "XORALTDEF" "XORALTDEF , NOT1 , AND , OR , IFF , 0";
addthmtextdep2 "DZER" "DZER , OR , NOT1 , AND , 0";
addthmtextdep2 "CASEPREP" "CASEPREP , ASSERT , ALLASSERTS , 0";
addthmtextdep2 "ALLASSERTS" "ASSERT , ALLASSERTS , 0";
addthmtextdep2 "IDEF2" "IDEF2 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "CONDCASES2" "CONDCASES2 , ASSERT , AND , NOT1 , OR , 0";
addthmtextdep2 "IMPTOCOND" "IMPTOCOND , IF , NOT1 , OR , AND , ASSERT , 0";
addthmtextdep2 "CONDCASES" "CONDCASES , AND , NOT1 , OR , ASSERT , 0";
addthmtextdep2 "CONDCASESL1F" "CONDCASESL1F , AND , NOT1 , OR , IFF , 0";
addthmtextdep2 "CONDCASESL1" "CONDCASESL1 , AND , NOT1 , OR , IFF , 0";
addthmtextdep2 "BEQSUBS" "BEQSUBS , IFF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "ASRTCOND" "ASRTCOND , ASSERT , 0";
addthmtextdep2 "EQSYMM2" "EQSYMM2 , 0";
addthmtextdep2 "CONVORAND" "CONVORAND , AND , BID2 , IFF , ASSERT , RIGHT , RIGHT1 , RIGHT2 , BID , BASSOC , BRULE3 , OR , NOT1 , 0";
addthmtextdep2 "BRULE3" "BRULE3 , ASSERT , IFF , 0";
addthmtextdep2 "BASSOC" "BASSOC , IFF , 0";
addthmtextdep2 "BID" "BID , IFF , 0";
addthmtextdep2 "BID2" "BID2 , IFF , ASSERT , 0";
addthmtextdep2 "CONVORIMP" "CONVORIMP , IF , NOT1 , OR , AND , BID , IFF , BRULE2 , ASSERT , 0";
addthmtextdep2 "BRULE2" "BRULE2 , ASSERT , IFF , 0";
addthmtextdep2 "CONVANDOR" "CONVANDOR , OR , NOT1 , AND , DID , ASSERT , FDEF , CONVANDIMP , IF , BID , IFF , BRULE2 , 0";
addthmtextdep2 "CONVANDIMP" "CONVANDIMP , IF , NOT1 , OR , AND , BID , IFF , BRULE2 , ASSERT , 0";
addthmtextdep2 "CONVIMPOR" "CONVIMPOR , OR , NOT1 , AND , DID , ASSERT , FDEF , IF , 0";
addthmtextdep2 "CONVIMPAND" "CONVIMPAND , AND , CID , ASSERT , IF , NOT1 , OR , 0";
addthmtextdep2 "IDIS4" "IDIS4 , OR , NOT1 , AND , IF , 0";
addthmtextdep2 "IDIS3" "IDIS3 , AND , IF , NOT1 , OR , 0";
addthmtextdep2 "IDIS2" "IDIS2 , AND , IF , NOT1 , OR , 0";
addthmtextdep2 "IDIS1" "IDIS1 , OR , NOT1 , AND , IF , 0";
addthmtextdep2 "3pt89" "3pt89 , AND , NOT1 , OR , ASSERT , 0";
addthmtextdep2 "AP3pt88" "AP3pt88 , OR , NOT1 , AND , THMAP , ASSRTBOTH , ASSERT , RIGHT , RIGHT1 , RIGHT2 , ASRTLEFT , MKASRT , ASRTRIGHT , LEFT , LEFT1 , LEFT2 , RL , (?x ** ?y) , 3pt88 , 0";
addthmtextdep2 "3pt88" "3pt88 , ASSERT , OR , NOT1 , AND , 0";
addthmtextdep2 "THMAP" "THMAP , ASSRTBOTH , ASSERT , RIGHT , RIGHT1 , RIGHT2 , ASRTLEFT , MKASRT , ASRTRIGHT , LEFT , LEFT1 , LEFT2 , RL , (?x ** ?y) , 0";
addthmtextdep2 "MKASRT" "ASSRTBOTH , ASSERT , RIGHT , RIGHT1 , RIGHT2 , ASRTLEFT , MKASRT , ASRTRIGHT , LEFT , LEFT1 , LEFT2 , RL , 0";
addthmtextdep2 "ASRTRIGHT" "LEFT , LEFT1 , LEFT2 , ASSRTBOTH , ASSERT , RIGHT , RIGHT1 , RIGHT2 , ASRTLEFT , MKASRT , ASRTRIGHT , RL , 0";
addthmtextdep2 "ASRTLEFT" "RIGHT , RIGHT1 , RIGHT2 , ASSRTBOTH , ASSERT , ASRTLEFT , MKASRT , ASRTRIGHT , LEFT , LEFT1 , LEFT2 , RL , 0";
addthmtextdep2 "ASSRTBOTH" "ASSRTBOTH , ASSERT , 0";
addthmtextdep2 "3pt87" "3pt87 , AND , 0";
addthmtextdep2 "AP3pt86b" "AP3pt86b , OR , NOT1 , AND , IF , THMAP , ASSRTBOTH , ASSERT , RIGHT , RIGHT1 , RIGHT2 , ASRTLEFT , MKASRT , ASRTRIGHT , LEFT , LEFT1 , LEFT2 , RL , (?x ** ?y) , 3pt86b , 0";
addthmtextdep2 "3pt86b" "3pt86b , ASSERT , OR , NOT1 , AND , IF , 0";
addthmtextdep2 "AP3pt86a" "AP3pt86a , IF , NOT1 , OR , AND , THMAP , ASSRTBOTH , ASSERT , RIGHT , RIGHT1 , RIGHT2 , ASRTLEFT , MKASRT , ASRTRIGHT , LEFT , LEFT1 , LEFT2 , RL , (?x ** ?y) , 3pt86a , 0";
addthmtextdep2 "3pt86a" "3pt86a , ASSERT , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt85b" "3pt85b , AND , IF , NOT1 , OR , 0";
addthmtextdep2 "3pt85a" "3pt85a , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt84c" "3pt84c , AND , IF , NOT1 , OR , 0";
addthmtextdep2 "3pt84b" "3pt84b , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt83F" "3pt83F , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt83" "3pt83 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt82cF" "3pt82cF , IF , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "3pt82c" "3pt82c , IF , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "3pt82bF" "3pt82bF , IFF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt82b" "3pt82b , IFF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt82aF" "3pt82aF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt82a" "3pt82a , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt81F" "3pt81F , IF , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "3pt81" "3pt81 , IF , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "3pt80" "3pt80 , IF , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "3pt79F" "3pt79F , ASSERT , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt79" "3pt79 , IF , NOT1 , OR , AND , ASSERT , 0";
addthmtextdep2 "3pt78" "3pt78 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "MOPF" "MOPF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "MOP" "MOP , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt76eF" "3pt76eF , AND , OR , NOT1 , IF , 0";
addthmtextdep2 "3pt76e" "3pt76e , AND , OR , NOT1 , IF , 0";
addthmtextdep2 "3pt76dF" "3pt76dF , AND , OR , NOT1 , IF , 0";
addthmtextdep2 "3pt76d" "3pt76d , AND , OR , NOT1 , IF , 0";
addthmtextdep2 "3pt76cF" "3pt76cF , AND , OR , NOT1 , IF , 0";
addthmtextdep2 "3pt76c" "3pt76c , AND , OR , NOT1 , IF , 0";
addthmtextdep2 "3pt76bF" "3pt76bF , AND , IF , NOT1 , OR , 0";
addthmtextdep2 "3pt76aF" "3pt76aF , OR , NOT1 , AND , IF , 0";
addthmtextdep2 "3pt76a" "3pt76a , OR , NOT1 , AND , IF , 0";
addthmtextdep2 "3pt75F" "3pt75F , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt75" "3pt75 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt74" "3pt74 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "ILID" "ILID , IF , NOT1 , OR , AND , ASSERT , 0";
addthmtextdep2 "IRZERF" "IRZERF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "IRZER" "IRZER , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "IREFF" "IREFF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "IREF" "IREF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt70" "3pt70 , OR , NOT1 , AND , IF , IFF , 0";
addthmtextdep2 "3pt69" "3pt69 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt68F" "3pt68F , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt68" "3pt68 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt67F" "3pt67F , ASSERT , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt67" "3pt67 , IF , NOT1 , OR , AND , ASSERT , 0";
addthmtextdep2 "3pt66" "3pt66 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt64" "3pt64 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt65" "3pt65 , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "3pt62" "3pt62 , IFF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "IDISB" "IDISB , IFF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "CONTP" "CONTP , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "IDEF3" "IDEF3 , IF , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "XALTDEF" "XALTDEF , XOR , IFF , NOT1 , AND , OR , 0";
addthmtextdep2 "REPL" "REPL , IFF , AND , 0";
addthmtextdep2 "3pt50" "3pt50 , IFF , AND , 0";
addthmtextdep2 "3pt49" "3pt49 , AND , IFF , 0";
addthmtextdep2 "3pt48" "3pt48 , NOT1 , AND , IFF , 0";
addthmtextdep2 "CDISD" "CDISD , OR , NOT1 , AND , 0";
addthmtextdep2 "DDISC" "DDISC , AND , OR , NOT1 , 0";
addthmtextdep2 "3pt44b" "3pt44b , NOT1 , AND , OR , 0";
addthmtextdep2 "3pt44a" "3pt44a , NOT1 , OR , AND , 0";
addthmtextdep2 "L3pt43" "L3pt43 , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "3pt43bF" "3pt43bF , ASSERT , AND , OR , NOT1 , 0";
addthmtextdep2 "3pt43b" "3pt43b , AND , OR , NOT1 , ASSERT , 0";
addthmtextdep2 "3pt43aF" "3pt43aF , ASSERT , OR , NOT1 , AND , 0";
addthmtextdep2 "3pt43a" "3pt43a , OR , NOT1 , AND , ASSERT , 0";
addthmtextdep2 "CCON" "CCON , NOT1 , AND , 0";
addthmtextdep2 "CDISC" "CDISC , AND , 0";
addthmtextdep2 "CZERF" "CZERF , AND , 0";
addthmtextdep2 "CIDEM" "CIDEM , AND , ASSERT , 0";
addthmtextdep2 "DUAL" "DUAL , REMFLIP , BRULE1 , IFF , ASSERT , CRULE1 , AND , DRULE1 , OR , NOT1 , NRULE1 , XRULE1 , XOR , AT , AF , TWOASSERTS , DUBNEG2 , FDEF , NEGF , BFLIP , XORFLIP , DEMa , DEMb , REMA , NOTCLEAN , ASSERTCLEAN , LEFT , LEFT1 , LEFT2 , SREMFLIP , RIGHT , RIGHT1 , RIGHT2 , FLIPALL , FLIPPASTA , SFLIPALL , FLIPPASTN , FLIPPASTB , FLIPPASTX , FLIPPASTD , FLIPPASTC , 0";
addthmtextdep2 "FLIPALL" "FLIPALL , ASSERT , NOT1 , FLIPPASTA , SFLIPALL , FLIPPASTN , FLIPPASTB , IFF , XOR , FLIPPASTX , FLIPPASTD , OR , AND , FLIPPASTC , FDEF , NEGF , DUBNEG2 , BRULE1 , XRULE1 , DRULE1 , CRULE1 , 0";
addthmtextdep2 "SFLIPALL" "ASSERT , NOT1 , FLIPPASTA , SFLIPALL , FLIPPASTN , FLIPPASTB , IFF , XOR , FLIPPASTX , FLIPPASTD , OR , AND , FLIPPASTC , FDEF , NEGF , 0";
addthmtextdep2 "FLIPPASTC" "AND , NOT1 , ASSERT , FLIPPASTA , SFLIPALL , FLIPPASTN , FLIPPASTB , IFF , XOR , FLIPPASTX , FLIPPASTD , OR , FLIPPASTC , FDEF , NEGF , 0";
addthmtextdep2 "FLIPPASTD" "OR , NOT1 , AND , ASSERT , FLIPPASTA , SFLIPALL , FLIPPASTN , FLIPPASTB , IFF , XOR , FLIPPASTX , FLIPPASTD , FLIPPASTC , FDEF , NEGF , 0";
addthmtextdep2 "FLIPPASTX" "XOR , IFF , NOT1 , ASSERT , FLIPPASTA , SFLIPALL , FLIPPASTN , FLIPPASTB , FLIPPASTX , FLIPPASTD , OR , AND , FLIPPASTC , FDEF , NEGF , 0";
addthmtextdep2 "FLIPPASTB" "IFF , NOT1 , ASSERT , FLIPPASTA , SFLIPALL , FLIPPASTN , FLIPPASTB , XOR , FLIPPASTX , FLIPPASTD , OR , AND , FLIPPASTC , FDEF , NEGF , 0";
addthmtextdep2 "FLIPPASTN" "NOT1 , ASSERT , FLIPPASTA , SFLIPALL , FLIPPASTN , FLIPPASTB , IFF , XOR , FLIPPASTX , FLIPPASTD , OR , AND , FLIPPASTC , FDEF , NEGF , 0";
addthmtextdep2 "FLIPPASTA" "ASSERT , NOT1 , FLIPPASTA , SFLIPALL , FLIPPASTN , FLIPPASTB , IFF , XOR , FLIPPASTX , FLIPPASTD , OR , AND , FLIPPASTC , FDEF , NEGF , 0";
addthmtextdep2 "REMFLIP" "REMFLIP , BRULE1 , IFF , ASSERT , CRULE1 , AND , DRULE1 , OR , NOT1 , NRULE1 , XRULE1 , XOR , AT , AF , TWOASSERTS , DUBNEG2 , FDEF , NEGF , BFLIP , XORFLIP , DEMa , DEMb , REMA , NOTCLEAN , ASSERTCLEAN , LEFT , LEFT1 , LEFT2 , SREMFLIP , RIGHT , RIGHT1 , RIGHT2 , 0";
addthmtextdep2 "SREMFLIP" "FDEF , NOT1 , NEGF , BFLIP , IFF , XOR , XORFLIP , DEMa , OR , AND , DEMb , REMA , ASSERT , NOTCLEAN , ASSERTCLEAN , LEFT , LEFT1 , LEFT2 , SREMFLIP , RIGHT , RIGHT1 , RIGHT2 , 0";
addthmtextdep2 "ASSERTCLEAN" "ASSERTCLEAN , ASSERT , 0";
addthmtextdep2 "NOTCLEAN" "NOTCLEAN , NOT1 , 0";
addthmtextdep2 "REMA" "REMA , NOT1 , ASSERT , 0";
addthmtextdep2 "DEMb" "DEMb , NOT1 , AND , OR , 0";
addthmtextdep2 "DEMa" "DEMa , NOT1 , OR , AND , 0";
addthmtextdep2 "XORFLIP" "XORFLIP , XOR , IFF , NOT1 , 0";
addthmtextdep2 "BFLIP" "BFLIP , IFF , NOT1 , XOR , 0";
addthmtextdep2 "NEGF" "NEGF , NOT1 , 0";
addthmtextdep2 "DUBNEG2" "DUBNEG2 , NOT1 , ASSERT , 0";
addthmtextdep2 "TWOASSERTS" "TWOASSERTS , ASSERT , 0";
addthmtextdep2 "AF" "AF , ASSERT , 0";
addthmtextdep2 "XRULE1" "XRULE1 , XOR , IFF , NOT1 , ASSERT , 0";
addthmtextdep2 "NRULE1" "NRULE1 , NOT1 , ASSERT , 0";
addthmtextdep2 "BRULE1" "BRULE1 , IFF , ASSERT , 0";
addthmtextdep2 "GR3" "GR3 , IFF , AND , OR , NOT1 , 0";
addthmtextdep2 "GR2" "GR2 , IFF , OR , NOT1 , AND , 0";
addthmtextdep2 "3pt32F" "3pt32F , ASSERT , OR , NOT1 , AND , IFF , 0";
addthmtextdep2 "3pt32" "3pt32 , OR , NOT1 , AND , IFF , ASSERT , 0";
addthmtextdep2 "DDISD" "DDISD , OR , NOT1 , AND , 0";
addthmtextdep2 "DZERF" "DZERF , OR , NOT1 , AND , 0";
addthmtextdep2 "MUTINT" "MUTINT , IFF , XOR , NOT1 , 0";
addthmtextdep2 "MUTASSOC" "MUTASSOC , XOR , IFF , NOT1 , 0";
addthmtextdep2 "XORASSOC" "XORASSOC , XOR , IFF , NOT1 , 0";
addthmtextdep2 "XORSYM" "XORSYM , XOR , IFF , NOT1 , 0";
addthmtextdep2 "NEQ" "NEQ , IFF , NOT1 , 0";
addthmtextdep2 "3pt15bF" "3pt15bF , NOT1 , IFF , 0";
addthmtextdep2 "3pt15b" "3pt15b , NOT1 , IFF , 0";
addthmtextdep2 "3pt15a" "3pt15a , IFF , NOT1 , 0";
addthmtextdep2 "3pt14" "3pt14 , XOR , IFF , NOT1 , 0";
addthmtextdep2 "3pt11" "3pt11 , NOT1 , IFF , 0";
addthmtextdep2 "APLZ" "APLZ , AND , RIGHT , RIGHT1 , RIGHT2 , LZ , (?x ** ?y) , 0";
addthmtextdep2 "LZ" "LZ , AND , 0";
addthmtextdep2 "GCLEAN" "RL , GCLEAN , NRULE2 , ASSERT , NOT1 , NRULE1 , STL , STR , STT , ALLASSERTS , RIGHT , RIGHT1 , RIGHT2 , LEFT , LEFT1 , LEFT2 , (?x ** ?y) , 0";
addthmtextdep2 "STT" "STT , ASSERT , 0";
addthmtextdep2 "STR" "STR , ASSERT , 0";
addthmtextdep2 "STL" "STL , ASSERT , 0";
addthmtextdep2 "NRULE2" "NRULE2 , ASSERT , NOT1 , 0";
addthmtextdep2 "EQT" "EQT , ASSERT , 0";
addthmtextdep2 "BCONV" "BCONV , IFF , ASSERT , 0";
addthmtextdep2 "ASRTEQ" "ASRTEQ , ASSERT , 0";
addthmtextdep2 "CONS" "CONS , IF , NOT1 , OR , AND , CONVIF , 0";
addthmtextdep2 "CONVIF" "CONVIF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "IDEF" "IDEF , IF , NOT1 , OR , AND , IFF , 0";
addthmtextdep2 "GR" "GR , AND , OR , NOT1 , IFF , 0";
addthmtextdep2 "DXMF" "DXMF , NOT1 , OR , AND , 0";
addthmtextdep2 "BIDF" "BIDF , IFF , 0";
addthmtextdep2 "DXM" "DXM , NOT1 , OR , AND , 0";
addthmtextdep2 "DDIS" "DDIS , IFF , OR , NOT1 , AND , 0";
addthmtextdep2 "DIDEM" "DIDEM , OR , NOT1 , AND , ASSERT , 0";
addthmtextdep2 "XORDEF" "XORDEF , XOR , IFF , NOT1 , 0";
addthmtextdep2 "BDIS" "BDIS , IFF , NOT1 , 0";
addthmtextdep2 "BSYM" "BSYM , IFF , 0";
addthmtextdep2 "PROVETAUT2" "PROVETAUT2 , BRULE1 , IFF , ASSERT , CRULE1 , AND , DRULE1 , OR , NOT1 , NRULE1 , XRULE1 , XOR , IRULE1 , IF , CNRULE1 , CONVIF , ASSERT2 , PROVETAUT , NEWTAUT , CASEINTRO , ALT_PUSH , EVERYWHERE_CASE , EVERYWHERE , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , BOTH_CASES , TOPDOWN_CASE , TOPDOWN , TOPDOWN_INFIX , RL , TOPDOWN_PREFIX , RIGHT , RIGHT1 , RIGHT2 , ASSERT_EXP , ALL_EXP , NOT_EXP , AND_EXP , OR_EXP , IF_EXP , IFF_EXP , XOR_EXP , CN_EXP , MAKE_CASE , ODDCHOICE , EQUATION , BOOLDEF , 0";
addthmtextdep2 "PROVETAUT" "PROVETAUT , NEWTAUT , CASEINTRO , ALT_PUSH , EVERYWHERE_CASE , EVERYWHERE , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , BOTH_CASES , TOPDOWN_CASE , TOPDOWN , TOPDOWN_INFIX , RL , TOPDOWN_PREFIX , RIGHT , RIGHT1 , RIGHT2 , ASSERT_EXP , ASSERT , ALL_EXP , NOT_EXP , NOT1 , AND_EXP , AND , OR_EXP , OR , IF_EXP , IF , IFF_EXP , IFF , XOR_EXP , XOR , CN_EXP , CONVIF , MAKE_CASE , ODDCHOICE , EQUATION , BOOLDEF , 0";
addthmtextdep2 "NEWTAUT" "NEWTAUT , CASEINTRO , ALT_PUSH , EVERYWHERE_CASE , EVERYWHERE , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , BOTH_CASES , TOPDOWN_CASE , TOPDOWN , TOPDOWN_INFIX , RL , TOPDOWN_PREFIX , RIGHT , RIGHT1 , RIGHT2 , ASSERT_EXP , ASSERT , ALL_EXP , NOT_EXP , NOT1 , AND_EXP , AND , OR_EXP , OR , IF_EXP , IF , IFF_EXP , IFF , XOR_EXP , XOR , CN_EXP , CONVIF , MAKE_CASE , ODDCHOICE , EQUATION , BOOLDEF , 0";
addthmtextdep2 "MAKE_CASE" "MAKE_CASE , ODDCHOICE , EQUATION , BOOLDEF , 0";
addthmtextdep2 "EQUATION" "EQUATION , 0";
addthmtextdep2 "ALL_EXP" "ASSERT_EXP , ASSERT , ALL_EXP , NOT_EXP , NOT1 , AND_EXP , AND , OR_EXP , OR , IF_EXP , IF , IFF_EXP , IFF , XOR_EXP , XOR , CN_EXP , CONVIF , 0";
addthmtextdep2 "CN_EXP" "CN_EXP , CONVIF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "XOR_EXP" "XOR_EXP , XOR , IFF , NOT1 , 0";
addthmtextdep2 "IFF_EXP" "IFF_EXP , IFF , 0";
addthmtextdep2 "IF_EXP" "IF_EXP , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "OR_EXP" "OR_EXP , OR , NOT1 , AND , 0";
addthmtextdep2 "AND_EXP" "AND_EXP , AND , 0";
addthmtextdep2 "NOT_EXP" "NOT_EXP , NOT1 , 0";
addthmtextdep2 "ASSERT_EXP" "ASSERT_EXP , ASSERT , 0";
addthmtextdep2 "ALT_PUSH" "CASEINTRO , ALT_PUSH , EVERYWHERE_CASE , EVERYWHERE , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , 0";
addthmtextdep2 "CASEINTRO" "CASEINTRO , 0";
addthmtextdep2 "CNRULE1" "CNRULE1 , CONVIF , IF , NOT1 , OR , AND , ASSERT , 0";
addthmtextdep2 "IRULE1" "IRULE1 , IF , NOT1 , OR , AND , ASSERT , 0";
addthmtextdep2 "CNRULE3" "CNRULE3 , ASSERT , CONVIF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "CNRULE2" "CNRULE2 , ASSERT , CONVIF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "IRULE3" "IRULE3 , ASSERT , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "XRULE3" "XRULE3 , ASSERT , XOR , IFF , NOT1 , 0";
addthmtextdep2 "XRULE2" "XRULE2 , ASSERT , XOR , IFF , NOT1 , 0";
addthmtextdep2 "CRULE3" "CRULE3 , ASSERT , AND , 0";
addthmtextdep2 "DRULE3" "DRULE3 , ASSERT , OR , NOT1 , AND , 0";
addthmtextdep2 "NONTRIV2a" "NONTRIV2a , 0";
addthmtextdep2 "FORSOMEBOOL2" "FORSOMEBOOL2 , forsome , forall , NOT1 , 0";
addthmtextdep2 "FORALLBOOL2" "FORALLBOOL2 , forall , 0";
addthmtextdep2 "BOOLDEF2" "BOOLDEF2 , 0";
addthmtextdep2 "ASSERT_UNEXP" "ASSERT_UNEXP , ASSERT , 0";
addthmtextdep2 "ANDUNPACK" "ANDUNPACK , AND , 0";
addthmtextdep2 "DUBNEG" "DUBNEG , NOT1 , 0";
addthmtextdep2 "BOOLDEF0" "BOOLDEF0 , 0";
addthmtextdep2 "UNPACK" "UNPACK , 0";
addthmtextdep2 "EXAMPLE1" "EXAMPLE1 , forall , forsome , NOT1 , 0";
addthmtextdep2 "CNBOOL" "CNBOOL , CONVIF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "CONSCIN" "CONSCIN , CONVIF , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "CONTYPE" "CONTYPE , CONVIF , IF , NOT1 , OR , AND , ASSERT , 0";
addthmtextdep2 "IMPTYPE" "IMPTYPE , IF , NOT1 , OR , AND , ASSERT , 0";
addthmtextdep2 "CTYPE" "CTYPE , AND , ASSERT , 0";
addthmtextdep2 "DTYPE" "DTYPE , OR , NOT1 , AND , ASSERT , 0";
addthmtextdep2 "NTYPE" "NTYPE , NOT1 , ASSERT , 0";
addthmtextdep2 "XORBOOL" "XORBOOL , XOR , IFF , NOT1 , 0";
addthmtextdep2 "XORSCIN" "XORSCIN , XOR , IFF , NOT1 , 0";
addthmtextdep2 "XORTYPE" "XORTYPE , XOR , IFF , NOT1 , ASSERT , 0";
addthmtextdep2 "BTYPE" "BTYPE , IFF , ASSERT , 0";
addthmtextdep2 "ASSERTSCOUT" "ASSERTSCOUT , ASSERT , 0";
addthmtextdep2 "IFFSCIN" "IFFSCIN , IFF , 0";
addthmtextdep2 "IFSCIN" "IFSCIN , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "ORSCIN" "ORSCIN , OR , NOT1 , AND , 0";
addthmtextdep2 "NOTBOOLDROP" "NOTBOOLDROP , NOT1 , 0";
addthmtextdep2 "ANDSCIN" "ANDSCIN , AND , 0";
addthmtextdep2 "IFFBOOL" "IFFBOOL , IFF , 0";
addthmtextdep2 "IFBOOL" "IFBOOL , IF , NOT1 , OR , AND , 0";
addthmtextdep2 "ALTORDEF" "ALTORDEF , OR , NOT1 , AND , 0";
addthmtextdep2 "NOT" "NOT , NOT1 , 0";
addthmtextdep2 "ORBOOL" "ORBOOL , OR , NOT1 , AND , 0";
addthmtextdep2 "ANDBOOL" "ANDBOOL , AND , 0";
addthmtextdep2 "FALSEBOOL" "FALSEBOOL , 0";
addthmtextdep2 "TRUEBOOL" "TRUEBOOL , 0";
addthmtextdep2 "forsome2" "forsome2 , forsome , forall , NOT1 , 0";
addthmtextdep2 "FORSOMEBOOL" "FORSOMEBOOL , forsome , forall , NOT1 , 0";
addthmtextdep2 "NOTBOOL" "NOTBOOL , NOT1 , 0";
addthmtextdep2 "forall2" "forall2 , forall , 0";
addthmtextdep2 "FORALLBOOL" "FORALLBOOL , forall , 0";
addthmtextdep2 "EQBOOL" "EQBOOL , 0";
addthmtextdep2 "EQSYMM" "EQSYMM , 0";
addthmtextdep2 "LAMBDAREMOVE3" "LAMBDAREMOVE3 , BOTH_CASES , LAMBDAREMOVE , LEFT , LEFT1 , LEFT2 , LAMBDAREMOVE2 , IGNOREFIRST , LAMBDAREMOVE1 , RL , 0";
addthmtextdep2 "LAMBDAREMOVE2" "LAMBDAREMOVE3 , BOTH_CASES , LAMBDAREMOVE , LEFT , LEFT1 , LEFT2 , LAMBDAREMOVE2 , IGNOREFIRST , LAMBDAREMOVE1 , RL , 0";
addthmtextdep2 "LAMBDAREMOVE1" "LAMBDAREMOVE3 , BOTH_CASES , LAMBDAREMOVE , LEFT , LEFT1 , LEFT2 , LAMBDAREMOVE2 , IGNOREFIRST , LAMBDAREMOVE1 , RL , 0";
addthmtextdep2 "LAMBDAREMOVE" "LAMBDAREMOVE3 , BOTH_CASES , LAMBDAREMOVE , LEFT , LEFT1 , LEFT2 , LAMBDAREMOVE2 , IGNOREFIRST , LAMBDAREMOVE1 , RL , 0";
addthmtextdep2 "LAMBDAINTRO3" "LAMBDAINTRO3 , BOTH_CASES , LAMBDAINTRO , LEFT , LEFT1 , LEFT2 , LAMBDAINTRO2 , LABELINTRO , IGNOREFIRST , LAMBDAINTRO1 , RL , 0";
addthmtextdep2 "LAMBDAINTRO2" "LAMBDAINTRO3 , BOTH_CASES , LAMBDAINTRO , LEFT , LEFT1 , LEFT2 , LAMBDAINTRO2 , LABELINTRO , IGNOREFIRST , LAMBDAINTRO1 , RL , 0";
addthmtextdep2 "LAMBDAINTRO1" "LAMBDAINTRO3 , BOTH_CASES , LAMBDAINTRO , LEFT , LEFT1 , LEFT2 , LAMBDAINTRO2 , LABELINTRO , IGNOREFIRST , LAMBDAINTRO1 , RL , 0";
addthmtextdep2 "LAMBDAINTRO" "LAMBDAINTRO3 , BOTH_CASES , LAMBDAINTRO , LEFT , LEFT1 , LEFT2 , LAMBDAINTRO2 , LABELINTRO , IGNOREFIRST , LAMBDAINTRO1 , RL , 0";
addthmtextdep2 "LABELINTRO" "LABELINTRO , IGNOREFIRST , 0";
addthmtextdep2 "goto" "goto , STRONG_EVERYWHERE_CASE , EVERYWHERE2 , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , EVERYWHERE_ABS , INPUT_AT , upfun , INPUTS2 , (?x ** ?y) , 0";
addthmtextdep2 "INPUT_AT" "INPUT_AT , upfun , INPUTS2 , (?x ** ?y) , 0";
addthmtextdep2 "INPUTS2" "upfun , INPUTS2 , (?x ** ?y) , 0";
addthmtextdep2 "upfun" "upfun , 0";
addthmtextdep2 "value" "value , VALUE , upfun , INPUTS2 , (?x ** ?y) , 0";
addthmtextdep2 "VALUE" "VALUE , 0";
addthmtextdep2 "left_case" "left_case , LEFT_CASE , upfun , INPUTS2 , (?x ** ?y) , 0";
addthmtextdep2 "right_case" "right_case , RIGHT_CASE , upfun , INPUTS2 , (?x ** ?y) , 0";
addthmtextdep2 "RIGHT_CASE" "RIGHT_CASE , 0";
addthmtextdep2 "left" "left , LEFT , LEFT1 , LEFT2 , upfun , INPUTS2 , (?x ** ?y) , 0";
addthmtextdep2 "right" "right , RIGHT , RIGHT1 , RIGHT2 , upfun , INPUTS2 , (?x ** ?y) , 0";
addthmtextdep2 "up" "up , upfun , 0";
addthmtextdep2 "BINDLABELS" "BINDLABELS , LEFT , LEFT1 , LEFT2 , STRONG_EVERYWHERE_CASE , EVERYWHERE2 , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , EVERYWHERE_ABS , IGNOREFIRST , RIGHT , RIGHT1 , RIGHT2 , ID , Id , APPLYATLABELS , APPLYATLABEL , APPLYATLABEL0 , (?x $ ?y) , 0";
addthmtextdep2 "APPLYATLABELS" "APPLYATLABELS , APPLYATLABEL , STRONG_EVERYWHERE_CASE , EVERYWHERE2 , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , EVERYWHERE_ABS , APPLYATLABEL0 , IGNOREFIRST , 0";
addthmtextdep2 "APPLYATLABEL" "APPLYATLABEL , STRONG_EVERYWHERE_CASE , EVERYWHERE2 , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , EVERYWHERE_ABS , APPLYATLABEL0 , IGNOREFIRST , 0";
addthmtextdep2 "APPLYATLABEL0" "APPLYATLABEL0 , IGNOREFIRST , 0";
addthmtextdep2 "ID" "ID , Id , 0";
addthmtextdep2 "Id" "Id , 0";
addthmtextdep2 "LABELTERM" "LABELTERM , LABELTERMS_FOUND , IGNOREFIRST , LABELTERMS_SPLIT , LABELTERMS , LABELTERMS_ABSTRACT , LABELTERMS_UNARY , LABELTERMS_CASE , 0";
addthmtextdep2 "LABELTERMS" "LABELTERMS_FOUND , IGNOREFIRST , LABELTERMS_SPLIT , LABELTERMS , LABELTERMS_ABSTRACT , LABELTERMS_UNARY , LABELTERMS_CASE , 0";
addthmtextdep2 "LABELTERMS_CASE" "LABELTERMS_FOUND , IGNOREFIRST , LABELTERMS_SPLIT , LABELTERMS , LABELTERMS_ABSTRACT , LABELTERMS_UNARY , LABELTERMS_CASE , 0";
addthmtextdep2 "LABELTERMS_UNARY" "LABELTERMS_FOUND , IGNOREFIRST , LABELTERMS_SPLIT , LABELTERMS , LABELTERMS_ABSTRACT , LABELTERMS_UNARY , LABELTERMS_CASE , 0";
addthmtextdep2 "LABELTERMS_ABSTRACT" "LABELTERMS_FOUND , IGNOREFIRST , LABELTERMS_SPLIT , LABELTERMS , LABELTERMS_ABSTRACT , LABELTERMS_UNARY , LABELTERMS_CASE , 0";
addthmtextdep2 "LABELTERMS_SPLIT" "LABELTERMS_FOUND , IGNOREFIRST , LABELTERMS_SPLIT , LABELTERMS , LABELTERMS_ABSTRACT , LABELTERMS_UNARY , LABELTERMS_CASE , 0";
addthmtextdep2 "LABELTERMS_FOUND" "LABELTERMS_FOUND , IGNOREFIRST , 0";
addthmtextdep2 "POP_CASE" "POP_CASE , IGNOREFIRST , POP_CASE_1 , POP_CASE_2 , (?x ** ?y) , 0";
addthmtextdep2 "POP_CASE_1" "IGNOREFIRST , POP_CASE_1 , POP_CASE_2 , (?x ** ?y) , 0";
addthmtextdep2 "POP_CASE_2" "IGNOREFIRST , POP_CASE_1 , POP_CASE_2 , (?x ** ?y) , 0";
addthmtextdep2 "ANTI_UNEVAL_TAC" "ANTI_UNEVAL_TAC , FNDIST , BOTH_CASES , 0";
addthmtextdep2 "FNDIST" "FNDIST , 0";
addthmtextdep2 "TYPEBIND" "TYPEBIND , STRONG_EVERYWHERE_CASE , EVERYWHERE2 , EVERYWHERE_INFIX , EVERYWHERE_PREFIX , EVERYWHERE_ABS , TYPES , (?x $ ?y) , 0";
addthmtextdep2 "UNEVAL_TAC" "UNEVAL_TAC , BOTH_CASES , FNDIST , 0";
addthmtextdep2 "VIEWCASES" "VIEWCASES , 0";
addthmtextdep2 "LOOP_TAC" "LOOP_TAC , IGNOREFIRST , STOPLOOP , ALL_STEPS , RIGHT , RIGHT1 , RIGHT2 , STARTLOOP , 0";
addthmtextdep2 "ALL_STEPS" "IGNOREFIRST , STOPLOOP , ALL_STEPS , RIGHT , RIGHT1 , RIGHT2 , STARTLOOP , 0";
addthmtextdep2 "STARTLOOP" "STARTLOOP , IGNOREFIRST , 0";
addthmtextdep2 "STOPLOOP" "STOPLOOP , IGNOREFIRST , 0";
addthmtextdep2 "LISTBIND" "PAIRBIND , LEFT , LEFT1 , LEFT2 , VALUE , RIGHT , RIGHT1 , RIGHT2 , PI2F , P2 , PI1F , P1 , LISTBIND , 0";
addthmtextdep2 "PAIRBIND" "PAIRBIND , LEFT , LEFT1 , LEFT2 , VALUE , RIGHT , RIGHT1 , RIGHT2 , PI2F , P2 , PI1F , P1 , 0";
addthmtextdep2 "PI1F" "PI1F , P1 , 0";
addthmtextdep2 "PI2F" "PI2F , P2 , 0";
addthmtextdep2 "VALUE0" "VALUE0 , 0";
addthmtextdep2 "REVPIVOT" "REVPIVOT , LEFT_CASE , HYP , 0";
addthmtextdep2 "PCASEINTRO" "PCASEINTRO , 0";
addthmtextdep2 "PI2" "PI2 , P2 , 0";
addthmtextdep2 "PI1" "PI1 , P1 , 0";
addthmtextdep2 "NONTRIV" "NONTRIV , 0";
addthmtextdep2 "COMP" "COMP , 0";
quit();
