<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Built-in tactics:</TITLE>
<META NAME="description" CONTENT="Built-in tactics:">
<META NAME="keywords" CONTENT="babydocs">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="babydocs.css">
<LINK REL="previous" HREF="node57.html">
<LINK REL="up" HREF="node55.html">
<LINK REL="next" HREF="node59.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html794"
 HREF="node59.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="http://cs.idbsu.edu/icons//next_motif.gif"></A> 
<A NAME="tex2html791"
 HREF="node55.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="http://cs.idbsu.edu/icons//up_motif.gif"></A> 
<A NAME="tex2html787"
 HREF="node57.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="http://cs.idbsu.edu/icons//previous_motif.gif"></A> 
<A NAME="tex2html793"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="http://cs.idbsu.edu/icons//contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html795"
 HREF="node59.html">Command abbreviations:</A>
<B> Up:</B> <A NAME="tex2html792"
 HREF="node55.html">Predeclared objects:</A>
<B> Previous:</B> <A NAME="tex2html788"
 HREF="node57.html">Predeclared theorems:</A>
<BR>
<BR>
<!--End of Navigation Panel-->

<H3><A NAME="SECTION000811300000000000000">
Built-in tactics:</A>
</H3>

<P>
<DL>
<DD><P>
<DT><STRONG>BIND:</STRONG>
<DD>built-in tactic which converts the current subterm to a
function of its term parameter, if this is permitted by stratification
constraints.  The <TT>BIND</TT> tactic now works sensibly when the
parameter is a pair or more complex tuple.

<P>
<DT><STRONG>EVAL:</STRONG>
<DD>built in tactic which reverses the effect of either
<TT>BIND</TT> or <TT>UNEVAL</TT>; if applied to a term with a function
(braket term) applied to an argument, it carries out the evaluation of
the function at that argument.

<P>
<DT><STRONG>INPUT:</STRONG>
<DD>built-in tactic which displays the local term and
hypotheses and allows the user to enter a theorem to be applied at
that point.  The <TT>script</TT> command will read input intended for the
<TT>INPUT</TT> command; in such input, comments are started by <TT>{</TT>
and ended by <TT>}</TT> or the end of the line. <TT>}</TT> can be used to
put more than one input theorem on a line.  At the top level, the
latest version of the prover causes a pause after the <TT>INPUT</TT>
prompt, at which one can issue secure commands, including <TT>inputri</TT> to set the theorem to rewrite with.  In scripts, the behavior
of the prover has not changed:  it reads theorems to be entered
as lines of input from the script.  The <TT>guimode();</TT> command
(which is deprecated) will restore the old behavior of <TT>INPUT</TT>
at top level (if GUI mode is turned off).

<P>
<DT><STRONG>FLIP:</STRONG>
<DD>built in tactic taking one argument (a theorem); the
theorem parameter is applied if the selected subterm is an infix term
with its two immediate subterms ``out of order''.  Used for sorting
(the parameter should be a commutative law, but this is not enforced).

<P>
<DT><STRONG>OUTPUT:</STRONG>
<DD>built-in tactic which causes the prover to display
its term parameter.

<P>
<DT><STRONG>UNEVAL:</STRONG>
<DD>built-in tactic which converts the selected subterm to
an application subterm in which the function is the term parameter, if
this is possible.  Upgrades in higher-order matching have considerably
increased the scope of application of this tactic.

<P>
<DT><STRONG>BINDM, EVALM, UNEVALM:</STRONG>
<DD>As <TT>BIND</TT>, <TT>EVAL</TT>, <TT>UNEVAL</TT>
These built-in tactics handle abstraction and reduction for a more
liberal kind of abstraction used to improve fluent treatment of
first-order logic.  These will be less important to typical users
than the forms without the <TT>M</TT>.

<P>
<DT><STRONG>SHELL (obsolete):</STRONG>
<DD>built-in tactic designed for use at the <TT>INPUT</TT>
prompt.  This tactic invokes the <TT>noml</TT> shell, so that the user
can issue prover commands (e.g. display or search for theorems) from
the <TT>INPUT</TT> environment.  Recall that <TT>quit();</TT> will terminate
the <TT>noml</TT> shell.  If the environment (the term being manipulated)
is changed by the commands issued at the <TT>noml</TT> prompt, the prover
will crash out in a manner similar to that which occurs with <TT>STOPINPUT</TT>.  Do not attempt to carry out proofs in the shell invoked
by this command!  The <TT>SHELL</TT> tactic is now deprecated, since
any top level invocation of <TT>INPUT</TT> now permits one to issue
secure commands at the <TT>INPUT</TT> prompt.  (Latest word is that
it is completely obsolete).  

<P>
<DT><STRONG>STOPINPUT:</STRONG>
<DD>built-in tactic designed for use at the <TT>INPUT</TT>
prompt:  the effect is to convert the current term to an error term, causing
the current execution to crash, returning to the first stage which invoked
<TT>INPUT</TT> and issuing an error message.  One can then edit and reissue
the most recent block of theorems to be read at the <TT>INPUT</TT> prompt.
<TT>STOPINPUT</TT> remains usable with the GUI modifications.

<P>
<DT><STRONG><TT>|-|</TT>:</STRONG>
<DD>operator which enables application of local hypotheses.
<TT>0|-|n</TT> applies the <I>n</I>th local hypothesis as a rewrite rule.  <TT>1|-|n</TT>
reduces the selected subterm if it is a case expression with hypothesis identical to the <I>n</I>th local hypothesis.  The converse of <TT>1|-|n</TT> builds a new
case expression with the <I>n</I>th local hypothesis (creating a new variable);
the converse of <TT>2|-|n</TT> is the same as the converse of <TT>1|-|n</TT>,
except that it takes a parameter which is used instead of the new variable.

<P>
<DT><STRONG><TT>UP</TT>:</STRONG>
<DD>a new (very experimental) built-in tactic.  An
execution of <TT>UP@?thm</TT> will cause <TT>?thm</TT> to be executed
on the parent term of the term to which it is applied, unless the
parent term is itself an embedded theorem application.  When two
instances compete to be applied, the one on the right wins.

<P>
<DT><STRONG><TT>SCOUT</TT>, <TT>SCIN</TT>, <TT>SCINR</TT>, <TT>SCINL</TT>:</STRONG>
<DD>These
built-in theorems allow application of the scin/scout witness theorem
of the top-level operator or function of a target term, if there
is one.  These tactics add type labels when applied in the direct
sense and eliminate them when applied in the converse sense, independently
of the sense of the actual witness theorem.

<P>
<DT><STRONG><TT>=&gt;&gt; &lt;&lt;=</TT>:</STRONG>
<DD>``alternative rule infixes'': the effect of
application of <TT>thm1 =&gt;&gt; thm2</TT> is to apply <TT>thm1</TT> (or its
converse if the converse rule infix is used for the application) and
apply thm2 (or its converse if <TT>&lt;&lt;=</TT> is used instead of <TT>=&gt;&gt;</TT>)
just in case the application of <TT>thm1</TT> fails.  Failure of built-in
tactics is defined as failure to change the selected term (this is not
an optimal solution in theory, but seems to work in practice).

<P>
<DT><STRONG><TT>*&gt; &lt;*</TT>:</STRONG>
<DD>``guarded rule infixes'': just as the previous two
infixes, except that <TT>thm2</TT> is applied (in the appropriate sense)
just in case the application of <TT>thm1</TT> succeeds.

<P>
<DT><STRONG><TT>=</TT>:</STRONG>
<DD>When used as a built-in tactic, the tactic interpreter
will search for a theorem or converse theorem justifying the equation
used as an embedded theorem and apply it.

<P>
<DT><STRONG><TT>!@ !$</TT>:</STRONG>
<DD>``autoformat'' prefixes.  Applying <TT>!@</TT>
(resp. <TT>!$</TT>) to a theorem produces a parameterized theorem taking
a parameter list filling the new variables introduced by the theorem
(resp. the converse of the theorem).

<P>
<DT><STRONG><TT>#!</TT>:</STRONG>
<DD>This unary operator on tactics was introduced to
increase efficiency of execution of definitions of recursive
functions.  The first time an embedded theorem to which <TT>#!</TT> is
applied is applied to a target, the result of this application is
recorded; when it is applied subsequently, the result to be obtained is
looked up in a table.  This can save execution time.  The argument
of <TT>#!</TT> can be a tactic with arguments.  Further, entries in the
table can be applied in the converse sense as well, which can produce
curious effects!

<P>
</DL>
<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html794"
 HREF="node59.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="http://cs.idbsu.edu/icons//next_motif.gif"></A> 
<A NAME="tex2html791"
 HREF="node55.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="http://cs.idbsu.edu/icons//up_motif.gif"></A> 
<A NAME="tex2html787"
 HREF="node57.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="http://cs.idbsu.edu/icons//previous_motif.gif"></A> 
<A NAME="tex2html793"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="http://cs.idbsu.edu/icons//contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html795"
 HREF="node59.html">Command abbreviations:</A>
<B> Up:</B> <A NAME="tex2html792"
 HREF="node55.html">Predeclared objects:</A>
<B> Previous:</B> <A NAME="tex2html788"
 HREF="node57.html">Predeclared theorems:</A>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Randall Holmes</I>
<BR><I>2000-11-03</I>
</ADDRESS>
</BODY>
</HTML>
